
<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GT Multi-User (Firestore Login) — v4.5 auto-sync</title>
  <style>
    :root { --bg:#0b0f16; --card:#111827; --muted:#6b7280; --text:#e5e7eb; --accent:#22c55e; --danger:#ef4444; --border:#1f2937; }
/* ==== RESPONSIVE FIX – idealne skalowanie na telefonach i małych laptopach ==== */
@media (max-width: 880px) {
  .card { 
    max-width: 96vw; 
    margin: 8px; 
    padding: 16px; 
    border-radius: 14px; 
  }
  .card h1 { font-size: 20px; }
  .card p.small { font-size: 13px; }
  input, button, select { 
    font-size: 15px !important; 
    padding: 11px 12px; 
  }
  .row { gap: 8px; }
  button { padding: 11px 10px; font-size: 14.5px; }
  .modal { 
    margin: 10px; 
    padding: 16px; 
    border-radius: 14px; 
    max-height: 94vh; 
  }
  .logo-wrap svg { width: 64px; height: 64px; }
  .logo-text { font-size: 17px; }
}

@media (max-width: 480px) {
  .card { padding: 14px; border-radius: 12px; }
  .card h1 { font-size: 19px; }
  input, button { font-size: 16px !important; } /* iOS nie zoomuje inputów < 16px */
  .topbar { bottom: 8px; left: 8px; }
  .pill { padding: 5px 9px; font-size: 11.5px; }
}


    html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial; }
    .center { position:relative; display:flex; align-items:center; justify-content:center; min-height:100%; overflow:hidden; }
    .card { width:100%; max-width:420px; background:var(--card); border:1px solid var(--border); border-radius:16px; padding:20px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
    .card h1 { font-size:22px; margin:0 0 8px; }
    .card p.small { color:var(--muted); margin:0 0 16px; }
    label { display:block; font-size:13px; color:var(--muted); margin:12px 0 6px; }
    input { width:100%; box-sizing:border-box; background:#0f172a; color:#e5e7eb; border:1px solid var(--border); border-radius:10px; padding:10px 12px; outline:none; }
    input:focus { border-color:var(--accent); box-shadow:0 0 0 3px rgba(34,197,94,.25); }
    .row { display:flex; gap:10px; margin-top:16px; flex-wrap:wrap; }
    button { flex:1; cursor:pointer; border:1px solid var(--border); border-radius:10px; padding:10px 12px; background:#0f172a; color:#e5e7eb; }
    button.primary { background:var(--accent); color:#001b0c; border-color:#16a34a; }
    button.link { background:transparent; border-color:transparent; text-decoration:underline; color:var(--muted); flex:none; }
    .error { color:var(--danger); font-size:13px; min-height:18px; margin-top:10px; }
    .hide { display:none !important; }
    #appContainer { position:fixed; inset:0; }
    #appFrame { width:100%; height:100%; border:0; background:#000; }
    .topbar { position:fixed; bottom:12px; left:12px; z-index:50; display:flex; gap:8px; align-items:center; pointer-events:none; }
    .pill { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid var(--border); font-size:12px; }
    .danger { background:rgba(239,68,68,.12); border-color:#7f1d1d; }
      .topbar > * { pointer-events:auto; }
  
    .checkbox-row {
      display:flex;
      align-items:center;
      gap:8px;
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
    }
    .checkbox-row input[type="checkbox"] {
      width:auto;
      flex:none;
      accent-color: var(--accent);
    }
    .checkbox-row a {
      color:var(--accent);
      text-decoration:underline;
      cursor:pointer;
    }
    .modal-overlay {
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.75);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:100;
    }
    .modal {
      width:100%;
      max-width:600px;
      max-height:80vh;
      background:var(--card);
      border-radius:16px;
      padding:20px;
      box-shadow:0 20px 40px rgba(0,0,0,.4);
      overflow:auto;
    }
    .modal h2 {
      margin-top:0;
      margin-bottom:10px;
      font-size:18px;
    }
    .modal h3 {
      margin-top:16px;
      margin-bottom:6px;
      font-size:15px;
    }
    .modal p, .modal li {
      font-size:13px;
      line-height:1.5;
      color:var(--muted);
    }
    .modal ul {
      padding-left:18px;
      margin:6px 0 10px;
    }
    .modal-footer {
      margin-top:16px;
      text-align:right;
    }
    .modal-footer button {
      flex:none;
      min-width:100px;
    }

    .logo-wrap {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      margin-bottom:16px;
    }
    .logo-wrap svg {
      max-width:260px;
      width:100%;
      height:auto;
      display:block;
    }

    .logo-wrap {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      margin-bottom:18px;
    }
    .logo-wrap svg {
      width:72px;
      height:72px;
      display:block;
    }
    .logo-text {
      margin-top:10px;
      font-size:18px;
      font-weight:600;
      letter-spacing:0.06em;
      text-transform:uppercase;
      color:#E5E7EB;
    }
    .logo-sub {
      margin-top:2px;
      font-size:11px;
      color:var(--muted);
    }


    /* Logo sizing override */
    .logo-wrap svg {
      max-width:240px;
      width:100%;
      height:auto;
      display:block;
    }

    .bg-svg {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      z-index:0;
      pointer-events:none;
    }
    #loginView .card {
      position:relative;
      z-index:1;
    }


    .app-logo-header {
      display:inline-flex;
      align-items:center;
      gap:8px;
      vertical-align:middle;
    }
    .app-logo-header svg {
      display:block;
      max-width:200px;
      height:auto;
    }

</style>
</head>

<body>
  

  <div id="loginView" class="center">
    <svg class="bg-svg" viewBox="0 0 1440 900" preserveAspectRatio="xMidYMid slice" aria-hidden="true">
    <defs>
      <linearGradient id="bg-grad-main" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" stop-color="#020617"/>
        <stop offset="45%" stop-color="#020617"/>
        <stop offset="100%" stop-color="#020617"/>
      </linearGradient>

      <linearGradient id="line-grad" x1="0%" y1="0%" x2="100%" y2="0%">
        <stop offset="0%" stop-color="#22C55E"/>
        <stop offset="45%" stop-color="#22C55E"/>
        <stop offset="75%" stop-color="#0EA5E9"/>
        <stop offset="100%" stop-color="#6366F1"/>
      </linearGradient>

      <filter id="line-glow" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="8" result="blur"/>
        <feColorMatrix
          in="blur"
          type="matrix"
          values="0 0 0 0 0.15
                  0 0 0 0 0.85
                  0 0 0 0 0.55
                  0 0 0 0.7 0"
          result="coloredBlur" />
        <feMerge>
          <feMergeNode in="coloredBlur"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>

      <style>
        .bg-root {
          fill: url(#bg-grad-main);
        }

        .bg-grid line {
          stroke: #111827;
          stroke-width: 1;
        }

        .bg-candle line {
          stroke-width: 2;
          stroke-linecap: round;
        }
        .bg-candle rect {
          stroke-width: 0;
          rx: 2;
        }
        .bg-candle-green rect { fill:#16a34a; }
        .bg-candle-green line { stroke:#16a34a; }
        .bg-candle-red rect   { fill:#dc2626; }
        .bg-candle-red line   { stroke:#dc2626; }

        .price-fill {
          fill: url(#line-grad);
          opacity: 0;
          animation: fill-fade 2.0s ease-out 1.0s forwards;
        }

        .price-line {
          fill: none;
          stroke: url(#line-grad);
          stroke-width: 2.8;
          stroke-linecap: round;
          stroke-linejoin: round;
          stroke-dasharray: 1500;
          stroke-dashoffset: 1500;
          animation: line-draw 3.0s ease-out 0.2s forwards;
        }

        .price-glow {
          fill: none;
          stroke: #22C55E;
          stroke-width: 6;
          opacity: 0;
          filter: url(#line-glow);
          stroke-dasharray: 1500;
          stroke-dashoffset: 1500;
          animation: line-glow-draw 3.0s ease-out 0.2s forwards;
        }

        .candles {
          opacity: 0;
          animation: candles-fade 2.0s ease-out 2.2s forwards;
        }

        .scene {
          animation: scene-drift 32s linear infinite alternate;
          animation-delay: 4.0s;
        }

        @keyframes line-draw {
          to { stroke-dashoffset: 0; }
        }

        @keyframes line-glow-draw {
          to { stroke-dashoffset: 0; opacity: 0.7; }
        }

        @keyframes fill-fade {
          to { opacity: 0.10; }
        }

        @keyframes candles-fade {
          to { opacity: 0.68; }
        }

        @keyframes scene-drift {
          0%   { transform: translateX(0); }
          100% { transform: translateX(-100px); }
        }

        @media (prefers-reduced-motion: reduce) {
          .scene {
            animation: none !important;
          }
          .price-line,
          .price-glow {
            animation: none !important;
            stroke-dasharray: none;
            stroke-dashoffset: 0;
          }
          .price-fill {
            animation: none !important;
            opacity: 0.10;
          }
          .candles {
            animation: none !important;
            opacity: 0.68;
          }
        }
      </style>
    </defs>

    <rect class="bg-root" width="1440" height="900"/>

    <g class="scene" transform="translate(-40,0)">
      <!-- grid -->
      <g class="bg-grid" opacity="0.22">
        <line x1="120" x2="120" y1="140" y2="780"/>
        <line x1="220" x2="220" y1="140" y2="780"/>
        <line x1="320" x2="320" y1="140" y2="780"/>
        <line x1="420" x2="420" y1="140" y2="780"/>
        <line x1="520" x2="520" y1="140" y2="780"/>
        <line x1="620" x2="620" y1="140" y2="780"/>
        <line x1="720" x2="720" y1="140" y2="780"/>
        <line x1="820" x2="820" y1="140" y2="780"/>
        <line x1="920" x2="920" y1="140" y2="780"/>
        <line x1="1020" x2="1020" y1="140" y2="780"/>
        <line x1="1120" x2="1120" y1="140" y2="780"/>
        <line x1="1220" x2="1220" y1="140" y2="780"/>
        <line x1="1320" x2="1320" y1="140" y2="780"/>

        <line x1="80" x2="1400" y1="200" y2="200"/>
        <line x1="80" x2="1400" y1="300" y2="300"/>
        <line x1="80" x2="1400" y1="400" y2="400"/>
        <line x1="80" x2="1400" y1="500" y2="500"/>
        <line x1="80" x2="1400" y1="600" y2="600"/>
        <line x1="80" x2="1400" y1="700" y2="700"/>
      </g>

      <!-- candles -->
      <g class="candles" opacity="0.68">
      <g class="bg-candle bg-candle-green">
        <line x1="120" y1="606.0" x2="120" y2="638.0"/>
        <rect x="116" y="620.0" width="8" height="12.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="140" y1="579.0" x2="140" y2="627.0"/>
        <rect x="136" y="596.0" width="8" height="12.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="160" y1="528.0" x2="160" y2="586.0"/>
        <rect x="156" y="548.0" width="8" height="25.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="180" y1="568.0" x2="180" y2="601.0"/>
        <rect x="176" y="579.0" width="8" height="8.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="200" y1="547.0" x2="200" y2="589.0"/>
        <rect x="196" y="567.0" width="8" height="15.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="220" y1="522.0" x2="220" y2="572.0"/>
        <rect x="216" y="534.0" width="8" height="23.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="240" y1="486.0" x2="240" y2="509.0"/>
        <rect x="236" y="492.0" width="8" height="8.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="260" y1="451.0" x2="260" y2="510.0"/>
        <rect x="256" y="470.0" width="8" height="24.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="280" y1="510.0" x2="280" y2="547.0"/>
        <rect x="276" y="516.0" width="8" height="11.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="300" y1="532.0" x2="300" y2="563.0"/>
        <rect x="296" y="541.0" width="8" height="10.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="320" y1="523.0" x2="320" y2="587.0"/>
        <rect x="316" y="537.0" width="8" height="33.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="340" y1="490.0" x2="340" y2="544.0"/>
        <rect x="336" y="506.0" width="8" height="28.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="360" y1="476.0" x2="360" y2="538.0"/>
        <rect x="356" y="494.0" width="8" height="28.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="380" y1="448.0" x2="380" y2="481.0"/>
        <rect x="376" y="462.0" width="8" height="6.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="400" y1="418.0" x2="400" y2="453.0"/>
        <rect x="396" y="426.0" width="8" height="13.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="420" y1="424.0" x2="420" y2="475.0"/>
        <rect x="416" y="436.0" width="8" height="21.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="440" y1="455.0" x2="440" y2="491.0"/>
        <rect x="436" y="461.0" width="8" height="24.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="460" y1="426.0" x2="460" y2="466.0"/>
        <rect x="456" y="439.0" width="8" height="18.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="480" y1="399.0" x2="480" y2="460.0"/>
        <rect x="476" y="409.0" width="8" height="33.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="500" y1="400.0" x2="500" y2="436.0"/>
        <rect x="496" y="416.0" width="8" height="10.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="520" y1="354.0" x2="520" y2="402.0"/>
        <rect x="516" y="370.0" width="8" height="20.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="540" y1="337.0" x2="540" y2="394.0"/>
        <rect x="536" y="344.0" width="8" height="35.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="560" y1="303.0" x2="560" y2="355.0"/>
        <rect x="556" y="317.0" width="8" height="27.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="580" y1="343.0" x2="580" y2="386.0"/>
        <rect x="576" y="350.0" width="8" height="24.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="600" y1="324.0" x2="600" y2="390.0"/>
        <rect x="596" y="342.0" width="8" height="34.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="620" y1="333.0" x2="620" y2="367.0"/>
        <rect x="616" y="340.0" width="8" height="13.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="640" y1="334.0" x2="640" y2="367.0"/>
        <rect x="636" y="340.0" width="8" height="16.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="660" y1="326.0" x2="660" y2="358.0"/>
        <rect x="656" y="332.0" width="8" height="8.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="680" y1="339.0" x2="680" y2="369.0"/>
        <rect x="676" y="351.0" width="8" height="7.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="700" y1="292.0" x2="700" y2="356.0"/>
        <rect x="696" y="308.0" width="8" height="32.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="720" y1="305.0" x2="720" y2="352.0"/>
        <rect x="716" y="325.0" width="8" height="15.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="740" y1="296.0" x2="740" y2="359.0"/>
        <rect x="736" y="313.0" width="8" height="27.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="760" y1="312.0" x2="760" y2="356.0"/>
        <rect x="756" y="323.0" width="8" height="17.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="780" y1="313.0" x2="780" y2="360.0"/>
        <rect x="776" y="332.0" width="8" height="8.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="800" y1="294.0" x2="800" y2="354.0"/>
        <rect x="796" y="312.0" width="8" height="28.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="820" y1="326.0" x2="820" y2="364.0"/>
        <rect x="816" y="340.0" width="8" height="14.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="840" y1="312.0" x2="840" y2="365.0"/>
        <rect x="836" y="332.0" width="8" height="17.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="860" y1="356.0" x2="860" y2="387.0"/>
        <rect x="856" y="368.0" width="8" height="8.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="880" y1="358.0" x2="880" y2="402.0"/>
        <rect x="876" y="372.0" width="8" height="19.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="900" y1="371.0" x2="900" y2="425.0"/>
        <rect x="896" y="378.0" width="8" height="31.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="920" y1="360.0" x2="920" y2="407.0"/>
        <rect x="916" y="378.0" width="8" height="14.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="940" y1="338.0" x2="940" y2="370.0"/>
        <rect x="936" y="350.0" width="8" height="14.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="960" y1="312.0" x2="960" y2="359.0"/>
        <rect x="956" y="325.0" width="8" height="18.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="980" y1="296.0" x2="980" y2="353.0"/>
        <rect x="976" y="307.0" width="8" height="33.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1000" y1="350.0" x2="1000" y2="394.0"/>
        <rect x="996" y="360.0" width="8" height="22.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="1020" y1="335.0" x2="1020" y2="389.0"/>
        <rect x="1016" y="343.0" width="8" height="32.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1040" y1="336.0" x2="1040" y2="375.0"/>
        <rect x="1036" y="355.0" width="8" height="6.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1060" y1="372.0" x2="1060" y2="424.0"/>
        <rect x="1056" y="386.0" width="8" height="30.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1080" y1="393.0" x2="1080" y2="422.0"/>
        <rect x="1076" y="407.0" width="8" height="8.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1100" y1="416.0" x2="1100" y2="478.0"/>
        <rect x="1096" y="433.0" width="8" height="34.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="1120" y1="400.0" x2="1120" y2="442.0"/>
        <rect x="1116" y="420.0" width="8" height="7.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1140" y1="375.0" x2="1140" y2="400.0"/>
        <rect x="1136" y="382.0" width="8" height="8.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1160" y1="377.0" x2="1160" y2="424.0"/>
        <rect x="1156" y="386.0" width="8" height="29.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1180" y1="395.0" x2="1180" y2="423.0"/>
        <rect x="1176" y="405.0" width="8" height="6.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="1200" y1="370.0" x2="1200" y2="421.0"/>
        <rect x="1196" y="384.0" width="8" height="30.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="1220" y1="412.0" x2="1220" y2="445.0"/>
        <rect x="1216" y="426.0" width="8" height="10.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="1240" y1="424.0" x2="1240" y2="476.0"/>
        <rect x="1236" y="433.0" width="8" height="33.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="1260" y1="469.0" x2="1260" y2="497.0"/>
        <rect x="1256" y="476.0" width="8" height="6.0"/>
      </g>
      <g class="bg-candle bg-candle-green">
        <line x1="1280" y1="488.0" x2="1280" y2="524.0"/>
        <rect x="1276" y="502.0" width="8" height="8.0"/>
      </g>
      <g class="bg-candle bg-candle-red">
        <line x1="1300" y1="471.0" x2="1300" y2="529.0"/>
        <rect x="1296" y="491.0" width="8" height="18.0"/>
      </g>
      </g>

      <!-- area under line -->
      <path class="price-fill" d="M 120 760 L 120 620 L 140 608 L 160 573 L 180 579 L 200 567 L 220 534 L 240 492 L 260 494 L 280 516 L 300 541 L 320 537 L 340 534 L 360 494 L 380 468 L 400 439 L 420 436 L 440 461 L 460 457 L 480 442 L 500 416 L 520 370 L 540 379 L 560 344 L 580 374 L 600 376 L 620 340 L 640 340 L 660 340 L 680 351 L 700 340 L 720 340 L 740 340 L 760 340 L 780 340 L 800 340 L 820 340 L 840 349 L 860 376 L 880 391 L 900 378 L 920 392 L 940 350 L 960 343 L 980 340 L 1000 360 L 1020 375 L 1040 355 L 1060 386 L 1080 407 L 1100 433 L 1120 427 L 1140 382 L 1160 386 L 1180 405 L 1200 414 L 1220 436 L 1240 466 L 1260 482 L 1280 502 L 1300 509 L 1300 760 L 120 760 Z"/>

      <!-- glow path -->
      <path class="price-glow" d="M 120 620 L 140 608 L 160 573 L 180 579 L 200 567 L 220 534 L 240 492 L 260 494 L 280 516 L 300 541 L 320 537 L 340 534 L 360 494 L 380 468 L 400 439 L 420 436 L 440 461 L 460 457 L 480 442 L 500 416 L 520 370 L 540 379 L 560 344 L 580 374 L 600 376 L 620 340 L 640 340 L 660 340 L 680 351 L 700 340 L 720 340 L 740 340 L 760 340 L 780 340 L 800 340 L 820 340 L 840 349 L 860 376 L 880 391 L 900 378 L 920 392 L 940 350 L 960 343 L 980 340 L 1000 360 L 1020 375 L 1040 355 L 1060 386 L 1080 407 L 1100 433 L 1120 427 L 1140 382 L 1160 386 L 1180 405 L 1200 414 L 1220 436 L 1240 466 L 1260 482 L 1280 502 L 1300 509"/>

      <!-- main price line -->
      <path class="price-line" d="M 120 620 L 140 608 L 160 573 L 180 579 L 200 567 L 220 534 L 240 492 L 260 494 L 280 516 L 300 541 L 320 537 L 340 534 L 360 494 L 380 468 L 400 439 L 420 436 L 440 461 L 460 457 L 480 442 L 500 416 L 520 370 L 540 379 L 560 344 L 580 374 L 600 376 L 620 340 L 640 340 L 660 340 L 680 351 L 700 340 L 720 340 L 740 340 L 760 340 L 780 340 L 800 340 L 820 340 L 840 349 L 860 376 L 880 391 L 900 378 L 920 392 L 940 350 L 960 343 L 980 340 L 1000 360 L 1020 375 L 1040 355 L 1060 386 L 1080 407 L 1100 433 L 1120 427 L 1140 382 L 1160 386 L 1180 405 L 1200 414 L 1220 436 L 1240 466 L 1260 482 L 1280 502 L 1300 509"/>
    </g>
  </svg>
<div class="card">
      
      <div class="logo-wrap">
  <svg
    width="260"
    height="80"
    viewBox="0 0 260 80"
    xmlns="http://www.w3.org/2000/svg"
    role="img"
    aria-labelledby="mwTitle mwDesc"
  >
    <title id="mwTitle">MyWallets</title>
    <desc id="mwDesc">Logo MyWallets z ikoną wykresu giełdowego i animowanym napisem</desc>

    <defs>
      <!-- Gradient tła ikony -->
      <linearGradient id="mw-grad" x1="0%" y1="0%" x2="120%" y2="120%">
        <stop offset="0%" stop-color="#22C55E">
          <animate attributeName="offset"
                   values="0;0.25;0"
                   dur="8s"
                   repeatCount="indefinite" />
        </stop>
        <stop offset="50%" stop-color="#0EA5E9">
          <animate attributeName="offset"
                   values="0.3;0.6;0.3"
                   dur="8s"
                   repeatCount="indefinite" />
        </stop>
        <stop offset="100%" stop-color="#6366F1">
          <animate attributeName="offset"
                   values="0.8;1;0.8"
                   dur="8s"
                   repeatCount="indefinite" />
        </stop>
      </linearGradient>

      <!-- Cień pod ikoną -->
      <filter id="mw-shadow" x="-50%" y="-50%" width="200%" height="200%">
        <feDropShadow dx="0" dy="4" stdDeviation="7" flood-opacity="0.28"/>
      </filter>

      <style>
        /* Animacje wejścia i „życia” logotypu */
        @keyframes mw-icon-pop {
          0%   { transform: translateY(8px) scale(0.7); opacity: 0; }
          60%  { transform: translateY(-2px) scale(1.05); opacity: 1; }
          100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        @keyframes mw-text-reveal {
          0%   { opacity: 0; transform: translateX(10px); }
          100% { opacity: 1; transform: translateX(0); }
        }

        @keyframes mw-underline-grow {
          0%   { transform: scaleX(0); opacity: 0; }
          40%  { opacity: 1; }
          100% { transform: scaleX(1); opacity: 1; }
        }

        @keyframes mw-dot-pulse {
          0%   { transform: scale(0.8); opacity: 0.5; }
          50%  { transform: scale(1.3); opacity: 1; }
          100% { transform: scale(0.8); opacity: 0.5; }
        }

        @keyframes mw-bars {
          0%   { transform: scaleY(0.4); }
          50%  { transform: scaleY(1.05); }
          100% { transform: scaleY(0.9); }
        }

        .mw-icon-wrap {
          transform-origin: 44px 40px;
          animation: mw-icon-pop 480ms cubic-bezier(0.18,0.89,0.32,1.28) 80ms both;
        }

        .mw-word-main {
          animation: mw-text-reveal 380ms ease-out 200ms both;
        }

        .mw-word-sub {
          animation: mw-text-reveal 380ms ease-out 320ms both;
        }

        .mw-underline {
          transform-origin: left center;
          animation: mw-underline-grow 420ms ease-out 380ms both;
        }

        .mw-dot {
          transform-origin: center;
          animation: mw-dot-pulse 1.8s ease-in-out 700ms infinite;
        }

        .mw-bar {
          transform-origin: center bottom;
          animation: mw-bars 2.2s ease-in-out infinite;
        }
        .mw-bar-1 { animation-delay: 0.0s; }
        .mw-bar-2 { animation-delay: 0.3s; }
        .mw-bar-3 { animation-delay: 0.6s; }

        /* Szacunek dla prefers-reduced-motion */
        @media (prefers-reduced-motion: reduce) {
          .mw-icon-wrap,
          .mw-word-main,
          .mw-word-sub,
          .mw-underline,
          .mw-dot,
          .mw-bar {
            animation: none !important;
          }
        }

        text {
          font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                       sans-serif;
        }
      </style>
    </defs>

    <!-- LEWA STRONA: ikona wykresu giełdowego -->
    <g class="mw-icon-wrap" transform="translate(10, 8)">
      <!-- Tło / karta -->
      <rect
        x="4"
        y="8"
        width="80"
        height="56"
        rx="18"
        ry="18"
        fill="url(#mw-grad)"
        filter="url(#mw-shadow)"
      />

      <!-- Delikatna linia „osi X” -->
      <line
        x1="18"
        y1="54"
        x2="72"
        y2="54"
        stroke="rgba(15,23,42,0.85)"
        stroke-width="2"
        stroke-linecap="round"
      />

      <!-- Słupki wykresu (animowane) -->
      <rect
        class="mw-bar mw-bar-1"
        x="22"
        y="40"
        width="8"
        height="14"
        rx="2"
        fill="#bbf7d0"
      />
      <rect
        class="mw-bar mw-bar-2"
        x="36"
        y="34"
        width="8"
        height="20"
        rx="2"
        fill="#86efac"
      />
      <rect
        class="mw-bar mw-bar-3"
        x="50"
        y="28"
        width="8"
        height="26"
        rx="2"
        fill="#4ade80"
      />

      <!-- Linia trendu + strzałka w górę -->
      <polyline
        points="20,48 32,42 44,38 58,30"
        fill="none"
        stroke="#fefce8"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      />
      <polygon
        points="58,30 62,26 62,33"
        fill="#fefce8"
      />

      <!-- Mała kropka „sygnał / alert” -->
      <circle
        class="mw-dot"
        cx="64"
        cy="22"
        r="4"
        fill="#22C55E"
      />
    </g>

    <!-- PRAWA STRONA: czytelny napis (bez wchodzenia na ikonę) -->
    <g transform="translate(110, 22)">
      <!-- Główny napis -->
      <text class="mw-word-main" x="0" y="22" font-size="22" fill="#E5E7EB">
        <tspan fill="#22C55E">My</tspan>Wallets
      </text>

      <!-- Podtytuł -->
      <text class="mw-word-sub" x="0" y="40" font-size="11" fill="#9CA3AF">
        investment portfolios &amp; alerts
      </text>

      <!-- Podkreślenie pod napisem -->
      <rect
        class="mw-underline"
        x="0"
        y="26"
        width="132"
        height="2"
        rx="1"
        fill="#22C55E"
        fill-opacity="0.7"
      />
    </g>
  </svg>
</div>

      <h1>Zaloguj się</h1>
      <p class="small">Lub utwórz nowe konto.</p>
      <label for="email">Email</label>
      <input id="email" type="email" autocomplete="email" placeholder="you@example.com" />
      <label for="password">Hasło</label>
      <input id="password" type="password" autocomplete="current-password" placeholder="min. 6 znaków" />
            <label class="checkbox-row">
        <input id="acceptTerms" type="checkbox" />
        <span>Akceptuję <a href="#" id="termsLink">regulamin i zasady prywatności</a></span>
      </label>
<div class="row">
        <button id="loginBtn" class="primary">Zaloguj</button>
        <button id="signupBtn">Utwórz konto</button> </div>
      <button id="resetBtn" class="link" type="button">Zapomniałem hasła</button>
      <div id="err" class="error"></div>
    </div>
  </div>

  <div id="termsOverlay" class="modal-overlay hide">
    <div class="modal">
      <h2>Regulamin i zasady prywatności (wersja testowa)</h2>
      <p class="small">Poniżej znajdziesz zwięzłe zasady korzystania z aplikacji w wersji beta.</p>
      <h3>1. Informacje ogólne</h3>
      <p>Aplikacja służy do testowego zarządzania portfelami inwestycyjnymi. Jest to wersja rozwojowa (beta), udostępniona ograniczonej grupie użytkowników do celów testowych.</p>
      <h3>2. Charakter aplikacji (brak doradztwa inwestycyjnego)</h3>
      <p>Aplikacja nie świadczy usług doradztwa inwestycyjnego. Wszystkie decyzje inwestycyjne podejmujesz samodzielnie, na własne ryzyko. Dane rynkowe mogą być opóźnione lub niepełne.</p>
      <h3>3. Dane przetwarzane w aplikacji</h3>
      <p>W ramach korzystania z aplikacji mogą być przetwarzane w szczególności:</p>
      <ul>
        <li>adres email i hasło (do logowania)*,</li>
        <li>dane portfeli i transakcji (nazwy portfeli, tickery, ilości, ceny, waluty),</li>
        <li>ustawienia użytkownika (waluta domyślna, zezwolenie na saldo ujemne, częstotliwość odświeżania, klucze API do serwisów z danymi rynkowymi),</li>
        <li>dane techniczne (logi błędów, podstawowe dane o urządzeniu/przeglądarce).</li>
      </ul>
      <p>* Hasło jest przechowywane po stronie Firebase (Firebase Authentication) w postaci zaszyfrowanej (hashowanej). Jako administrator aplikacji nie mam możliwości odczytania treści Twojego hasła.</p>

      <h3>4. Zasady prywatności</h3>
      <p>Dane są wykorzystywane wyłącznie w celu umożliwienia działania aplikacji, poprawy jej jakości oraz analizy błędów. Dane nie są sprzedawane osobom trzecim. Zewnętrzne serwisy (np. dostawcy danych giełdowych) mogą przetwarzać dane zgodnie z własnymi regulaminami i politykami prywatności.</p>
      <p>Wszystkie dane związane z Twoim kontem (email, zaszyfrowane hasło, portfele, transakcje, ustawienia) są przechowywane w usługach Firebase Authentication oraz Cloud Firestore (Google).</p>

      <h3>5. Twoje prawa</h3>
      <p>Jako użytkownik masz prawo m.in. do:</p>
      <ul>
        <li>dostępu do swoich danych i ich poprawiania,</li>
        <li>usunięcia konta i danych (w aplikacji dostępna jest funkcja dezaktywacji konta),</li>
        <li>ograniczenia przetwarzania oraz zgłoszenia sprzeciwu,</li>
        <li>zgłoszenia skargi do odpowiedniego organu nadzorczego ds. ochrony danych osobowych.</li>
      </ul>
      <h3>6. Odpowiedzialność</h3>
      <p>Autor aplikacji dokłada starań, aby działała poprawnie, ale nie gwarantuje jej nieprzerwanego działania ani poprawności danych. Aplikacja jest przeznaczona wyłącznie do celów edukacyjnych i testowych. Korzystasz z niej na własną odpowiedzialność.</p>
      <h3>7. Kontakt</h3>
      <p>W sprawach związanych z regulaminem lub prywatnością danych skontaktuj się z administratorem aplikacji (np. pod adresem email wskazanym przez autora aplikacji).</p>
      <p>Kontakt do administratora aplikacji: <a href="mailto:filpod2@wp.pl">filpod2@wp.pl</a></p>

      <div class="modal-footer">
        <button id="closeTermsBtn">Zamknij</button>
      </div>
    </div>
  </div>


  <div id="verifyView" class="center hide">
    <div class="card">
      <h1>Potwierdź adres email</h1>
      <p class="small">Na adres <span id="verifyEmail"></span> wysłaliśmy link aktywacyjny.</p>
      <p class="small">Kliknij link w wiadomości, a następnie wróć tutaj.</p>
      <div class="row">
        <button id="resendVerifyBtn">Wyślij ponownie link</button>
        <button id="refreshVerifyBtn">Sprawdź ponownie</button>
      </div>
      <div id="verifyErr" class="error small"></div>
    </div>
  </div>


<div id="appContainer" class="hide">
    <div class="topbar">
      <span id="who" class="pill">—</span>
      <button id="logoutBtn" class="pill danger">Wyloguj</button>
    </div>
    <iframe id="appFrame" loading="eager"></iframe>

    <template id="appTemplate">
<!doctype html>
<html lang="pl">
<head>
<base href="__BASE__">

<script>
  // Global Finnhub demo token for all parts of the app (portfele + przegląd)
  var FINNHUB_DEMO_TOKEN = "d4dlki1r01qmhtc51ao0d4dlki1r01qmhtc51aog";
</script>

<!-- GT wrapper: LS adapter + Firestore stubs + firewall + auto-sync -->
<script>
(function(){
  const LS_PREFIX="GT_MultiUser_v1__";
  const PURGE_UNPREFIXED=false;

  // --- Network firewall: block Firebase/Firestore endpoints from inner app ---
  (function(){
    const BLOCK = /(^|\.)firebaseio\.com$|(^|\.)(gstatic|googleapis)\.com$|(^|\.)(firestore\.googleapis)\.com$/i;
    try{
      const _fetch = window.fetch;
      window.fetch = function(input, init){
        try {
          const url = (typeof input === 'string') ? input : (input && input.url) || '';
          const u = new URL(url, document.baseURI);
          if (BLOCK.test(u.hostname)) return Promise.reject(new Error('Blocked by iframe firewall: '+u.hostname));
        } catch(_e){}
        return _fetch.apply(this, arguments);
      };
    }catch(_e){}
    try{
      const _open = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function(method, url){
        try {
          const u = new URL(url, document.baseURI);
          if (BLOCK.test(u.hostname)) { this.__blocked_by_firewall__ = true; }
        } catch(_e){}
        return _open.apply(this, arguments);
      };
      const _send = XMLHttpRequest.prototype.send;
      XMLHttpRequest.prototype.send = function(){
        if (this.__blocked_by_firewall__) { this.abort(); throw new Error('Blocked by iframe firewall (XHR)'); }
        return _send.apply(this, arguments);
      };
    }catch(_e){}
  })();

  // --- LocalStorage adapter with prefix + optional purge of old keys ---
  (function(){
    const orig=window.localStorage;
    try{
      if(PURGE_UNPREFIXED){
        const toDel=[];
        for(let i=0;i<orig.length;i++){const k=orig.key(i); if(k && !k.startsWith(LS_PREFIX)) toDel.push(k);}
        toDel.forEach(k=>{try{orig.removeItem(k);}catch(_e){}});
      }
    }catch(_e){}
    const mapKey=(k)=>LS_PREFIX+k;
    const _set=orig.setItem.bind(orig);
    const _get=orig.getItem.bind(orig);
    const _rem=orig.removeItem.bind(orig);
    Storage.prototype.setItem=function(k,v){ try{_set(mapKey(k),v);}catch(_e){}; try{parent.postMessage({type:'storage_event',key:k,value:v},'*');}catch(_e){}; };
    Storage.prototype.getItem=function(k){ return _get(mapKey(k)); };
    Storage.prototype.removeItem=function(k){ try{_rem(mapKey(k));}catch(_e){}; try{parent.postMessage({type:'storage_event',key:k,value:null},'*');}catch(_e){}; };
    Storage.prototype.clear=function(){ try{const keys=[]; for(let i=0;i<orig.length;i++){const key=orig.key(i); if(key&&key.startsWith(LS_PREFIX)) keys.push(key);} keys.forEach(k=>_rem(k));}catch(_e){}; try{parent.postMessage({type:'storage_clear'},'*');}catch(_e){}; };
    window.addEventListener('message',(ev)=>{
      const msg=ev.data||{};
      if(msg.type==='storage_apply'&&msg.payload){
        Object.keys(msg.payload).forEach(k=>{ try{_set(mapKey(k),msg.payload[k]);}catch(_e){}; });
        try{
          if (typeof window.__GT_RELOAD_FROM_SNAPSHOT__ === 'function') {
            window.__GT_RELOAD_FROM_SNAPSHOT__(msg.payload);
          }
        }catch(_e){}
      } else if(msg.type==='set_clear_on_exit'){ window.__GT_CLEAR_ON_EXIT__=!!msg.value; }
    });
    window.addEventListener('beforeunload',()=>{
      if(window.__GT_CLEAR_ON_EXIT__){
        try{const keys=[]; for(let i=0;i<orig.length;i++){const key=orig.key(i); if(key&&key.startsWith(LS_PREFIX)) keys.push(key);} keys.forEach(k=>{try{_rem(k);}catch(_e){}});}catch(_e){}
      }
    });
    try{ parent.postMessage({type:'request_init'},'*'); }catch(_e){}
  })();

  // --- Firestore compat stubs backed by localStorage (key: GTFS_STORE) + auto-sync hook ---
  (function(){
    function noop(){}
    function resolved(v){ return Promise.resolve(v); }
    function now(){ return new Date().toISOString(); }

    const STUB_KEY = "GTFS_STORE";

    function loadStore(){
      try{ const raw = localStorage.getItem(STUB_KEY); if(!raw) return { c:{} }; return JSON.parse(raw); }catch(e){ return { c:{} }; }
    }
    function saveStore(store){
      try{ localStorage.setItem(STUB_KEY, JSON.stringify(store)); }catch(_e){}
    }
    const store = loadStore();

    function clone(v){ try{ return JSON.parse(JSON.stringify(v)); }catch(_e){ return v; } }
    function ensureCol(name){ if(!store.c[name]) store.c[name] = {}; return store.c[name]; }
    function makeId(){ return Math.random().toString(36).slice(2, 10) + Math.random().toString(36).slice(2, 10); }

    function makeDocSnapshot(id, data){
      return { id, exists: data != null, data: () => clone(data || {}) };
    }
    function makeQuerySnapshot(docs){
      const arr = (docs || []).map(d => ({ id: d.id, data: () => clone(d.data) }));
      return {
        empty: arr.length === 0,
        size: arr.length,
        docs: arr,
        forEach: (cb) => arr.forEach(doc => cb(doc))
      };
    }

    function applyWhere(arr, field, op, value){
      if (!arr) return [];
      if (op !== '==' && op !== 'in' && op !== 'array-contains' && op !== '>=' && op !== '<=' && op !== '>' && op !== '<') return arr;
      return arr.filter(item => {
        const v = item.data[field];
        switch(op){
          case '==': return v === value;
          case '>=': return v >= value;
          case '<=': return v <= value;
          case '>':  return v >  value;
          case '<':  return v <  value;
          case 'in': return Array.isArray(value) && value.includes(v);
          case 'array-contains': return Array.isArray(v) && v.includes(value);
        }
      });
    }

    function collectionRef(name){
      const api = {};
      api.doc = function(id){
        const docId = id || makeId();
        return {
          id: docId,
          get: () => { const col = ensureCol(name); const data = col[docId]; return resolved(makeDocSnapshot(docId, data)); },
          set: (data, opts) => { const col = ensureCol(name); col[docId] = (opts && opts.merge) ? Object.assign({}, col[docId]||{}, clone(data)) : clone(data); saveStore(store); return resolved(); },
          update: (patch) => { const col = ensureCol(name); col[docId] = Object.assign({}, col[docId]||{}, clone(patch)); saveStore(store); return resolved(); },
          delete: () => { const col = ensureCol(name); delete col[docId]; saveStore(store); return resolved(); },
          onSnapshot: (cb) => { const col = ensureCol(name); const data = col[docId]; try{ cb(makeDocSnapshot(docId, data)); }catch(_e){} return noop; }
        };
      };
      api.add = function(data){ const id = makeId(); const col = ensureCol(name); col[id] = clone(data); saveStore(store); return resolved({ id }); };

      function queryObj(list){
        const q = {};
        q._list = list || Object.entries(ensureCol(name)).map(([id,data]) => ({ id, data }));
        q.where = function(field, op, value){ q._list = applyWhere(q._list, field, op, value); return q; };
        q.orderBy = function(field, dir){ q._list.sort((a,b)=>{ if (a.data[field] == b.data[field]) return 0; return (a.data[field] < b.data[field] ? -1 : 1) * (dir==='desc'?-1:1); }); return q; };
        q.limit = function(n){ q._list = q._list.slice(0, n); return q; };
        q.startAfter = function(){ return q; };
        q.endBefore = function(){ return q; };
        q.get = function(){ return resolved(makeQuerySnapshot(q._list)); };
        q.onSnapshot = function(cb){ try{ cb(makeQuerySnapshot(q._list)); }catch(_e){}; return noop; };
        return q;
      }
      api.where = function(field, op, value){ return queryObj().where(field, op, value); };
      api.get = function(){ return queryObj().get(); };
      api.onSnapshot = function(cb){ return queryObj().onSnapshot(cb); };

      return api;
    }

    if (!window.firebase) window.firebase = {};
    window.firebase.apps = [{}];
    window.firebase.initializeApp = function(){ return {}; };
    window.firebase.firestore = function(){ return { collection: collectionRef, doc: (id)=>collectionRef('_root').doc(id), FieldValue: { serverTimestamp: () => ({ __serverTimestamp:true, at: now() }) } }; };
    window.firebase.firestore.FieldValue = { serverTimestamp: () => ({ __serverTimestamp:true, at: now() }) };
    window.firebase.auth = function(){ return { setPersistence: ()=>resolved(), signInAnonymously: ()=>resolved({ user:{ uid:'stub' } }), currentUser: { uid:'stub' }, onAuthStateChanged: (cb)=>{ try{ cb({ uid:'stub' }); }catch(_e){}; return ()=>{}; } }; };
    window.firebase.auth.Auth = { Persistence: { LOCAL:'LOCAL', SESSION:'SESSION', NONE:'NONE' } };
    console.log("GT Firestore stub: ready");

    // --- Auto-sync handler from wrapper ---
    function seedStubFromLocal(){
      try{
        const LS_KEY = (typeof detectLSKey==='function') ? detectLSKey() : 'portfele_firmy_v1';
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return false;
        let data=null; try{ data = JSON.parse(raw); }catch(_e){ return false; }
        const FB_COL = (typeof window.FB_COL!=='undefined') ? window.FB_COL : 'gt_portfolios';
        const FB_DOC = (typeof window.FB_DOC!=='undefined') ? window.FB_DOC : 'default';
        const col = ensureCol(FB_COL);
        col[FB_DOC] = clone(data);
        saveStore(store);
        return true;
      }catch(_e){
        console.warn('seedStubFromLocal error', _e);
        return false;
      }
    }

    function tryHardDownload(){
      try{
        if (typeof hardDownload==='function'){
          return hardDownload(true);
        }
      }catch(_e){ console.warn('hardDownload call error', _e); }
      return Promise.resolve(false);
    }

    window.addEventListener('message', (ev)=>{
      const msg = ev.data||{};
      if (msg.type==='auto_sync'){
        const seeded = seedStubFromLocal();
        // nawet jeśli nie udało się zasilić, spróbuj pobrać
        tryHardDownload();
      }
    });
  })();
})();
</script>


  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portfele — v2</title>
  <style>
    :root{
      --bg:#0f172a;        /* slate-900 */
      --panel:#111827;     /* gray-900 */
      --panel-2:#1f2937;   /* gray-800 */
      --muted:#94a3b8;     /* slate-400 */
      --text:#e5e7eb;      /* gray-200 */
      --accent:#22d3ee;    /* cyan-400 */
      --accent-2:#06b6d4;  /* cyan-500 */
      --danger:#ef4444;    /* red-500 */
      --ok:#10b981;        /* emerald-500 */
      --warn:#f59e0b;      /* amber-500 */
      --shadow: 0 10px 25px rgba(0,0,0,.35);
      --radius: 14px;
    }
    *{ box-sizing: border-box; }
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Noto Sans, Ubuntu, Cantarell, Arial, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;
      background: linear-gradient(120deg,#0b1222 0%,#0f172a 40%, #101525 100%);
      color: var(--text);
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 18px; position:static; top:0; z-index:5;
      background: linear-gradient(0deg, rgba(15,23,42,.6), rgba(15,23,42,.6));
      backdrop-filter: blur(8px);
      border-bottom: 1px solid #111827;
      box-shadow: var(--shadow);
    }
    header h1{ margin:0; font-weight:700; font-size: clamp(18px, 2vw, 22px); letter-spacing:.3px; }
    header .actions{ display:flex; gap:8px; flex-wrap:wrap; margin-left:12px; }
    .btn{
      border:none; border-radius:10px;
      padding:10px 14px; color:#0b1222; font-weight:600;
      background: var(--accent); cursor:pointer;
      transition:.2s transform ease, .2s box-shadow ease, .2s filter ease;
      box-shadow: 0 8px 20px rgba(34,211,238,.25);
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.05); }
    .btn:active{ transform: translateY(0px) scale(.98); }
    .btn.secondary{ background:#334155; color: var(--text); box-shadow:none; }
    .btn.ghost{ background: transparent; color: var(--text); border:1px solid #334155; }
    .btn.warn{ background: var(--warn); color:#0b1222; }
    .btn.danger{ background: var(--danger); color:#fff; }
    .btn.ok{ background: var(--ok); color:#0b1222; }
    .layout{ display:grid; grid-template-columns: 330px 1fr; gap:14px; padding:14px; }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }
    .card{
      background: linear-gradient(180deg, rgba(17,24,39,.85), rgba(16,23,42,.92));
      border:1px solid #1f2937;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .sidebar{ padding:14px; min-height: calc(100svh - 80px); }
    .sidebar .head{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    .portfolios{ display:flex; flex-direction:column; gap:8px; }
    .portfolio-item{
      padding:10px; border-radius:12px; border:1px solid #1f2937;
      background: linear-gradient(180deg, #0f172a, #0b1222);
      cursor:pointer; transition:.15s ease;
    }
    .portfolio-item:hover{ border-color:#334155; }
    .portfolio-item.active{ border-color: var(--accent); box-shadow: 0 0 0 1px inset var(--accent); }
    .portfolio-item .name{ font-weight:700; font-size:15px; }
    .portfolio-item .row{ display:flex; justify-content:space-between; gap:8px; color: var(--muted); font-size:13px; margin-top:4px; }
    .main{ padding:14px; display:flex; flex-direction:column; gap:14px; }
    .panel{ padding:14px; }
    .panel h2{ margin:0 0 10px 0; font-size:18px; }
    .grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:14px; }
    .col-4{ grid-column: span 4; } .col-6{ grid-column: span 6; } .col-8{ grid-column: span 8; } .col-12{ grid-column: span 12; }
    @media (max-width: 980px){ .col-4,.col-6,.col-8{ grid-column: span 12; } }
    .stat{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px; border-radius:12px; background:#0b1222; border:1px solid #1f2937;
    }
    .muted{ color: var(--muted); }
    .row{ display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .spacer{ flex: 1 1 auto; }
    textarea, input, select{
      width:100%; padding:10px 12px; border-radius:10px; border:1px solid #334155; background:#0b1222;
      color:var(--text); outline:none; font-size:14px;
    }
    label{ display:block; font-size:13px; color: var(--muted); margin-bottom:6px; }
    table{ width:100%; border-collapse: collapse; }
    th, td{ text-align:left; padding:10px; border-bottom:1px solid #1f2937; vertical-align: top; }
    th{ color: #cbd5e1; font-weight:700; background:#0b1222; position:sticky; top:0; }
    tr:hover td{ background: rgba(3, 7, 18, .4); }
    .ticker{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; letter-spacing:.3px; font-weight:700; }
    details summary{ cursor:pointer; user-select:none; }
    .tag{ padding:4px 8px; border-radius:999px; background:#111827; border:1px solid #1f2937; font-size:12px; color:#cbd5e1; }
    footer{ color:var(--muted); text-align:center; padding:18px 8px; }
    dialog{ border:none; border-radius:16px; padding:0; background:transparent; 
      color: var(--text);
}
    .modal{
      color: var(--text);
 background: linear-gradient(180deg, rgba(17,24,39,.98), rgba(15,23,42,.98)); border:1px solid #334155; border-radius:16px; width:min(720px, 96vw); box-shadow: var(--shadow); }
    .modal header{ position:static; top:0; background:transparent; box-shadow:none; border:none; padding:14px; }
    .modal .content{ padding:14px; }
    .modal footer{ display:flex; gap:8px; justify-content:flex-end; padding:14px; }
    .small{ font-size:12px; color:var(--muted); }
    .note{ font-size:13px; color:#e5e7eb; opacity:.9; }
    .danger-text{ color: var(--danger); }
    .ok-text{ color: var(--ok); }
    
.warn-text{ color: var(--warn, #ffb020); }
.warn-strong-text{ color:#ff6a00; font-weight:600; }
/* Percentage badge helper */
.pct-badge{ font-weight:700; padding:2px 6px; border-radius:8px; background: rgba(255,255,255,.04); display:inline-block; min-width:62px; text-align:right; }
.pct-pos{ color: var(--ok); }
.pct-neg{ color: var(--danger); }
.center{ text-align:center; }
    .link{ color: var(--accent); cursor:pointer; text-decoration: underline; }
  
    .near-target{ animation: pulse 1.2s infinite; }
    .hit-target{ animation: pulse-strong 0.8s infinite; }
    @keyframes pulse{
      0%{ box-shadow: 0 0 0 0 rgba(16,185,129,.35); }
      50%{ box-shadow: 0 0 0 6px rgba(16,185,129,.05); background: rgba(16,185,129,.06); }
      100%{ box-shadow: 0 0 0 0 rgba(16,185,129,.0); }
    }
    @keyframes pulse-strong{
      0%{ box-shadow: 0 0 0 0 rgba(34,197,94,.6); }
      50%{ box-shadow: 0 0 0 10px rgba(34,197,94,.12); background: rgba(34,197,94,.12); }
      100%{ box-shadow: 0 0 0 0 rgba(34,197,94,.0); }
    }

  
  /* === Collapsible History === */
  #historyPanel #txTableWrap { transition: max-height 0.25s ease; }
  #historyPanel.collapsed #txTableWrap { max-height: 0; overflow: hidden; padding: 0; margin: 0; border: 0; }
  #historyPanel.collapsed #filterQuery, 
  #historyPanel.collapsed label[for="filterQuery"] { display: none; }
  #historyPanel .clickable { cursor: pointer; }
  #historyPanel .chev { display:inline-block; transition: transform .2s ease; }
  #historyPanel.collapsed .chev { transform: rotate(-90deg); }


/* === Colored blinking for BUY (red) and SELL (green) === */
@keyframes blinkRed { 0%{outline-color: transparent;} 50%{outline-color: rgba(220,38,38,0.9);} 100%{outline-color: transparent;} }
@keyframes blinkGreen { 0%{outline-color: transparent;} 50%{outline-color: rgba(16,185,129,0.9);} 100%{outline-color: transparent;} }

.hit-target-sell   { outline: 3px solid; animation: blinkGreen 1s infinite;    }
.near-target-sell  { outline: 2px dashed; animation: blinkGreen 1.6s infinite; }
.hit-target-buy    { outline: 3px solid; animation: blinkRed 1s infinite;  }
.near-target-buy   { outline: 2px dashed; animation: blinkRed 1.6s infinite; }

/* compatibility (old generic classes) */
.hit-target { outline: 3px solid; animation: blinkRed 1.2s infinite; }
.near-target{ outline: 2px dashed; animation: blinkRed 2s infinite; }

/* === Mobile tweaks === */
@media (max-width: 980px){
  .layout{ grid-template-columns: 1fr; padding:10px; gap:10px; }
  .sidebar{ min-height: auto; }
  main{ padding:10px; gap:10px; }
  header{ padding:10px; }
  header .actions{ gap:6px; }
  header .actions > *{ flex: 1 1 48%; } /* 2 per row */
  .panel{ padding:10px; }
  .grid{ gap:10px; }
  th, td{ padding:8px; }
  .btn{ padding:10px 12px; font-size:14px; }
}

@media (max-width: 640px){
  header h1{ display:flex; flex-direction:column; gap:8px; }
  header h1 .btn{ align-self:flex-start; }
  header .actions > *{ flex: 1 1 100%; } /* full width */
  .table-wrap{ overflow-x:auto; -webkit-overflow-scrolling: touch; }
  table{ min-width: 640px; } /* enable horizontal scroll for wide tables */
  .ticker{ font-size:13px; }
  th, td{ font-size:13px; }
}
/* === Daily change arrows === */
.change-arrow{ font-weight: 700; margin-right: 4px; }
.change-arrow.up{ color: var(--ok); }
.change-arrow.down{ color: var(--danger); }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<!-- Firebase SDKs (compat) -->
  
<script>
/* === Early TX helpers shim (ensureBuyLotIdInTx / applyCash) [GO] === */
(function(){
  try{
    if (typeof window.ensureBuyLotIdInTx !== 'function') {
      window.ensureBuyLotIdInTx = function(tx){
        try{
          if(tx && tx.type==='buy' && !tx.lotId){
            tx.lotId = tx.id || ('lot_'+Date.now().toString(36)+'_'+Math.random().toString(36).slice(2));
          }
        }catch(_){}
      };
    }
    if (typeof window.__go_applyCashShim !== 'function') {
      window.__go_applyCashShim = function(state, type, amount){
        const a = Number(amount)||0;
        if(!state || !type) return;
        if(type==='deposit' || type==='transfer_in'){ state.cash = (Number(state.cash)||0) + a; return; }
        if(type==='withdraw' || type==='transfer_out'){ state.cash = (Number(state.cash)||0) - a; return; }
        // else ignore
      };
    }
  }catch(_){}
})();
/* === end early TX shims === */

</script>
<script>
/* === Lightweight apply* fallbacks for GO chart (used only if app versions not yet loaded) === */
(function(){
  function __go_book(state, tkr){
    state.holdings = state.holdings || {};
    if(!state.holdings[tkr]) state.holdings[tkr] = { qty: 0, lots: [] };
    const b = state.holdings[tkr];
    b.lots = Array.isArray(b.lots) ? b.lots : [];
    b.qty = Number(b.qty)||0;
    return b;
  }
  function __go_consumeLots(book, qty, links){
    let left = Number(qty)||0;
    if(!book || !Array.isArray(book.lots)) return 0;
    // If explicit lotLinks provided, consume those first
    if(Array.isArray(links) && links.length){
      for(const ln of links){
        if(left<=0) break;
        const id = ln.lotId; let rq = Number(ln.qty)||0;
        for(const lot of book.lots){
          if(left<=0) break;
          if(id && lot.lotId===id){
            const take = Math.min(lot.qty||0, rq, left);
            lot.qty = (lot.qty||0) - take;
            book.qty = (book.qty||0) - take;
            left -= take; rq -= take;
          }
        }
      }
    }
    // FIFO for the rest
    for(const lot of book.lots){
      if(left<=0) break;
      const take = Math.min(lot.qty||0, left);
      lot.qty = (lot.qty||0) - take;
      book.qty = (book.qty||0) - take;
      left -= take;
    }
    // cleanup empty lots
    book.lots = book.lots.filter(l => (l.qty||0) > 0);
    return left; // remaining (if >0, not enough qty)
  }
  if(typeof window.__go_applyBuy !== 'function'){
    window.__go_applyBuy = function(state, pf, tx){
      const tkr = String(tx.ticker||'').trim().toUpperCase();
      const q = Number(tx.qty)||0, p = Number(tx.price)||0, f = Number(tx.fees)||0;
      state.cash = (Number(state.cash)||0) - (q*p + f);
      try{ if(typeof ensureBuyLotIdInTx==='function') ensureBuyLotIdInTx(tx); }catch(_){}
      const book = __go_book(state, tkr);
      const lot = { lotId: tx.lotId || ('lot_'+Math.random().toString(36).slice(2)), qty: q, price: p };
      book.lots.push(lot);
      book.qty = (book.qty||0) + q;
    };
  }
  if(typeof window.__go_applySell !== 'function'){
    window.__go_applySell = function(state, pf, tx){
      const tkr = String(tx.ticker||'').trim().toUpperCase();
      const q = Number(tx.qty)||0, p = Number(tx.price||tx.sellPrice||0), f = Number(tx.fees)||0;
      state.cash = (Number(state.cash)||0) + (q*p - f);
      const book = __go_book(state, tkr);
      __go_consumeLots(book, q, Array.isArray(tx.lotLinks)?tx.lotLinks:[]);
    };
  }
  if(typeof window.__go_applyTransferCompanyIn !== 'function'){
    window.__go_applyTransferCompanyIn = function(state, pf, tx){
      const tkr = String(tx.ticker||'').trim().toUpperCase();
      const q = Number(tx.qty)||0, p = Number(tx.price)||0;
      const book = __go_book(state, tkr);
      book.lots.push({ lotId: tx.lotId || ('lot_'+Math.random().toString(36).slice(2)), qty: q, price: p });
      book.qty = (book.qty||0) + q;
    };
  }
  if(typeof window.__go_applyTransferCompanyOut !== 'function'){
    window.__go_applyTransferCompanyOut = function(state, pf, tx){
      const tkr = String(tx.ticker||'').trim().toUpperCase();
      const q = Number(tx.qty)||0;
      const book = __go_book(state, tkr);
      __go_consumeLots(book, q, Array.isArray(tx.lotLinks)?tx.lotLinks:[]);
    };
  }
})();
/* === end lightweight apply* fallbacks === */
</script>
<script>
/* === Early currency formatter shim (before app boot) [GO] === */
(function(){
  try{
    if (typeof window.__go_fmtCurrency !== 'function') {
      window.__go_fmtCurrency = function(v, code){
        try { if (typeof fmtCurrency === 'function') return fmtCurrency(v, code); } catch(_) {}
        try { return new Intl.NumberFormat(undefined, { style:'currency', currency:(code||'PLN') }).format(v||0); }
        catch(_) { return String(Math.round((v||0)*100)/100) + ' ' + (code||''); }
      };
    }
  }catch(_){}
})();
/* === end shim === */
</script>

  
  


<script>
// Global shims to avoid ReferenceError when __fmtNum / __esc are used before module loads
window.__esc = window.__esc || function(s){
  try{ if(typeof window.escapeHtml==='function') return window.escapeHtml(String(s||'')); }catch(_){}
  const t = document.createElement('textarea'); t.textContent = String(s||''); return t.innerHTML;
};
window.__fmtNum = window.__fmtNum || function(v){
  try{ if(typeof window.fmtNum==='function') return window.fmtNum(v); }catch(_){}
  const n = Number(v); if(!isFinite(n)) return '—';
  return n.toLocaleString(undefined, {maximumFractionDigits: 2});
};
</script>
<script>
// === Global date helpers shim (added by fix) ===
window.toMs = window.toMs || function(d){
  try{
    if (d == null) return NaN;
    if (typeof d === 'number') return d;
    if (d instanceof Date) return d.getTime();
    if (d && typeof d.toDate === 'function') return d.toDate().getTime();
    if (d && typeof d.seconds !== 'undefined') return Number(d.seconds) * 1000;
    const ms = Date.parse(String(d));
    return Number.isFinite(ms) ? ms : NaN;
  }catch(_){ return NaN; }
};

window.inRangeMs = window.inRangeMs || function(ms, range){
  if (!range) return true;
  if (!Number.isFinite(ms)) return false;
  const s = Number(((range && range.start) ?? -Infinity));
  const e = Number(((range && range.end) ?? Infinity));
  return ms >= s && ms <= e;
};
</script>


<style>
#toastsWrap{position:fixed;right:10px;bottom:10px;z-index:9999;display:flex;flex-direction:column;gap:8px;max-width:92vw}
.toast{padding:10px 12px;border-radius:10px;box-shadow:0 4px 14px rgba(0,0,0,.2);background:var(--table-bg, #f8f9fa);color:var(--text-color,#111);font-size:.9rem;opacity:.98;display:flex;align-items:center;gap:8px}
.toast.hit{border-left:4px solid #16a34a}
.toast.near{border-left:4px solid #d97706}
.toast .time{opacity:.6;font-size:.8rem;margin-left:auto}
#alertsTabBtn .badge{margin-left:6px;padding:0 6px;border-radius:10px;background:#ef4444;color:#fff;font-size:.75rem;display:inline-block}

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<style>
/* Disable blinking inside Alerts panel */
#alertsPanel .hit-target-sell, 
#alertsPanel .hit-target-buy, 
#alertsPanel .near-target-sell, 
#alertsPanel .near-target-buy { animation: none !important; }
/* Use non-blinking styles for rows */
#alertsPanel tr.state-hit  { border-left: 4px solid rgba(34,197,94,.9); }   /* green */
#alertsPanel tr.state-near { border-left: 4px solid rgba(245,158,11,.9); }  /* amber */
#alertsPanel tr.state-hit, #alertsPanel tr.state-near { background: inherit; }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style>
/* === Global Dark Theme for ALL modals/popups === */
:root{
  --__modal-bg: var(--surface, #0f172a);
  --__modal-bg2: var(--surface-2, #0b1220);
  --__modal-text: var(--text, #e5e7eb);
  --__modal-muted: var(--muted, #94a3b8);
  --__modal-border: var(--border-color, #334155);
  --__modal-ring: var(--accent, #60a5fa);
  --__backdrop: rgba(2,6,23,0.66);
}

/* Native <dialog> */
dialog, [role="dialog"], .modal, .popup, .dialog, .app-modal, .app-popup {
  background:
    linear-gradient(180deg, color-mix(in oklab, var(--__modal-bg) 98%, transparent),
                           color-mix(in oklab, var(--__modal-bg2) 98%, transparent));
  color: var(--__modal-text);
  border: 1px solid var(--__modal-border);
  border-radius: 16px;
  box-shadow: 0 12px 28px rgba(0,0,0,.35);
}

/* Ensure common inner wrappers inherit */
dialog .modal-content,
.modal .modal-content,
.popup .modal-content,
[role="dialog"] .modal-content { background: transparent; color: inherit; border: 0; }

/* Backdrop for native <dialog> */
dialog::backdrop { 
  background: var(--__backdrop);
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
}

/* Generic overlay/backdrop classes used by custom modals */
.backdrop, .overlay, .modal-backdrop, .popup-backdrop {
  background: var(--__backdrop) !important;
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
}

/* Head/foot areas */
.modal-header, .popup-header {
  border-bottom: 1px solid var(--__modal-border);
  padding: 12px 16px;
}
.modal-footer, .popup-footer {
  border-top: 1px solid var(--__modal-border);
  padding: 12px 16px;
  display: flex; gap: 12px; justify-content: flex-end; align-items: center;
}

/* Controls */
.modal input, .modal textarea, .modal select,
dialog input, dialog textarea, dialog select,
.popup input, .popup textarea, .popup select,
[role="dialog"] input, [role="dialog"] textarea, [role="dialog"] select {
  background: var(--surface-2, #111827);
  color: var(--__modal-text);
  border: 1px solid var(--__modal-border);
  border-radius: 12px;
  padding: 10px 12px;
  outline: none;
}
.modal input::placeholder, .modal textarea::placeholder,
dialog input::placeholder, dialog textarea::placeholder,
.popup input::placeholder, .popup textarea::placeholder,
[role="dialog"] input::placeholder, [role="dialog"] textarea::placeholder {
  color: color-mix(in oklab, var(--__modal-muted) 80%, transparent);
}
.modal input:focus, .modal textarea:focus, .modal select:focus,
dialog input:focus, dialog textarea:focus, dialog select:focus,
.popup input:focus, .popup textarea:focus, .popup select:focus,
[role="dialog"] input:focus, [role="dialog"] textarea:focus, [role="dialog"] select:focus {
  box-shadow: 0 0 0 3px color-mix(in oklab, var(--__modal-ring) 30%, transparent);
  border-color: var(--__modal-ring);
}

/* Checkbox/Radio accent */
.modal input[type="checkbox"], .modal input[type="radio"],
dialog input[type="checkbox"], dialog input[type="radio"],
.popup input[type="checkbox"], .popup input[type="radio"],
[role="dialog"] input[type="checkbox"], [role="dialog"] input[type="radio"]{
  accent-color: var(--__modal-ring);
}

/* Close icon */
.modal .modal-x, dialog .modal-x, .popup .modal-x {
  color: var(--__modal-muted);
}
.modal .modal-x:hover, dialog .modal-x:hover, .popup .modal-x:hover {
  opacity: .9;
}

/* Buttons (use existing .btn styling if present) */
.modal .btn, dialog .btn, .popup .btn {
  border-radius: 12px;
  padding: 10px 14px;
  font-weight: 600;
}
.modal .btn.ghost, dialog .btn.ghost, .popup .btn.ghost {
  background: transparent;
  border: 1px solid var(--__modal-border);
  color: var(--__modal-muted);
}

/* Subtle enter animation; respects reduced motion */
@media (prefers-reduced-motion: no-preference){
  dialog[open], .modal, .popup, [role="dialog"] {
    animation: modalFadeIn .16s ease-out;
  }
  @keyframes modalFadeIn { from { opacity: .0; transform: scale(.98);} to { opacity: 1; transform: scale(1);} }
}


  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style>
/* === GO period chip polish === */
.go-chip-label{display:inline-block; margin-right:8px; opacity:.9; font-weight:600;}
#go-period{
  padding:4px 10px;
  border-radius:10px;
  border:1px solid var(--muted, rgba(128,128,128,.4));
  background: var(--bg-2, rgba(255,255,255,.05));
  outline:none;
}
#go-period:focus{ box-shadow:0 0 0 2px rgba(100,150,255,.25); }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style>
.company-name-display {
  display: block;
  font-size: 11px;
  color: var(--muted);
  font-weight: 400;
  margin-top: 2px;
  opacity: 0.85;
}



  

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style id="holdings-actions-align">
/* Align '+' and transfer buttons in holdings summary to the far right */
#holdingsTableWrap details > summary{
  display: flex;
  align-items: center;
  gap: 8px;
}
/* push the first small button to the right; the rest will follow */
#holdingsTableWrap details > summary .btn.small:first-of-type{
  margin-left: auto;
}

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style id="alerts-history-controls-fix">
/* Common class for the alerts history controls container */
.alerts-history-controls{
  display: flex !important;
  align-items: center;
  gap: 8px;
  white-space: nowrap;
  flex-wrap: nowrap;
}
/* Ensure button text color follows theme (same for both) */
.alerts-history-controls button,
.alerts-history-controls .btn,
.alerts-history-controls a[role="button"]{
  color: var(--foreground, inherit) !important;
}

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<style id="alerts-history-inline-fix2">
/* Force 'Odśwież' and 'Wyczyść' to sit inline and share text color */
#alertsPanel .filters .col-3,
#alertsPanel .filters .col,
#alertsPanel .filters .controls,
#alertsPanel .filters{
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
}
#alertsRefreshBtn, #alertsClearBtn{
  display: inline-flex !important;
  width: auto !important;
  min-width: 0 !important;
  flex: 0 0 auto !important;
  white-space: nowrap !important;
  vertical-align: middle !important;
}
/* unifying text color - match normal .btn dark text used on accent buttons */
#alertsClearBtn, #alertsRefreshBtn{
  color: #0b1222 !important;
}
/* subtle spacing if layout engine ignores gap */
#alertsRefreshBtn{ margin-right: 8px !important; }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style id="alerts-inline-controls-css">
.alerts-inline-controls{
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
}
/* keep buttons compact */
.alerts-inline-controls #alertsRefreshBtn,
.alerts-inline-controls #alertsClearBtn{
  display: inline-flex !important;
  flex: 0 0 auto !important;
  width: auto !important;
  min-width: 0 !important;
  white-space: nowrap !important;
}

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<style id="go-improved-chart-css-v3">
  .go-chart-wrap { position:relative; height: 640px; background: rgba(0,0,0,0.2); border-radius: 12px; border: 1px solid #1f2937; overflow: hidden; }
@media (max-width: 768px){ .go-chart-wrap{ height: 480px; } }
@media (min-width: 1400px){ .go-chart-wrap{ height: 740px; } }
  #go-line-chart { width:100%; height:100%; display:block; cursor: crosshair; }
  .chart-tooltip-improved {
    position: absolute;
    background: rgba(0,0,0,0.95);
    border: 2px solid #22d3ee;
    border-radius: 10px;
    padding: 14px 16px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    max-width: 340px;
    box-shadow: 0 8px 24px rgba(34,211,238,0.3);
    display: none;
    backdrop-filter: blur(6px);
    min-width: 280px;
  }
  .chart-tooltip-improved.visible { display: block; }
  .tooltip-row-improved{
    display:flex; justify-content:space-between; gap:12px;
    margin:6px 0; padding:4px 0; border-bottom:1px solid rgba(148,163,184,0.2);
  }
  .tooltip-row-improved:last-child{ border-bottom:none; }
  .tooltip-label-improved{ color:#94a3b8; font-weight:500; }
  .tooltip-value-improved{ font-weight:700; color:#22d3ee; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; text-align:right; }
</style>

<style>#go-line-chart-overlay{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;}</style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<input type="file" id="xtbImportFile" accept=".xlsx,.xls" style="display:none" />
<div id="toastsWrap"></div>

<header>
  <h1><span class="app-logo-header"><svg
    width="200"
    height="56"
    viewBox="0 0 260 80"
    xmlns="http://www.w3.org/2000/svg"
    role="img"
    aria-labelledby="mwTitle mwDesc"
  >
    <title id="mwTitle">MyWallets</title>
    <desc id="mwDesc">Logo MyWallets z ikoną wykresu giełdowego i animowanym napisem</desc>

    <defs>
      <!-- Gradient tła ikony -->
      <linearGradient id="mw-grad" x1="0%" y1="0%" x2="120%" y2="120%">
        <stop offset="0%" stop-color="#22C55E">
          <animate attributeName="offset"
                   values="0;0.25;0"
                   dur="8s"
                   repeatCount="indefinite" />
        </stop>
        <stop offset="50%" stop-color="#0EA5E9">
          <animate attributeName="offset"
                   values="0.3;0.6;0.3"
                   dur="8s"
                   repeatCount="indefinite" />
        </stop>
        <stop offset="100%" stop-color="#6366F1">
          <animate attributeName="offset"
                   values="0.8;1;0.8"
                   dur="8s"
                   repeatCount="indefinite" />
        </stop>
      </linearGradient>

      <!-- Cień pod ikoną -->
      <filter id="mw-shadow" x="-50%" y="-50%" width="200%" height="200%">
        <feDropShadow dx="0" dy="4" stdDeviation="7" flood-opacity="0.28"/>
      </filter>

      <style>
        /* Animacje wejścia i „życia” logotypu */
        @keyframes mw-icon-pop {
          0%   { transform: translateY(8px) scale(0.7); opacity: 0; }
          60%  { transform: translateY(-2px) scale(1.05); opacity: 1; }
          100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        @keyframes mw-text-reveal {
          0%   { opacity: 0; transform: translateX(10px); }
          100% { opacity: 1; transform: translateX(0); }
        }

        @keyframes mw-underline-grow {
          0%   { transform: scaleX(0); opacity: 0; }
          40%  { opacity: 1; }
          100% { transform: scaleX(1); opacity: 1; }
        }

        @keyframes mw-dot-pulse {
          0%   { transform: scale(0.8); opacity: 0.5; }
          50%  { transform: scale(1.3); opacity: 1; }
          100% { transform: scale(0.8); opacity: 0.5; }
        }

        @keyframes mw-bars {
          0%   { transform: scaleY(0.4); }
          50%  { transform: scaleY(1.05); }
          100% { transform: scaleY(0.9); }
        }

        .mw-icon-wrap {
          transform-origin: 44px 40px;
          animation: mw-icon-pop 480ms cubic-bezier(0.18,0.89,0.32,1.28) 80ms both;
        }

        .mw-word-main {
          animation: mw-text-reveal 380ms ease-out 200ms both;
        }

        .mw-word-sub {
          animation: mw-text-reveal 380ms ease-out 320ms both;
        }

        .mw-underline {
          transform-origin: left center;
          animation: mw-underline-grow 420ms ease-out 380ms both;
        }

        .mw-dot {
          transform-origin: center;
          animation: mw-dot-pulse 1.8s ease-in-out 700ms infinite;
        }

        .mw-bar {
          transform-origin: center bottom;
          animation: mw-bars 2.2s ease-in-out infinite;
        }
        .mw-bar-1 { animation-delay: 0.0s; }
        .mw-bar-2 { animation-delay: 0.3s; }
        .mw-bar-3 { animation-delay: 0.6s; }

        /* Szacunek dla prefers-reduced-motion */
        @media (prefers-reduced-motion: reduce) {
          .mw-icon-wrap,
          .mw-word-main,
          .mw-word-sub,
          .mw-underline,
          .mw-dot,
          .mw-bar {
            animation: none !important;
          }
        }

        text {
          font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                       sans-serif;
        }
      </style>
    </defs>

    <!-- LEWA STRONA: ikona wykresu giełdowego -->
    <g class="mw-icon-wrap" transform="translate(10, 8)">
      <!-- Tło / karta -->
      <rect
        x="4"
        y="8"
        width="80"
        height="56"
        rx="18"
        ry="18"
        fill="url(#mw-grad)"
        filter="url(#mw-shadow)"
      />

      <!-- Delikatna linia „osi X” -->
      <line
        x1="18"
        y1="54"
        x2="72"
        y2="54"
        stroke="rgba(15,23,42,0.85)"
        stroke-width="2"
        stroke-linecap="round"
      />

      <!-- Słupki wykresu (animowane) -->
      <rect
        class="mw-bar mw-bar-1"
        x="22"
        y="40"
        width="8"
        height="14"
        rx="2"
        fill="#bbf7d0"
      />
      <rect
        class="mw-bar mw-bar-2"
        x="36"
        y="34"
        width="8"
        height="20"
        rx="2"
        fill="#86efac"
      />
      <rect
        class="mw-bar mw-bar-3"
        x="50"
        y="28"
        width="8"
        height="26"
        rx="2"
        fill="#4ade80"
      />

      <!-- Linia trendu + strzałka w górę -->
      <polyline
        points="20,48 32,42 44,38 58,30"
        fill="none"
        stroke="#fefce8"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      />
      <polygon
        points="58,30 62,26 62,33"
        fill="#fefce8"
      />

      <!-- Mała kropka „sygnał / alert” -->
      <circle
        class="mw-dot"
        cx="64"
        cy="22"
        r="4"
        fill="#22C55E"
      />
    </g>

    <!-- PRAWA STRONA: czytelny napis (bez wchodzenia na ikonę) -->
    <g transform="translate(110, 22)">
      <!-- Główny napis -->
      <text class="mw-word-main" x="0" y="22" font-size="22" fill="#E5E7EB">
        <tspan fill="#22C55E">My</tspan>Wallets
      </text>

      <!-- Podtytuł -->
      <text class="mw-word-sub" x="0" y="40" font-size="11" fill="#9CA3AF">
        investment portfolios &amp; alerts
      </text>

      <!-- Podkreślenie pod napisem -->
      <rect
        class="mw-underline"
        x="0"
        y="26"
        width="132"
        height="2"
        rx="1"
        fill="#22C55E"
        fill-opacity="0.7"
      />
    </g>
  </svg></span>  <button class="btn ghost" id="portfoliosTabBtn" title="Widok portfeli">📂 Portfele</button> <button class="btn ghost" id="wishlistTabBtn" title="Lista życzeń (ceny kupna)">⭐ Lista życzeń</button> <button class="btn ghost" id="alertsTabBtn" title="Historia alarmów">🔔 Alarmy</button></h1>
<div class="actions"><button class="btn ok" id="addPortfolioBtn">➕ Nowy portfel</button>
    <button class="btn secondary" id="transferBtn">🔁 Przelew między portfelami</button>
    <button class="btn ghost" id="exportBtn">⬇️ Eksportuj JSON</button>
    <label for="importFile" class="btn ghost" style="cursor:pointer">⬆️ Importuj JSON</label>
    <input type="file" id="importFile" accept=".json,application/json" style="display:none" />
    <button class="btn warn" id="settingsBtn">⚙️ Ustawienia</button>
  
    <button class="btn ghost" id="firebaseDiagBtn" title="Sprawdź połączenie z Firestore">🧪 Test</button>
    
    <span id="syncCheckLabel" style="margin-left:8px;font-size:12px;">
      Synchronizacja: <span id="syncCheckValue" style="font-weight:600;color:#9ca3af;">?</span>
    </span>
    </div>
</header>
<div class="layout">
  <aside class="sidebar card">
    <div class="head">
            <div class="portfolio-header-svg">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 380 80"
          preserveAspectRatio="xMinYMid meet"
          role="img"
          aria-label="Twoje portfele. Każdy portfel to osobna firma ze swoją strategią"
          style="width:100%; max-width:100%; height:auto; display:block;"
        >
          <defs>
            <!-- Akcentowy gradient (zielono-turkusowy) -->
            <linearGradient id="tpAccent" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#22c55e"/>
              <stop offset="50%" stop-color="#16a34a"/>
              <stop offset="100%" stop-color="#0ea5e9"/>
            </linearGradient>
          </defs>

          <!-- Ikonka "wykresu / portfela" po lewej -->
          <g transform="translate(4,16)">
            <rect
              x="0"
              y="0"
              width="40"
              height="40"
              rx="10"
              ry="10"
              fill="rgba(15,23,42,0.9)"
              stroke="url(#tpAccent)"
              stroke-width="1.4"
            />
            <rect x="8"  y="20" width="5"  height="12" rx="2" fill="url(#tpAccent)"/>
            <rect x="17" y="14" width="5"  height="18" rx="2" fill="url(#tpAccent)"/>
            <rect x="26" y="10" width="5"  height="22" rx="2" fill="url(#tpAccent)"/>
          </g>

          <!-- Główny tytuł -->
          <text
            x="60"
            y="30"
            style="
              font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
              font-size: 24px;
              font-weight: 650;
              fill: #f9fafb;
            "
          >
            Twoje
            <tspan
              dx="8"
              style="
                fill: url(#tpAccent);
                font-weight: 750;
              "
            >
              portfele
            </tspan>
          </text>

          <!-- Podtytuł (dopasowany długością do podkreślenia) -->
          <text
            x="60"
            y="50"
            textLength="280"
            lengthAdjust="spacing"
            style="
              font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
              font-size: 14px;
              font-weight: 500;
              fill: #d1d5db;
            "
          >
            Każdy portfel to osobna „firma” ze swoją strategią
          </text>

          <!-- Podkreślenie dokładnie do końca napisu -->
          <rect
            x="60"
            y="56"
            width="280"
            height="3"
            rx="1.5"
            ry="1.5"
            fill="url(#tpAccent)"
            opacity="0.9"
          />
        </svg>
      </div>
      <button class="btn ok" id="depositBtn" title="Szybki przelew gotówki do wybranego portfela" style="display:none">💰</button>
    </div>
    <div class="portfolios" id="portfolioList"></div>
  </aside>
  <main>
<section id="alertsPanel" style="display:none">
  <div class="card">
    <div class="card-header">
      <h2>🔔 Historia alarmów</h2>
    </div>
    <div class="card-body">
      <div class="grid" style="gap: 8px; align-items: end;">
        <div class="col-3">
          <label>Zakres</label>
          <select id="alertsScope">
            <option value="">Wszystko</option>
            <option value="portfolio">Portfele</option>
            <option value="wishlist">Lista życzeń</option>
          </select>
        </div>
        <div class="col-3">
          <label>Stan</label>
          <select id="alertsState">
            <option value="">Wszystko</option>
            <option value="hit">🎯 Cel osiągnięty</option>
            <option value="near">⏳ Blisko celu</option>
          </select>
        </div>
        <div class="col-3">
          <label>Rodzaj</label>
          <select id="alertsKind">
            <option value="">Wszystko</option>
            <option value="sell">SELL</option>
            <option value="buy">BUY</option>
          </select>
        </div>
        <div class="col-3">
          <button class="btn" id="alertsRefreshBtn">🔄 Odśwież</button> <button id="alertsClearBtn" class="btn small" title="Skasuj historię alarmów">🗑 Wyczyść</button>
        </div>
      </div>
      <div id="alertsStats" class="small" style="margin:8px 0;"></div>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Data</th>
              <th>Ticker</th>
              <th>Stan</th>
              <th>Rodzaj</th>
              <th>Cena</th>
              <th>Cel</th>
              <th>Źródło</th>
            </tr>
          </thead>
          <tbody id="alertsTableBody">
            <tr><td colspan="7" class="muted">Brak danych…</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</section>


    <section id="wishlistPanel" class="card panel" style="display:none">
      <div class="row">
        <h2>⭐ Lista życzeń (cele KUPNA)</h2>
        <div class="spacer"></div>
      </div>
      <div class="grid">
        <div class="col-4">
          <label>Ticker</label>
          <div class="row" style="gap:6px">
            <input id="wlTicker" placeholder="np. TSLA " />
            <button class="btn ghost" id="wlSearch">Szukaj</button>
          </div>
        </div>
        <div class="col-4">
          <label>Cena docelowa (kupno)</label>
          <input id="wlPrice" type="number" step="0.0001" min="0" placeholder="np. 300.00" />
        </div>
        <div class="col-4">
          <label>&nbsp;</label>
          <button class="btn ok" id="wlAdd">➕ Dodaj do listy</button>
        </div>
        <div class="col-12">
          <label>Wyniki wyszukiwania</label>
          <div id="wlSearchResults" class="card panel" style="padding:8px; max-height:220px; overflow:auto"></div>
        </div>
      </div>
      <div style="margin-top:10px"></div>
      <div id="wlTableWrap"></div>
      <div class="small" style="margin-top:8px">Sortowanie wg. odległości od celu; gdy kurs ≤ cel: wiersz mruga na zielono; gdy blisko (≤ tolerancja z Ustawień): delikatne mruganie.</div>
    </section>

    <section class="card panel">
      <div class="row">
        <h2 id="pfTitle">Wybierz portfel</h2>
        <div class="spacer"></div>
        <button class="btn secondary" id="renameBtn">✏️ Zmień nazwę</button>
        <button class="btn danger" id="deleteBtn">🗑️ Usuń portfel</button>
      </div>
      <div class="grid">
        <div class="col-6">
          <label>Strategia / Notatki</label>
          <textarea id="strategyBox" rows="4" placeholder="Opisz krótko zasady tej 'firmy' (np. dywidendy, momentum, swing itp.)"></textarea>
          <div class="small">Zapisywane automatycznie.</div>
        </div>
        <div class="col-6">
          <div class="grid">
            <div class="col-6">
              <div class="stat">
                <div>
                  <div class="muted">Saldo gotówki</div>
                  <div id="cashBalance" style="font-size:20px; font-weight:800">—</div>
                </div>
                <button class="btn ok" id="cashActionsBtn">💵 Operacje</button>
              </div>
            </div>
            <div class="col-6">
              <div class="stat">
                <div>
                  <div class="muted">Zysk/Strata (zrealizowane)</div>
                  <div style="font-size:20px; font-weight:800">
                    <span id="realizedPL">—</span>
                    <span class="small">(<span id="realizedPLnet">netto</span>)</span>
                  </div>
                </div>
                <div class="tag">liczone tylko po sprzedaży</div>
              </div>
            </div>
            <div class="col-12">
              <div class="row">
                <button class="btn ok" id="buyBtn">🛒 Zakup</button>
                <button class="btn ok" id="sellBtn">💸 Sprzedaż (dowolne partie)</button>
                <button class="btn secondary" id="withdrawBtn" style="display:none">🏧 Wypłata</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="card panel">
      <div class="row">
        <h2>Stan posiadania (partie i średni koszt)</h2>
        <div class="spacer"></div>
        <span class="small">Kursy na żywo z Finnhub (bez konwersji walut). Ustaw token w ⚙️ Ustawienia.</span>
      </div>
      <div id="holdingsTableWrap"></div>
    </section>

    <section id="historyPanel" class="card panel">
      <div class="row">
        <h2 id="historyTitle" class="clickable">Historia operacji</h2>
        <div class="spacer"></div>
        <button id="historyCollapseBtn" class="btn small ok" title="Zwiń/Rozwiń"><span class="chev">▾</span></button>
        <label class="small" for="filterQuery">Filtr</label>
        <input id="filterQuery" placeholder="np. typ:sell TSLA 2025-09" style="max-width:300px" />
        <button class="btn small ghost" id="filterClearBtn">Wyczyść</button>
      </div>
      <div id="txTableWrap"></div>
    </section>

    <footer>
      v2 • Dane zapisywane lokalnie w przeglądarce (localStorage) oraz w chmurze. Zawsze możesz <span class="link" id="exportLink2">eksportować JSON</span> i później go <span class="link" id="importLink2">zaimportować</span>.
    </footer>
  </main>
</div>

<!-- Modale -->
<dialog id="modal">
  <div class="modal">
    <header>
      <h3 id="modalTitle">Modal</h3>
    </header>
    <div class="content" id="modalContent">—</div>
    <footer>
      <button class="btn ghost" id="modalCancel">Anuluj</button>
      <button class="btn" id="modalOk">Zapisz</button>
    </footer>
  </div>
</dialog>

<script>
(()=>{
  const KEY = "portfele_firmy_v1";


// Funkcja wywoływana z wrappera przy otrzymaniu snapshotu Firestore
// payload: { [KEY]: JSON-string DB, ... }
window.__GT_RELOAD_FROM_SNAPSHOT__ = function(payload){
  try{
    if (!payload) return;
    const raw = payload[KEY];
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return;
    DB = parsed;
    // Zapisz do localStorage (wywoła setItem + ewentualny storage_event do wrappera)
    try { save(); } catch(_e){}
    // Przerysuj interfejs (portfele + wishlist)
    try { render(); } catch(_e){}
    try { renderWishlist(); updateWishlistBlinkState(); } catch(_e){}
  }catch(e){
    console.error('GT reload from Firestore snapshot error:', e);
  }
};


// === [UNDO] Migawki bazy z TTL 2 dni ===
const UNDO_KEY = KEY + '__undo';
const UNDO_TTL_MS = 2*24*60*60*1000; // 2 dni
const UNDO_MAX = 60; // ograniczenie wielkości historii (ring buffer)
window.__UNDO_RESTORING = false; // guard przed nasłuchem Firestore w trakcie przywracania

function __undoLoad(){
  try{ return JSON.parse(localStorage.getItem(UNDO_KEY) || '[]'); }catch(_){ return []; }
}
function __undoSave(stack){ try{ localStorage.setItem(UNDO_KEY, JSON.stringify(stack)); }catch(_){} }
function __undoPrune(stack=null){
  const now = Date.now();
  const s = (stack || __undoLoad()).filter(it => (now - (it.ts||0)) < UNDO_TTL_MS);
  if(s.length > UNDO_MAX) s.splice(0, s.length - UNDO_MAX);
  __undoSave(s);
  __undoUpdateBtn();
  return s;
}
function __makeSnapshot(kind='tx'){
  return { ts: Date.now(), kind, label: '', db: JSON.stringify(DB), currentPfId };
}
function pushUndo({label='Zmiana', kind='tx'} = {}){
  try{
    const s = __undoPrune();
    const snap = __makeSnapshot(kind); snap.label = label;
    s.push(snap);
    __undoSave(s);
    __undoUpdateBtn();
  }catch(_){}
}
function canUndo(){ return __undoPrune().length > 0; }

function __findSnapshotToUndo(mode='tx'){
  // mode: 'tx' (domyślnie skaczemy do ostatniej transakcyjnej), 'any' (krokowo)
  const s = __undoPrune();
  if(s.length===0) return {stack:s, target:null, idx:-1};
  if(mode==='any'){
    return {stack:s, target:s[s.length-1], idx:s.length-1};
  }
  for(let i=s.length-1;i>=0;i--){
    if((s[i].kind||'tx')==='tx') return {stack:s, target:s[i], idx:i};
  }
  // jeśli nie ma 'tx', weź ostatnią jakąkolwiek
  return {stack:s, target:s[s.length-1], idx:s.length-1};
}

function undo({mode='tx'}={}){
  const found = __findSnapshotToUndo(mode);
  const s = found.stack;
  const target = found.target;
  const idx = found.idx;
  if(!target){ alert('Brak cofnięć (historia pusta lub po TTL).'); return; }
  try{
    window.__UNDO_RESTORING = true;
    DB = JSON.parse(target.db);
    currentPfId = target.currentPfId || (DB.portfolios && DB.portfolios[0] && DB.portfolios[0].id) || null;
    if (typeof save === 'function') save();
    if (typeof render === 'function') render();
    try{ if(typeof window.hardUpload==='function'){ const r = window.hardUpload(); if(r && typeof r.then==='function'){ r.then(()=>{}).catch(()=>{}); } } }catch(_){}
    alert('Cofnięto: ' + (target.label || 'zmianę'));
  }catch(e){
    alert('Nie udało się cofnąć: ' + (e && e.message || e));
  }finally{
    // usuń wszystkie migawki od końca aż do wybranej (włącznie)
    s.splice(idx, s.length - idx);
    __undoSave(s);
    __undoUpdateBtn();
    setTimeout(()=>{ window.__UNDO_RESTORING = false; }, 1500);
  }
}

function __undoUpdateBtn(){
  try{
    const btn = document.getElementById('undoBtn');
    if(!btn) return;
    const n = (__undoLoad() || []).filter(it => (Date.now() - (it.ts||0)) < UNDO_TTL_MS).length;
    btn.disabled = n===0;
    btn.title = n ? `Cofnij (w historii: ${n}; wygasa po 2 dniach)` : 'Brak rzeczy do cofnięcia';
  }catch(_){}
}

document.addEventListener('DOMContentLoaded', ()=>{
  const btn = document.getElementById('undoBtn');
  if(btn) btn.addEventListener('click', (e)=>{
    // Shift+klik -> tryb 'any' (krokowo), zwykły klik -> 'tx' (skok do ostatniej transakcji)
    undo({mode: e && e.shiftKey ? 'any' : 'tx'});
  });
  __undoUpdateBtn();
});
document.addEventListener('keydown', (e)=>{
  const key = String(e.key||'').toLowerCase();
  if((e.ctrlKey||e.metaKey) && key==='z'){
    e.preventDefault();
    // Ctrl/Cmd+Shift+Z -> 'any', zwykłe Ctrl/Cmd+Z -> 'tx'
    undo({mode: e.shiftKey ? 'any' : 'tx'});
  }
});

  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));

  const fmtCurrency = (n, cur) => {
    if(n === null || n === undefined || isNaN(n)) return "—";
    try{
      return new Intl.NumberFormat('pl-PL', { style:'currency', currency: cur || 'USD', minimumFractionDigits:2, maximumFractionDigits:2 }).format(n);
    }catch(e){
      return (n.toFixed(2)) + ' ' + (cur||'USD');
    }
  };
  const fmtNum = (n, d=2) => (n ?? n===0) ? Number(n).toFixed(d) : "—";
  const id = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

  const defaultDB = ()=> ({
    version: 1,
    settings: { taxRate: 0.19, allowNegativeCash: false, currencyDefault: "USD", finnhubToken: "", pricePollSeconds: 45, approachTolerancePct: 1 },
    portfolios: [],
    watchlist: []
  });
  let DB = null;
  try{
    DB = JSON.parse(localStorage.getItem(KEY)) || defaultDB();
  }catch(e){
    DB = defaultDB();
  }
    const save = ()=> {
    if(DB) DB._ts = Date.now(); // znacznik czasu ostatniej modyfikacji
    localStorage.setItem(KEY, JSON.stringify(DB));
  };


  const FINNHUB_DEMO_TOKEN = "d4dlki1r01qmhtc51ao0d4dlki1r01qmhtc51aog";

  function resolveFinnhubToken(tokenOverride, preferWishlist){
    const s = (typeof DB === 'object' && DB && DB.settings) ? DB.settings : {};
    const main = s.finnhubToken || "";
    const wish = s.finnhubTokenWishlist || "";
    if (tokenOverride) return tokenOverride;
    if (preferWishlist) {
      if (wish) return wish;
      if (main) return main;
    } else {
      if (main) return main;
      if (wish) return wish;
    }
    if (!main && !wish) {
      return FINNHUB_DEMO_TOKEN;
    }
    return "";
  }


  let currentPfId = DB.portfolios[0]?.id || null;

  // UI Elements
  const portfolioListEl = $("#portfolioList");
  const pfTitleEl = $("#pfTitle");
  const strategyBox = $("#strategyBox");
  const cashBalanceEl = $("#cashBalance");
  const realizedPLEl = $("#realizedPL");
  const realizedPLnetEl = $("#realizedPLnet");
  const holdingsTableWrap = $("#holdingsTableWrap");
  const txTableWrap = $("#txTableWrap");
  const filterQueryEl = $("#filterQuery");

  // Modal helpers
  const modal = $("#modal");
  const modalTitle = $("#modalTitle");
  const modalContent = $("#modalContent");
  const modalOk = $("#modalOk");
  const modalCancel = $("#modalCancel");
  let modalResolve = null;
  modalCancel.addEventListener('click', ()=> closeModal(null));
  function openModal({title, innerHTML, okText="Zapisz", cancelText="Anuluj"}){
    modalTitle.textContent = title;
    modalContent.innerHTML = innerHTML;
    $("#modalOk").textContent = okText;
    $("#modalCancel").textContent = cancelText;
    modal.showModal();
    return new Promise(res=> modalResolve = res);
  }
  function closeModal(result){
    modal.close();
    if(modalResolve){ const r = modalResolve; modalResolve = null; r(result); }
  }
  modalOk.addEventListener('click', ()=> {
    // By default, collect form values into an object
    const form = modalContent.querySelector("form");
    if(form){
      const data = Object.fromEntries(new FormData(form).entries());
      closeModal(data);
    }else{
      closeModal(true);
    }
  });

  // Core operations

  // === Rebuild from transactions (chronological replay) ===
  
// --- Helper: find lot by lotId across holdings
function getLotById(pf, lotId){
  if(!pf || !lotId) return null;
  for(const [ticker, h] of Object.entries(pf.holdings||{})){
    for(const lot of (h.lots||[])){
      if(lot.lotId === lotId) return lot;
    }
  }
  return null;
}
function ensureBuyLotIdInTx(tx){
    // Assign stable lotId to buy tx if missing (backward compat)
    if(tx.type==="buy" && !tx.lotId){
      tx.lotId = tx.id || id();
    }
  }
  function cloneEmptyState(pf){
    return { cash: 0, holdings: {} };
  }
  function applyBuy(state, pf, tx){
    const tkr = tx.ticker.trim().toUpperCase();
    const q = Number(tx.qty)||0;
    const p = Number(tx.price)||0;
    const f = Number(tx.fees)||0;
    state.cash -= (q*p + f);
    state.holdings[tkr] ||= { lots: [] };
    const lotIdStable = tx.lotId;
    const lot = { lotId: lotIdStable, date: tx.date || today(), qty: q, unitCost: p + (f/q||0), rawPrice: p, fees: f, note: tx.note||"", targetPct: (tx.targetPct??null), targetPrice: (tx.targetPrice??null), buyTargetPct: (tx.buyTargetPct??null), buyTargetPrice: (tx.buyTargetPrice??null) };
    state.holdings[tkr].lots.push(lot);
    __gt_updateActiveTargetLotForTicker(state.holdings[tkr]);
  }
  function applySell(state, pf, tx){
  const tkr = tx.ticker.trim().toUpperCase();
  const pSell = Number(tx.price||tx.sellPrice||0);
  const f = Number(tx.fees)||0;
  const links = (tx.lotLinks||[]).map(x=>({lotId: x.lotId, qty: Number(x.qty)||0})).filter(x=>x.qty>0);
  // Prepare errors array
  state.__errors = state.__errors || [];
  function softError(msg){
    try{ state.__errors.push({ticker:tkr, id: tx.id||null, date: tx.date||null, message: String(msg)}); }catch(_){}
  }
  let proceeds = 0, grossPL = 0;
  const book = state.holdings[tkr];
  if(!book){
    softError("Sprzedaż bez pozycji ("+tkr+").");
    // Keep tx derived fields consistent but do not mutate state
    tx.qty = links.reduce((a,b)=>a+b.qty,0);
    tx.proceeds = 0; tx.grossPL = 0; tx.tax = 0; tx.netPL = 0;
    return;
  }
  for(const link of links){
    const lot = book.lots.find(l=>l.lotId===link.lotId);
    if(!lot){
      softError("Brak partii "+link.lotId+" przy sprzedaży "+tkr);
      continue;
    }
    if(link.qty > lot.qty + 1e-9){
      softError("Sprzedaż przekracza ilość w partii ("+tkr+").");
      continue;
    }
    proceeds += link.qty * pSell;
    grossPL += link.qty * (pSell - lot.unitCost);
  }
  grossPL -= f;
  const tax = grossPL>0 ? grossPL*(DB.settings.taxRate||0.19) : 0;
  const netPL = grossPL - tax;
  // Update cash & reduce lots only for links that were valid
  state.cash += (proceeds - f);
  for(const link of links){
    const lot = (book.lots||[]).find(l=>l.lotId===link.lotId);
    if(lot && link.qty <= lot.qty + 1e-9){
      lot.qty -= link.qty;
    }
  }
  book.lots = book.lots.filter(l=>l.qty>1e-9);
  __gt_updateActiveTargetLotForTicker(book);
  // Mutate tx to keep derived fields consistent
  tx.qty = links.reduce((a,b)=>a+b.qty,0);
  tx.price = pSell;
  tx.proceeds = proceeds;
  tx.grossPL = grossPL;
  tx.tax = tax;
  tx.netPL = netPL;
}

function applyTransferCompanyIn(state, pf, tx){
    const tkr = (tx.ticker||'').trim().toUpperCase();
    const q = Number(tx.qty)||0;
    const uc = Number(tx.unitCost ?? tx.price ?? 0) || 0;
    state.holdings[tkr] ||= { lots: [] };
    const lotId = tx.newLotId || tx.lotId || id();
    const lot = {
      lotId,
      date: tx.date || today(),
      qty: q,
      unitCost: uc,
      rawPrice: Number(tx.rawPrice ?? uc),
      fees: Number(tx.fees)||0,
      note: tx.note||"",
      // przenosimy cele sprzedaży/kupna razem z partią
      targetPct: (tx.targetPct!==undefined && tx.targetPct!==null && tx.targetPct!=="") ? Number(tx.targetPct) : null,
      targetPrice: (tx.targetPrice!==undefined && tx.targetPrice!==null && tx.targetPrice!=="") ? Number(tx.targetPrice) : null,
      buyTargetPct: (tx.buyTargetPct!==undefined && tx.buyTargetPct!==null && tx.buyTargetPct!=="") ? Number(tx.buyTargetPct) : null,
      buyTargetPrice: (tx.buyTargetPrice!==undefined && tx.buyTargetPrice!==null && tx.buyTargetPrice!=="") ? Number(tx.buyTargetPrice) : null
    };
    state.holdings[tkr].lots.push(lot);
    __gt_updateActiveTargetLotForTicker(state.holdings[tkr]);
  }

function applyTransferCompanyOut(state, pf, tx){
    const tkr = (tx.ticker||'').trim().toUpperCase();
    const q = Number(tx.qty)||0;
    const book = state.holdings[tkr];
    if(!book) return; // nothing to remove
    if(tx.lotId){
      const idx = book.lots.findIndex(l=>l.lotId===tx.lotId);
      if(idx>=0){
        const lot = book.lots[idx];
        lot.qty -= q;
        if(lot.qty <= 1e-9){ book.lots.splice(idx,1); }
      }
    }else{
      // Fallback: remove qty from first lots FIFO
      let remaining = q;
      for(const lot of book.lots){
        if(remaining<=1e-9) break;
        const take = Math.min(lot.qty, remaining);
        lot.qty -= take;
        remaining -= take;
      }
      book.lots = book.lots.filter(l=>l.qty>1e-9);
    }
  }

  function applyCash(state, type, amount){
    const a = Number(amount)||0;
    if(type==="deposit" || type==="transfer_in") state.cash += a;
    if(type==="withdraw" || type==="transfer_out") state.cash -= a;
    // Zaokrąglenie gotówki do 2 miejsc po przecinku, żeby uniknąć błędów float
    state.cash = Math.round((state.cash || 0) * 100) / 100;
  }
  function rebuildPortfolio(pf){
    // --- Preserve per-lot muted flags BEFORE rebuild (by stable lotId) ---
    const __prevMuted = {};
    try{
      const prevHoldings = pf && pf.holdings ? pf.holdings : {};
      for(const [tk, book] of Object.entries(prevHoldings)){
        for(const lot of (book.lots||[])){
          if(lot && lot.lotId){ __prevMuted[lot.lotId] = !!lot.muted; }
        }
      }
    }catch(_){}

    // Replay from oldest to newest
    const txsChrono = pf.transactions.slice().reverse();
    const state = cloneEmptyState(pf);
    state.__errors = [];
    for(const tx of txsChrono){
      if(tx.type==="deposit" || tx.type==="withdraw" || tx.type==="transfer_in" || tx.type==="transfer_out"){
        applyCash(state, tx.type, tx.amount);
      }else if(tx.type==="buy"){
        ensureBuyLotIdInTx(tx);
        applyBuy(state, pf, tx);
      }else if(tx.type === "sell"){
        const sellDateMs = toMs(tx.date);
        applySell(state, pf, tx);
      }else if(tx.type==="transfer_company_in"){
        applyTransferCompanyIn(state, pf, tx);
      }else if(tx.type==="transfer_company_out"){
        applyTransferCompanyOut(state, pf, tx);
      }
    }

    // --- Re-apply muted flags to rebuilt lots (matching by lotId) ---
    try{
      for(const [tk, book] of Object.entries(state.holdings||{})){
        for(const lot of (book.lots||[])){
          if(lot && lot.lotId && (__prevMuted[lot.lotId] === true || __prevMuted[lot.lotId] === false)){
            lot.muted = __prevMuted[lot.lotId];
          }
        }
      }
    }catch(_){}

    
    // --- Prune empty/zero-qty lots and remove empty tickers (anti-ghost) ---
    try {
      for (const [tk, book] of Object.entries(state.holdings || {})) {
        const lots = Array.isArray(book.lots) ? book.lots : [];
        // drop zero-qty lots
        book.lots = lots.filter(l => Number(l && l.qty || 0) > 1e-9);
        // remove ticker entirely if no lots left
        if (!book.lots.length) {
          delete state.holdings[tk];
        }
      }
    } catch (_) {}
pf.__errors = Array.isArray(state.__errors) ? state.__errors : [];
    pf.cash = Math.round((state.cash || 0) * 100) / 100;
    pf.holdings = state.holdings;
    try{
      for(const book of Object.values(pf.holdings||{})){
        __gt_updateActiveTargetLotForTicker(book);
      }
    }catch(_){}

    pf.updatedAt = new Date().toISOString();
  }
  function getPf(id){ return DB.portfolios.find(p=>p.id===id) || null; }
  function ensureCurrency(cur){ return cur || DB.settings.currencyDefault || "PLN"; }

  function addPortfolio(){
  try{ pushUndo({label:"Dodanie portfela", kind:'tx'}); }catch(_){}

    const newPf = {
      id: id(),
      name: "Nowy portfel",
      currency: DB.settings.currencyDefault || "PLN",
      strategy: "",
      cash: 0,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      holdings: {}, // ticker -> { lots: [ {lotId, date, qty, unitCost, rawPrice, fees, note} ] }
      transactions: [] // list of tx objects
    };
    DB.portfolios.push(newPf);
    currentPfId = newPf.id;
    save(); render();
  }

  function deletePortfolio(pfId){
  try{ pushUndo({label:"Usuni\u0119cie portfela", kind:'tx'}); }catch(_){}

    const idx = DB.portfolios.findIndex(p=>p.id===pfId);
    if(idx>=0){ DB.portfolios.splice(idx,1); if(currentPfId===pfId) currentPfId = DB.portfolios[0]?.id || null; save(); render(); }
  }

  function renamePortfolio(pfId, name){
  try{ pushUndo({label:"Zmiana nazwy portfela", kind:'meta'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    pf.name = name; pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  function setStrategy(pfId, text){
  try{ pushUndo({label:"Edycja strategii/notatki", kind:'meta'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    pf.strategy = text; pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  function deposit(pfId, amount, note=""){
  try{ pushUndo({label:"Wp\u0142ata got\u00f3wki", kind:'tx'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    const amt = Number(amount)||0;
    pf.cash = Math.round(((Number(pf.cash) || 0) + amt) * 100) / 100;
    pf.transactions.unshift({ id:id(), type:"deposit", date:today(), amount:amt, note });
    pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }
  function withdraw(pfId, amount, note=""){
  try{ pushUndo({label:"Wyp\u0142ata got\u00f3wki", kind:'tx'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    const amt = Number(amount)||0;
    if(!DB.settings.allowNegativeCash && pf.cash < amt){ alert("Brak środków. Włącz opcję 'Zezwól na saldo ujemne' w Ustawieniach, jeśli chcesz kontynuować."); return; }
    pf.cash = Math.round(((Number(pf.cash) || 0) - amt) * 100) / 100;
    pf.transactions.unshift({ id:id(), type:"withdraw", date:today(), amount:amt, note });
    pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  function transfer(fromId, toId, amount, note=""){
  try{ pushUndo({label:"Przelew mi\u0119dzy portfelami", kind:'tx'}); }catch(_){}

  if(fromId===toId){ alert("Wybierz różne portfele."); return; }
  const from = getPf(fromId), to = getPf(toId);
  const amt = Number(amount)||0;
  if(!from || !to) return alert("Nieprawidłowe portfele.");
  if(!DB.settings.allowNegativeCash && from.cash < amt){ alert("Brak środków w portfelu źródłowym."); return; }
  from.cash = Math.round(((Number(from.cash) || 0) - amt) * 100) / 100;
  to.cash = Math.round(((Number(to.cash) || 0) + amt) * 100) / 100;
  const stamp = today();
  const linkId = id();
  from.transactions.unshift({ id:id(), linkId, type:"transfer_out", date:stamp, amount:amt, note, counterpartyPortfolioId: to.id });
  to.transactions.unshift({ id:id(), linkId, type:"transfer_in",  date:stamp, amount:amt, note, counterpartyPortfolioId: from.id });
  from.updatedAt = to.updatedAt = new Date().toISOString();
  save(); render();
}


async function transferCompanyDialog(fromPfId, ticker) {
  const fromPf = getPf(fromPfId);
  if(!fromPf) return alert("Błąd: portfel źródłowy nie istnieje.");
  const book = (fromPf.holdings||{})[ticker];
  if(!book || !book.lots || !book.lots.length) return alert("Brak pakietów do przeniesienia.");
  const targetPortfolios = DB.portfolios.filter(p => p.id !== fromPfId);
  if(!targetPortfolios.length) return alert("Brak innych portfeli do przeniesienia.");
  const opts = targetPortfolios.map(p => `<option value="${p.id}">${__esc(p.name)} (${p.currency})</option>`).join("");
  const totalQty = book.lots.reduce((sum, lot) => sum + Number(lot.qty||0), 0);
  const totalValue = book.lots.reduce((sum, lot) => sum + (Number(lot.qty||0) * Number(lot.unitCost||0)), 0);
  const lotsList = book.lots.map((lot, i) => 
    `<tr>
      <td>${i+1}</td>
      <td>${__esc(lot.date||"")}</td>
      <td>${__fmtNum(lot.qty||0)}</td>
      <td>${__go_fmtCurrency(lot.unitCost||0, fromPf.currency)}</td>
      <td>${__go_fmtCurrency((Number(lot.qty||0) * Number(lot.unitCost||0)), fromPf.currency)}</td>
    </tr>`
  ).join("");

  const data = await openModal({
    title: `Przenieś całą spółkę ${ticker}`,
    innerHTML: `<form class="grid">
      <div class="col-6">
        <label>Portfel docelowy</label>
        <select name="toPortfolioId" required>${opts}</select>
      </div>
      <div class="col-6">
        <label>Data przeniesienia</label>
        <input name="date" type="date" value="${today()}" required />
      </div>
      <div class="col-12">
        <label>Notatka (opcjonalnie)</label>
        <input name="note" placeholder="np. reorganizacja portfeli" />
      </div>
      <div class="col-12">
        <h4>Pakiety do przeniesienia:</h4>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>#</th><th>Data</th><th>Ilość</th><th>Koszt/szt</th><th>Wartość</th></tr>
            </thead>
            <tbody>${lotsList}</tbody>
            <tfoot>
              <tr style="font-weight:bold">
                <td colspan="2">RAZEM:</td>
                <td>${__fmtNum(totalQty)}</td>
                <td>—</td>
                <td>${__go_fmtCurrency(totalValue, fromPf.currency)}</td>
              </tr>
            </tfoot>
          </table>
        </div>
        <div class="small warn-text">
          UWAGA: Operacja przeniesie wszystkie pakiety akcji ${ticker} 
          z portfela "${fromPf.name}" do wybranego portfela docelowego.
        </div>
      </div>
    </form>`,
    okText: "Przenieś spółkę",
    cancelText: "Anuluj"
  });
  if(data) {
    await transferCompany(fromPfId, data.toPortfolioId, ticker, data.date, data.note||"");
  }
}


async function transferCompany(fromPfId, toPfId, ticker, date, note = "") {
  try{ pushUndo({label:"Transfer spółki", kind:'tx'}); }catch(_){}

  if(fromPfId === toPfId) return alert("Portfel źródłowy i docelowy są identyczne.");
  const fromPf = getPf(fromPfId);
  const toPf = getPf(toPfId);
  if(!fromPf || !toPf) return alert("Błąd: nieprawidłowe portfele.");
  const book = (fromPf.holdings||{})[ticker];
  if(!book || !book.lots || !book.lots.length) return alert("Brak pakietów do przeniesienia.");

  // KLUCZOWA LOGIKA – automatyczny kurs FX:
  //  • USD↔PLN: zawsze z internetu / cache, bez prompta
  //  • inne pary: internet + ewentualnie ręczny prompt (fallback)
  let fxRate = 1;
  const fromCur = fromPf.currency || (DB.settings && DB.settings.currencyDefault) || "PLN";
  const toCur   = toPf.currency   || (DB.settings && DB.settings.currencyDefault) || "PLN";

  if(fromCur !== toCur){
    const isUsdPln = (fromCur === 'USD' && toCur === 'PLN') || (fromCur === 'PLN' && toCur === 'USD');
    let autoRate = null;

    // 1) Najpierw spróbuj pobrać z internetu przez istniejącą logikę ensureFx (sekcja Statystyki)
    try{
      if(typeof ensureFx === 'function'){
        autoRate = await ensureFx(fromCur, toCur);
      }
    }catch(_){}

    if(Number.isFinite(autoRate) && autoRate > 0){
      fxRate = autoRate;
    }else if(isUsdPln){
      // 2) Dla USD↔PLN – NIGDY nie pokazujemy prompta.
      //    Użyj tego, co jest już w ST.FX lub localStorage, a jak się nie uda -> załóż 1.0
      let cachedRate = null;

      // 2a) Spróbuj odczytać z ST.FX (sekcja Statystyki)
      try{
        if (window.ST && ST.FX && ST.FX['USD'] && Number.isFinite(ST.FX['USD']['PLN']) && ST.FX['USD']['PLN'] > 0){
          cachedRate = ST.FX['USD']['PLN'];
        }
      }catch(_){}

      // 2b) Jak nie ma w ST.FX, spróbuj localStorage (oba klucze, które już są używane w appce)
      if(!Number.isFinite(cachedRate) || cachedRate <= 0){
        try{
          const lsRaw = (localStorage.getItem('gt_fx_usd_pln') || localStorage.getItem('global_overview_fx_usdpln') || '').replace(',', '.').trim();
          const lsVal = Number(lsRaw);
          if(Number.isFinite(lsVal) && lsVal > 0){
            cachedRate = lsVal;
          }
        }catch(_){}
      }

      // 2c) Jeśli nadal nic – absolutny fallback 1.0, ale nadal BEZ prompta
      if(Number.isFinite(cachedRate) && cachedRate > 0){
        fxRate = (fromCur === 'USD') ? cachedRate : (1 / cachedRate);
      }else{
        fxRate = 1; // wolimy 1, niż blokować transfer promptem
      }
    }else{
      // 3) Inne pary walut – zostawiamy stary mechanizm z promptem jako fallback
      const key = fromCur + "_" + toCur;
      const last = (window.__LAST_EXCHANGE_RATE__ && window.__LAST_EXCHANGE_RATE__[key]) || "";
      const rateStr = prompt(
        `Przenosisz spółkę z portfela w ${fromCur} → ${toCur}.\n` +
        `Podaj aktualny kurs ${fromCur} → ${toCur} (np. 1 ${fromCur} = 4.02 ${toCur}):`,
        last
      );
      if(rateStr === null){
        return; // anulowano
      }
      const parsed = parseFloat(String(rateStr).replace(",", "."));
      if(!parsed || !isFinite(parsed) || parsed <= 0){
        alert("Nieprawidłowy kurs.");
        return;
      }
      fxRate = parsed;
      window.__LAST_EXCHANGE_RATE__ = window.__LAST_EXCHANGE_RATE__ || {};
      window.__LAST_EXCHANGE_RATE__[key] = fxRate;
    }
  }

  try{
    const transferDate = date || today();
    const linkId = id();
    // Nie modyfikujemy bezpośrednio holdings docelowego – wszystko odbudujemy z transakcji,
    // dzięki czemu cele sprzedaży/kupna pozostaną spójne.
    for(const lot of book.lots){
      const newLotId = id();
      const qty = Number(lot.qty)||0;
      const srcUnitCost = Number(lot.unitCost)||0;
      const srcRawPrice = Number(lot.rawPrice ?? lot.unitCost) || 0;
      const fees = Number(lot.fees)||0;
      const targetPct = (lot.targetPct!==undefined && lot.targetPct!==null && lot.targetPct!=="") ? Number(lot.targetPct) : null;
      const targetPrice = (lot.targetPrice!==undefined && lot.targetPrice!==null && lot.targetPrice!=="") ? Number(lot.targetPrice) : null;
      const buyTargetPct = (lot.buyTargetPct!==undefined && lot.buyTargetPct!==null && lot.buyTargetPct!=="") ? Number(lot.buyTargetPct) : null;
      const buyTargetPrice = (lot.buyTargetPrice!==undefined && lot.buyTargetPrice!==null && lot.buyTargetPrice!=="") ? Number(lot.buyTargetPrice) : null;

      const unitCost = srcUnitCost * fxRate;
      const rawPrice = srcRawPrice * fxRate;

      toPf.transactions.unshift({
        id: id(),
        linkId: linkId,
        type: "transfer_company_in",
        date: transferDate,
        ticker: ticker,
        qty,
        price: rawPrice,
        unitCost,
        rawPrice,
        fees,
        note: `Transfer spółki ${ticker} z portfela "${fromPf.name}". ${note}`.trim(),
        counterpartyPortfolioId: fromPfId,
        originalLotId: lot.lotId,
        newLotId: newLotId,
        targetPct,
        targetPrice,
        buyTargetPct,
        buyTargetPrice,
        fxRate,
        srcCurrency: fromCur,
        dstCurrency: toCur,
        srcUnitCost,
        srcRawPrice
      });
    }

    for(const lot of book.lots){
      fromPf.transactions.unshift({
        id: id(),
        linkId: linkId,
        type: "transfer_company_out",
        date: transferDate,
        ticker: ticker,
        qty: Number(lot.qty)||0,
        price: Number(lot.rawPrice ?? lot.unitCost) || 0,
        unitCost: Number(lot.unitCost)||0,
        fees: Number(lot.fees)||0,
        note: `Transfer spółki ${ticker} do portfela "${toPf.name}". ${note}`.trim(),
        counterpartyPortfolioId: toPfId,
        lotId: lot.lotId,
        fxRate,
        srcCurrency: fromCur,
        dstCurrency: toCur
      });
    }
    delete fromPf.holdings[ticker];
    const now = new Date().toISOString();
    fromPf.updatedAt = now;
    toPf.updatedAt = now;
    try { rebuildPortfolio(fromPf); rebuildPortfolio(toPf); } catch(_) {}
    save(); render();
    alert(
      `Transfer zakończony!\n\n` +
      `Spółka: ${ticker}\n` +
      `Z: ${fromPf.name} → ${toPf.name}\n` +
      `Pakietów: ${book.lots.length}\n` +
      `Data: ${transferDate}`
    );
  }catch(error){
    console.error("Błąd transferu spółki:", error);
    alert(`Błąd podczas transferu: ${error.message}`);
  }
}




async function buy(pfId, {ticker, date, qty, price, fees, note, targetPct, targetPrice, buyTargetPct, buyTargetPrice}){
  try{ pushUndo({label:"Zakup", kind:'tx'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    ticker = (ticker||"").trim().toUpperCase();
    const q = Math.max(0, Number(qty)||0);
    const p = Number(price)||0;
    const f = Number(fees)||0;
    if(!ticker || q<=0 || p<=0){ return alert("Uzupełnij poprawnie: ticker, ilość, cenę."); }
    const cashOut = q*p + f;
    if(!DB.settings.allowNegativeCash && pf.cash < cashOut){ return alert("Brak środków na zakup (sprawdź saldo gotówki) lub zezwól na saldo ujemne w ustawieniach."); }
    pf.cash = Math.round(((Number(pf.cash) || 0) - cashOut) * 100) / 100;
    pf.holdings[ticker] ||= { lots: [] };
    const lot = { lotId: id(), date: date || today(), qty: q, unitCost: p + (f/q||0), rawPrice: p, fees: f, note: note||"", targetPct: (targetPct!==undefined && targetPct!=="" ? Number(targetPct) : null), targetPrice: (targetPrice!==undefined && targetPrice!=="" ? Number(targetPrice) : null), buyTargetPct: (buyTargetPct!==undefined && buyTargetPct!=="" ? Number(buyTargetPct) : null), buyTargetPrice: (buyTargetPrice!==undefined && buyTargetPrice!=="" ? Number(buyTargetPrice) : null) };
    pf.holdings[ticker].lots.push(lot);
    __gt_updateActiveTargetLotForTicker(pf.holdings[ticker]);
    pf.transactions.unshift({ id:id(), type:"buy", date: date || today(), ticker, qty:q, price:p, fees:f, note: note, lotId: lot.lotId, targetPct: lot.targetPct, targetPrice: lot.targetPrice, buyTargetPct: lot.buyTargetPct, buyTargetPrice: lot.buyTargetPrice });
    pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  function sell(pfId, {ticker, date, sellPrice, fees, allocations, note}){
  try{ pushUndo({label:"Sprzeda\u017c", kind:'tx'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    ticker = (ticker||"").trim().toUpperCase();
    const pSell = Number(sellPrice)||0;
    const f = Number(fees)||0;
    if(!ticker || pSell<=0){ return alert("Uzupełnij poprawnie: ticker i cenę sprzedaży."); }
    const book = pf.holdings[ticker]; if(!book){ return alert("Brak pozycji na ten ticker."); }
    // Validate allocations
    let totalQty = 0;
    allocations = allocations.filter(a=>a.qty>0);
    if(allocations.length===0){ return alert("Wybierz ilość do sprzedaży w co najmniej jednej partii."); }
    for(const a of allocations){ totalQty += a.qty; }
    // Proceeds and P/L
    const proceeds = totalQty * pSell;
    let grossPL = 0;
    for(const a of allocations){
      const lot = book.lots.find(l=>l.lotId===a.lotId);
      if(!lot) return alert("Nie znaleziono partii.");
      if(a.qty > lot.qty){ return alert("Sprzedawana ilość przekracza ilość w partii."); }
      grossPL += a.qty * (pSell - lot.unitCost);
    }
    grossPL -= f;
    const tax = grossPL>0 ? grossPL * (DB.settings.taxRate || 0.19) : 0;
    const netPL = grossPL - tax;
    // Apply inventory changes
    for(const a of allocations){
      const lot = book.lots.find(l=>l.lotId===a.lotId);
      lot.qty -= a.qty;
    }
    book.lots = book.lots.filter(l=>l.qty>0.0000001);
    __gt_updateActiveTargetLotForTicker(book);
    // Add cash
    pf.cash = Math.round(((Number(pf.cash) || 0) + (proceeds - f)) * 100) / 100;
    // Record TX
    pf.transactions.unshift({
      id:id(), type:"sell", date: date || today(), ticker,
      qty: totalQty, price: pSell, fees: f,
      proceeds, grossPL, tax, netPL,
      lotLinks: allocations.map(a=>({ lotId:a.lotId, qty:a.qty })),
      note
    });
    // Cleanup empty ticker
    if(book.lots.length===0){ delete pf.holdings[ticker]; }
    pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  // === XTB IMPORTER v1: XLSX -> konfigurator BUY/SELL ===
  let __xtbImportPortfolioId = null;
  let __xtbAggregated = null;
  let __xtbImportModal = null;

  function startXtbImportForPortfolio(pfId){
    __xtbImportPortfolioId = pfId;
    const input = document.getElementById("xtbImportFile");
    if(!input){
      alert("Brak pola pliku XTB w HTML.");
      return;
    }
    input.value = "";
    input.click();
  }

  function __xtbExcelDateToJs(value){
    if (value instanceof Date) return value;
    if (typeof value === "number") {
      const epoch = new Date(Date.UTC(1899, 11, 30));
      const ms = value * 24 * 60 * 60 * 1000;
      return new Date(epoch.getTime() + ms);
    }
    return value || null;
  }

  function __xtbParseNumber(val){
    if (typeof val === "number") return val;
    if (val == null) return NaN;
    let s = String(val).replace(/\\s+/g, "");
    s = s.replace(",", ".");
    const n = Number(s);
    return isNaN(n) ? NaN : n;
  }

  function __xtbDetectHeaderRow(rows, requiredCols){
    for(let i=0;i<rows.length;i++){
      const r = rows[i] || [];
      let ok = true;
      for(const name of requiredCols){
        if(!r.includes(name)){ ok = false; break; }
      }
      if(ok) return i;
    }
    return -1;
  }

  function __xtbBuildIndexMap(headerRow){
    const map = {};
    headerRow.forEach((name, idx)=>{
      if(typeof name === "string" && name.trim()){
        map[name.trim()] = idx;
      }
    });
    return map;
  }

  function __xtbNormalizeSymbol(sym){
    if(!sym) return { full:"", base:"" };
    const s = String(sym).trim();
    const parts = s.split(".");
    return { full:s, base:parts[0] };
  }

  function __xtbParseCashSheet(sheet){
    const out = [];
    if(!sheet) return out;
    const array = XLSX.utils.sheet_to_json(sheet, {header:1, defval:null, raw:true});
    if(!array || !array.length) return out;

    const headerIdx = __xtbDetectHeaderRow(array, ["ID","Type","Time","Comment","Symbol","Amount"]);
    if(headerIdx === -1) return out;
    const header = array[headerIdx];
    const idx = __xtbBuildIndexMap(header);

    for(let r=headerIdx+1;r<array.length;r++){
      const row = array[r] || [];
      const maybeTotal = row[idx["ID"]];
      if(maybeTotal === "Total") break;

      const type = row[idx["Type"]];
      const time = row[idx["Time"]];
      const comment = row[idx["Comment"]];
      const symbol = row[idx["Symbol"]];
      const amount = row[idx["Amount"]];

      if(!type || !time || !comment || !symbol || amount == null) continue;

      const t = String(type).toUpperCase();
      if (t !== "STOCK PURCHASE" && t !== "STOCK SALE") continue;

      const norm = __xtbNormalizeSymbol(symbol);

      const m = String(comment).match(/(OPEN|CLOSE)\s+BUY\s+([0-9.,]+)\/([0-9.,]+)\s+@\s+([0-9.,]+)/i);
      if(!m) continue;
      const qty = __xtbParseNumber(m[2]);
      const price = __xtbParseNumber(m[4]);
      if(!qty || !price) continue;

      const side = (t === "STOCK PURCHASE") ? "BUY" : "SELL";

      out.push({
        symbolFull: norm.full,
        symbol: norm.base,
        side: side,
        qty: qty,
        price: price,
        time: __xtbExcelDateToJs(time),
        sheet: "CASH",
        rawType: type,
        comment: String(comment||"")
      });
    }
    return out;
  }

  function __xtbBuildAggregated(rows){
    const agg = {};
    rows.forEach(r => {
      const ticker = (r.symbol || "").toUpperCase();
      if(!ticker) return;
      if(!agg[ticker]){
        agg[ticker] = {
          ticker,
          symbolFull: r.symbolFull || ticker,
          buys: [],
          sells: [],
          buyTotalQty: 0,
          buyTotalCash: 0,
          buyFirstDate: null,
          sellTotalQty: 0,
          sellTotalCash: 0,
          sellFirstDate: null
        };
      }
      const entry = agg[ticker];
      if(r.side === "BUY"){
        entry.buys.push(r);
        entry.buyTotalQty += r.qty;
        entry.buyTotalCash += r.qty * r.price;
        const dt = r.time instanceof Date ? r.time : __xtbExcelDateToJs(r.time);
        if(dt && (!entry.buyFirstDate || dt < entry.buyFirstDate)) entry.buyFirstDate = dt;
      }else if(r.side === "SELL"){
        entry.sells.push(r);
        entry.sellTotalQty += r.qty;
        entry.sellTotalCash += r.qty * r.price;
        const dt = r.time instanceof Date ? r.time : __xtbExcelDateToJs(r.time);
        if(dt && (!entry.sellFirstDate || dt < entry.sellFirstDate)) entry.sellFirstDate = dt;
      }
    });

    Object.keys(agg).forEach(t => {
      const e = agg[t];
      e.buyAvgPrice = e.buyTotalQty > 0 ? (e.buyTotalCash / e.buyTotalQty) : 0;
      e.sellAvgPrice = e.sellTotalQty > 0 ? (e.sellTotalCash / e.sellTotalQty) : 0;
    });
    return agg;
  }

  function __xtbEnsureImportModal(){
    if(__xtbImportModal) return __xtbImportModal;
    const wrap = document.createElement("div");
    wrap.id = "xtbImportModal";
    wrap.style.position = "fixed";
    wrap.style.inset = "0";
    wrap.style.display = "none";
    wrap.style.alignItems = "center";
    wrap.style.justifyContent = "center";
    wrap.style.background = "rgba(15,23,42,0.8)";
    wrap.style.zIndex = "9999";

    const card = document.createElement("div");
    card.style.background = "#020617";
    card.style.borderRadius = "12px";
    card.style.border = "1px solid rgba(148,163,184,0.6)";
    card.style.padding = "12px 14px";
    card.style.maxWidth = "780px";
    card.style.width = "100%";
    card.style.maxHeight = "80vh";
    card.style.boxShadow = "0 22px 60px rgba(15,23,42,0.9)";
    card.style.fontSize = "12px";
    card.style.color = "#e5e7eb";
    card.style.display = "flex";
    card.style.flexDirection = "column";
    card.style.gap = "8px";

    const title = document.createElement("div");
    title.id = "xtbImportTitle";
    title.style.fontWeight = "600";
    title.style.fontSize = "13px";
    card.appendChild(title);

    const desc = document.createElement("div");
    desc.textContent = "Wybierz, które spółki z pliku XTB chcesz zaimportować. BUY zostaną dodane jako nowe zakupy, SELL możesz powiązać z wybranymi partiami.";
    desc.style.fontSize = "11px";
    desc.style.color = "#94a3b8";
    card.appendChild(desc);

    const body = document.createElement("div");
    body.id = "xtbImportBody";
    body.style.display = "flex";
    body.style.flexDirection = "column";
    body.style.gap = "6px";
    body.style.overflow = "auto";
    body.style.padding = "4px 0";
    card.appendChild(body);

    const footer = document.createElement("div");
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "6px";

    const cancelBtn = document.createElement("button");
    cancelBtn.type = "button";
    cancelBtn.textContent = "Anuluj";
    cancelBtn.style.padding = "4px 10px";
    cancelBtn.style.borderRadius = "999px";
    cancelBtn.style.border = "1px solid rgba(148,163,184,0.6)";
    cancelBtn.style.background = "transparent";
    cancelBtn.style.color = "#e5e7eb";
    cancelBtn.style.fontSize = "11px";
    cancelBtn.style.cursor = "pointer";
    cancelBtn.addEventListener("click", function(){
      wrap.style.display = "none";
      __xtbAggregated = null;
      __xtbImportPortfolioId = null;
    });

    const importBtn = document.createElement("button");
    importBtn.type = "button";
    importBtn.id = "xtbImportConfirm";
    importBtn.textContent = "Importuj zaznaczone";
    importBtn.style.padding = "4px 10px";
    importBtn.style.borderRadius = "999px";
    importBtn.style.border = "none";
    importBtn.style.background = "#22c55e";
    importBtn.style.color = "#020617";
    importBtn.style.fontSize = "11px";
    importBtn.style.cursor = "pointer";
    importBtn.style.fontWeight = "600";

    footer.appendChild(cancelBtn);
    footer.appendChild(importBtn);
    card.appendChild(footer);

    wrap.appendChild(card);
    document.body.appendChild(wrap);

    importBtn.addEventListener("click", __xtbPerformImport);

    __xtbImportModal = wrap;
    return wrap;
  }

  function __xtbFormatDate(d){
    if(!(d instanceof Date)) return "";
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const da = String(d.getDate()).padStart(2,"0");
    return y + "-" + m + "-" + da;
  }

  function __xtbRenderImportModal(pfId, aggregated){
    const pf = getPf(pfId);
    const modal = __xtbEnsureImportModal();
    const title = modal.querySelector("#xtbImportTitle");
    const body = modal.querySelector("#xtbImportBody");
    if(title) title.textContent = "Import z XTB do portfela: " + (pf && pf.name ? pf.name : pfId);
    body.innerHTML = "";

    const tickers = Object.keys(aggregated).sort();
    if(!tickers.length){
      const info = document.createElement("div");
      info.textContent = "Brak transakcji BUY/SELL do zaimportowania.";
      info.style.fontSize = "11px";
      info.style.color = "#94a3b8";
      body.appendChild(info);
      return;
    }

    tickers.forEach(ticker => {
      const entry = aggregated[ticker];
      const row = document.createElement("div");
      row.className = "xtb-import-row";
      row.dataset.ticker = ticker;
      row.style.border = "1px solid rgba(51,65,85,0.9)";
      row.style.borderRadius = "8px";
      row.style.padding = "6px 8px";
      row.style.display = "flex";
      row.style.flexDirection = "column";
      row.style.gap = "4px";
      row.style.background = "rgba(15,23,42,0.7)";

      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.justifyContent = "space-between";
      header.style.alignItems = "center";

      const titleDiv = document.createElement("div");
      titleDiv.textContent = (entry.symbolFull || ticker);
      titleDiv.style.fontWeight = "600";
      titleDiv.style.fontSize = "12px";

      header.appendChild(titleDiv);
      row.appendChild(header);

      const cols = document.createElement("div");
      cols.style.display = "flex";
      cols.style.gap = "8px";
      cols.style.flexWrap = "wrap";

      // BUY column
      const buyCol = document.createElement("div");
      buyCol.style.flex = "1 1 260px";
      buyCol.style.minWidth = "0";

      if(entry.buyTotalQty > 0){
        const lbl = document.createElement("label");
        lbl.style.display = "flex";
        lbl.style.alignItems = "center";
        lbl.style.gap = "4px";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.className = "xtb-import-buy-checkbox";
        cb.checked = true;
        lbl.appendChild(cb);

        const span = document.createElement("span");
        span.textContent = "Zaimportuj BUY";
        lbl.appendChild(span);
        buyCol.appendChild(lbl);

        const info = document.createElement("div");
        info.style.fontSize = "11px";
        info.style.color = "#cbd5f5";
        const avg = entry.buyAvgPrice || 0;
        info.textContent = "Qty: " + entry.buyTotalQty.toFixed(4) + " | Śr. cena: " + avg.toFixed(4) + " | Transakcji: " + entry.buys.length + (entry.buyFirstDate ? " | od: " + __xtbFormatDate(entry.buyFirstDate) : "");
        buyCol.appendChild(info);
      }else{
        const info = document.createElement("div");
        info.style.fontSize = "11px";
        info.style.color = "#64748b";
        info.textContent = "Brak transakcji BUY dla tej spółki w pliku.";
        buyCol.appendChild(info);
      }

      // SELL column
      const sellCol = document.createElement("div");
      sellCol.style.flex = "1 1 260px";
      sellCol.style.minWidth = "0";

      if(entry.sellTotalQty > 0){
        const top = document.createElement("div");
        top.style.display = "flex";
        top.style.alignItems = "center";
        top.style.justifyContent = "space-between";
        top.style.gap = "4px";

        const lbl = document.createElement("label");
        lbl.style.display = "flex";
        lbl.style.alignItems = "center";
        lbl.style.gap = "4px";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.className = "xtb-import-sell-checkbox";
        cb.checked = true;
        lbl.appendChild(cb);
        const span = document.createElement("span");
        span.textContent = "Zaimportuj SELL";
        lbl.appendChild(span);
        top.appendChild(lbl);

        const lotsBtn = document.createElement("button");
        lotsBtn.type = "button";
        lotsBtn.textContent = "Pokaż partie";
        lotsBtn.className = "xtb-sell-lots-toggle";
        lotsBtn.dataset.ticker = ticker;
        lotsBtn.style.padding = "2px 8px";
        lotsBtn.style.borderRadius = "999px";
        lotsBtn.style.border = "1px solid rgba(148,163,184,0.7)";
        lotsBtn.style.background = "transparent";
        lotsBtn.style.color = "#e5e7eb";
        lotsBtn.style.fontSize = "10px";
        lotsBtn.style.cursor = "pointer";
        top.appendChild(lotsBtn);

        sellCol.appendChild(top);

        const info = document.createElement("div");
        info.style.fontSize = "11px";
        info.style.color = "#fecaca";
        const avg = entry.sellAvgPrice || 0;
        info.textContent = "Qty (XTB): " + entry.sellTotalQty.toFixed(4) + " | Śr. cena SELL: " + avg.toFixed(4) + " | Transakcji: " + entry.sells.length + (entry.sellFirstDate ? " | od: " + __xtbFormatDate(entry.sellFirstDate) : "");
        sellCol.appendChild(info);

        const lotsWrap = document.createElement("div");
        lotsWrap.className = "xtb-sell-lots";
        lotsWrap.dataset.ticker = ticker;
        lotsWrap.style.display = "none";
        lotsWrap.style.marginTop = "4px";
        lotsWrap.style.borderTop = "1px solid rgba(51,65,85,0.9)";
        lotsWrap.style.paddingTop = "4px";

        const pfHold = pf && pf.holdings && pf.holdings[ticker] ? pf.holdings[ticker] : null;
        const lots = pfHold && Array.isArray(pfHold.lots) ? pfHold.lots : [];

        if(lots.length){
          const tbl = document.createElement("table");
          tbl.style.width = "100%";
          tbl.style.borderCollapse = "collapse";
          const thead = document.createElement("thead");
          const hr = document.createElement("tr");
          ["", "Data", "Qty", "Cena zakupu"].forEach(txt => {
            const th = document.createElement("th");
            th.textContent = txt;
            th.style.fontSize = "10px";
            th.style.fontWeight = "500";
            th.style.textAlign = "left";
            th.style.padding = "2px 4px";
            th.style.color = "#94a3b8";
            hr.appendChild(th);
          });
          thead.appendChild(hr);
          tbl.appendChild(thead);

          const tb = document.createElement("tbody");
          lots.forEach(lot => {
            const tr = document.createElement("tr");
            tr.style.fontSize = "11px";

            const tdCb = document.createElement("td");
            tdCb.style.padding = "2px 4px";
            const cbLot = document.createElement("input");
            cbLot.type = "checkbox";
            cbLot.className = "xtb-sell-lot-checkbox";
            cbLot.dataset.ticker = ticker;
            cbLot.dataset.lotid = lot.lotId;
            cbLot.dataset.qty = Number(lot.qty||0);
            tdCb.appendChild(cbLot);
            tr.appendChild(tdCb);

            const tdDate = document.createElement("td");
            tdDate.style.padding = "2px 4px";
            tdDate.textContent = lot.date || "";
            tr.appendChild(tdDate);

            const tdQty = document.createElement("td");
            tdQty.style.padding = "2px 4px";
            tdQty.textContent = (Number(lot.qty)||0).toFixed(4);
            tr.appendChild(tdQty);

            const tdPrice = document.createElement("td");
            tdPrice.style.padding = "2px 4px";
            tdPrice.textContent = (Number(lot.unitCost)||0).toFixed(4);
            tr.appendChild(tdPrice);

            tb.appendChild(tr);
          });
          tbl.appendChild(tb);
          lotsWrap.appendChild(tbl);
        }else{
          const noLots = document.createElement("div");
          noLots.textContent = "Brak otwartych partii na ten ticker w portfelu.";
          noLots.style.fontSize = "11px";
          noLots.style.color = "#f97373";
          lotsWrap.appendChild(noLots);
        }

        sellCol.appendChild(lotsWrap);
      }else{
        const info = document.createElement("div");
        info.style.fontSize = "11px";
        info.style.color = "#64748b";
        info.textContent = "Brak transakcji SELL dla tej spółki w pliku.";
        sellCol.appendChild(info);
      }

      cols.appendChild(buyCol);
      cols.appendChild(sellCol);
      row.appendChild(cols);
      body.appendChild(row);
    });

    // toggle buttons
    const toggles = modal.querySelectorAll(".xtb-sell-lots-toggle");
    toggles.forEach(btn => {
      btn.addEventListener("click", function(){
        const t = btn.dataset.ticker;
        const wrap = modal.querySelector(".xtb-sell-lots[data-ticker='"+t+"']");
        if(!wrap) return;
        wrap.style.display = wrap.style.display === "none" ? "block" : "none";
      });
    });
  }

  function __xtbPerformImport(){
    const pfId = __xtbImportPortfolioId;
    if(!pfId || !__xtbAggregated){
      alert("Brak danych importu XTB.");
      return;
    }
    const pf = getPf(pfId);
    if(!pf){
      alert("Portfel nie istnieje.");
      return;
    }

    const modal = __xtbImportModal || document.getElementById("xtbImportModal");
    const body = modal ? modal.querySelector("#xtbImportBody") : null;

    let buysImported = 0;
    let sellsImported = 0;
    let skipped = 0;

    function toDateStr(d){
      const x = d instanceof Date ? d : __xtbExcelDateToJs(d);
      if(!(x instanceof Date)) return today();
      const y = x.getFullYear();
      const m = String(x.getMonth()+1).padStart(2,"0");
      const da = String(x.getDate()).padStart(2,"0");
      return y+"-"+m+"-"+da;
    }

    const tickers = Object.keys(__xtbAggregated);
    tickers.forEach(ticker => {
      const entry = __xtbAggregated[ticker];
      const rowEl = body ? body.querySelector(".xtb-import-row[data-ticker='"+ticker+"']") : null;
      if(!rowEl) return;

      const buyCb = rowEl.querySelector(".xtb-import-buy-checkbox");
      const sellCb = rowEl.querySelector(".xtb-import-sell-checkbox");

      // BUY import
      if(buyCb && buyCb.checked && entry.buyTotalQty > 0){
        try{
          const dateStr = entry.buyFirstDate ? toDateStr(entry.buyFirstDate) : today();
          const qty = entry.buyTotalQty;
          const price = entry.buyAvgPrice || 0;
          buy(pfId, {
            ticker,
            date: dateStr,
            qty: qty,
            price: price,
            fees: 0,
            note: "Import XTB BUY (" + entry.buys.length + " trans.)",
            targetPct: null,
            targetPrice: null,
            buyTargetPct: null,
            buyTargetPrice: null
          });
          buysImported++;
        }catch(err){
          console.error("XTB import BUY error", err);
          skipped++;
        }
      }

      // SELL import
      if(sellCb && sellCb.checked && entry.sellTotalQty > 0){
        try{
          const lotCbs = rowEl.querySelectorAll(".xtb-sell-lot-checkbox");
          const selected = [];
          lotCbs.forEach(cb => {
            if(cb.checked){
              selected.push({
                lotId: cb.dataset.lotid,
                qty: Number(cb.dataset.qty)||0
              });
            }
          });
          if(!selected.length){
            skipped++;
            return;
          }
          const totalXtbQty = entry.sellTotalQty || 0;
          if(totalXtbQty <= 0){
            skipped++;
            return;
          }
          let remaining = totalXtbQty;
          const allocations = [];
          // Alokujemy częściowo z zaznaczonych partii aż do wyczerpania ilości XTB
          selected.forEach(s => {
            if(remaining <= 0) return;
            const lotQty = Number(s.qty) || 0;
            if(lotQty <= 0) return;
            const useQty = Math.min(lotQty, remaining);
            if(useQty > 0){
              allocations.push({ lotId: s.lotId, qty: useQty });
              remaining -= useQty;
            }
          });
          if(!allocations.length){
            skipped++;
            return;
          }
          const sellPrice = entry.sellAvgPrice || 0;
          const sellDateStr = entry.sellFirstDate ? toDateStr(entry.sellFirstDate) : today();
          sell(pfId, {
            ticker,
            date: sellDateStr,
            sellPrice: sellPrice,
            fees: 0,
            allocations: allocations,
            note: "Import XTB SELL (zaznaczone partie, " + entry.sells.length + " trans.)"
          });
          sellsImported++;
        }catch(err){
          console.error("XTB import SELL error", err);
          skipped++;
        }
      }
    });


    if(modal) modal.style.display = "none";
    __xtbImportPortfolioId = null;
    __xtbAggregated = null;

    alert(
      "Import XTB zakończony.\\n" +
      "BUY dodane: " + buysImported + "\\n" +
      "SELL wykonane: " + sellsImported + "\\n" +
      "Pominięte / błędne: " + skipped
    );
  }

  function __xtbHandleFileInputChange(ev){
    const input = ev.target;
    const file = input.files && input.files[0];
    if(!file) return;
    if(typeof XLSX === "undefined"){
      alert("Brak biblioteki XLSX (SheetJS). Sprawdź połączenie z internetem.");
      return;
    }
    const pfId = __xtbImportPortfolioId;
    if(!pfId){
      alert("Najpierw wybierz portfel dla importu XTB.");
      return;
    }

    const reader = new FileReader();
    reader.onload = function(e){
      let wb;
      try{
        const data = new Uint8Array(e.target.result);
        wb = XLSX.read(data, {type:"array", cellDates:true});
      }catch(err){
        console.error("XTB import: błąd parsowania pliku", err);
        alert("Nie udało się odczytać pliku XTB (XLSX).");
        return;
      }
      const sheetNames = wb.SheetNames || [];

      const cashName = sheetNames.find(n => n.toUpperCase().startsWith("CASH OPERATION"));
      const rowsAll = [];
      if(cashName && wb.Sheets[cashName]){
        rowsAll.push(...__xtbParseCashSheet(wb.Sheets[cashName]));
      }

      if(!rowsAll.length){
        alert("Nie znaleziono żadnych pozycji akcyjnych (Stock purchase/sale) w arkuszu CASH OPERATION HISTORY.");
        return;
      }

      const aggregated = __xtbBuildAggregated(rowsAll);
      __xtbAggregated = aggregated;
      __xtbImportPortfolioId = pfId;
      __xtbRenderImportModal(pfId, aggregated);
      const modal = __xtbEnsureImportModal();
      modal.style.display = "flex";
    };
    reader.readAsArrayBuffer(file);
  }

  (function(){
    const fi = document.getElementById("xtbImportFile");
    if(fi) fi.addEventListener("change", __xtbHandleFileInputChange);
  })();


  // Rendering

  // Compute holdings (using live quote if available, else unitCost) and totals
  function computeHoldingsAndTotalValues(pf){
    try{
      let holdingsValue = 0;
      for(const [ticker, book] of Object.entries(pf.holdings||{})){
        const lots = (book && Array.isArray(book.lots)) ? book.lots : [];
        const qPrice = getQuote(ticker);
        for(const l of lots){
          const qty = Number(l.qty)||0;
          const unit = (qPrice!=null ? Number(qPrice) : Number(l.unitCost)||0);
          holdingsValue += qty * unit;
        }
      }
      const totalWithCash = holdingsValue + (Number(pf.cash)||0);
      return { holdingsValue, totalWithCash };
    }catch(e){
      return { holdingsValue: 0, totalWithCash: Number(pf.cash)||0 };
    }
  }

function renderPortfolioList(){
  setTimeout(()=>{ try { updateSidebarBlinkStates(); } catch(e) {} }, 0);

    portfolioListEl.innerHTML = "";
    for(const pf of ((typeof ST!=='undefined' && ST.DB && Array.isArray(ST.DB.portfolios)) ? ST.DB.portfolios : ((typeof DB!=='undefined' && Array.isArray(DB.portfolios)) ? DB.portfolios : []))){
      const totalLots = Object.values(pf.holdings).reduce((acc, v)=> acc + v.lots.length, 0);
      const el = document.createElement("div");
      el.className = "portfolio-item" + (pf.id===currentPfId ? " active": "");
      el.dataset.pfId = pf.id;
      try {
        const _state = portfolioTargetState(pf);
        if(_state === "hit") el.classList.add("hit-target");
        else if(_state === "near") el.classList.add("near-target");
      } catch(e) {}

      el.innerHTML = `
        <div class="name">${__esc(pf.name)}</div>
        <div class="row">
          <div class="tag">Gotówka: ${__go_fmtCurrency(pf.cash, pf.currency)}</div>
        <div class="row">
          <div class="tag">Akcje: ${__go_fmtCurrency((computeHoldingsAndTotalValues(pf).holdingsValue), pf.currency)}</div>
          <div class="tag">Razem: ${__go_fmtCurrency((computeHoldingsAndTotalValues(pf).totalWithCash), pf.currency)}</div>
        </div>

          <div class="tag">Partie: ${totalLots}</div>
        </div>
        <div class="row">
          <div class="small">Waluta: ${pf.currency}</div>
          <div class="small">modyf: ${new Date(pf.updatedAt).toLocaleDateString('pl-PL')}</div>
        </div>
        <div class="row">
          <button class="btn ghost btn-xtb-import" type="button" title="Import transakcji z XTB do tego portfela">⬆️ Import z XTB</button>
        </div>
      `;
      el.addEventListener('click', ()=> { 
      try{ 
        const main = document.querySelector('.main') || document.querySelector('main');
        if(main){
          main.querySelectorAll(':scope > section').forEach(sec=>{
            if(sec.id==='alertsPanel' || sec.id==='wishlistPanel') sec.style.display='none'; else sec.style.display='';
          });
        }
      }catch(_){}
      currentPfId = pf.id; render(); 
    });

      const importBtn = el.querySelector(".btn-xtb-import");
      if (importBtn) {
        importBtn.addEventListener("click", (ev)=>{
          ev.stopPropagation();
          startXtbImportForPortfolio(pf.id);
        });
      }

      portfolioListEl.appendChild(el);
    }
    if(!currentPfId && DB.portfolios.length===0){
      const empty = document.createElement('div');
      empty.className="small";
      empty.innerHTML = "Brak portfeli. Kliknij <b>Nowy portfel</b>, aby rozpocząć.";
      portfolioListEl.appendChild(empty);
    }
  }

  function renderMain(){
    const pf = getPf(currentPfId);
    if(!pf){
      pfTitleEl.textContent = "Wybierz portfel";
      cashBalanceEl.textContent = "—";
      realizedPLEl.textContent = "—";
      realizedPLnetEl.textContent = "netto";
      strategyBox.value = "";
      holdingsTableWrap.innerHTML = "";
      txTableWrap.innerHTML = "";
      return;
    }
    ensureTransactionsCoherent(pf);
    maybeWarnTxLoss(pf);
    pfTitleEl.textContent = `${pf.name} (${pf.currency})`;
    strategyBox.value = pf.strategy || "";
    cashBalanceEl.textContent = __go_fmtCurrency(pf.cash, pf.currency);
    const {sumGross, sumTax, sumNet} = realizedSums(pf);
    realizedPLEl.textContent = __go_fmtCurrency(sumGross, pf.currency);
    realizedPLnetEl.textContent = __go_fmtCurrency(sumNet, pf.currency);

    // Holdings table
    holdingsTableWrap.innerHTML = buildHoldingsTableHTML(pf);
// Show integrity warnings (non-blocking)
try{
  const errWrapId = 'pfErrorsBanner';
  let old = document.getElementById(errWrapId);
  if(old) old.remove();
  const errs = Array.isArray(pf.__errors) ? pf.__errors : [];
  if(errs.length){
    const wrap = document.createElement('div');
    wrap.id = errWrapId;
    wrap.className = 'banner warn';
    const details = errs.slice(0,4).map(e => `${e.date||'—'} • ${e.ticker||'—'} • ${e.message||''}`).join('<br>');
    wrap.innerHTML = `<div>⚠️ Niespójne transakcje: ${errs.length}. <span class="small" style="opacity:.85">Edycja nie została zablokowana — sprawdź szczegóły i popraw daty/alokacje.</span><div class="small" style="margin-top:6px">${details}${errs.length>4?'<br>…':''}</div></div><div style="display:flex;gap:8px"><button class="btn ghost" id="pfErrorsDismiss">OK</button><button class="btn warn" id="pfErrorsIgnore">Ignoruj sprzedaże</button></div>`;
    const main = document.querySelector('main') || document.querySelector('.main') || document.body;
    main.prepend(wrap);
    document.getElementById('pfErrorsDismiss')?.addEventListener('click', ()=> wrap.remove());
        document.getElementById('pfErrorsIgnore')?.addEventListener('click', ()=> { try{ __ignoreInconsistentSells(); }catch(_){ alert('Błąd ignorowania.'); } });
  }
}catch(_){}

    
    // Update left sidebar tile blinking for the current portfolio
    (function(){
      const state = portfolioTargetState(pf); // "hit" | "near" | "none"
      // Clear previous blinking classes on all sidebar items
      document.querySelectorAll('.portfolio-item').forEach(el=>{
        el.classList.remove('hit-target','near-target');
      });
      // Apply to the current portfolio's tile
      const curEl = document.querySelector(`.portfolio-item[data-pf-id="${pf.id}"]`);
      if(curEl){
        if(state === "hit") curEl.classList.add('hit-target');
        else if(state === "near") curEl.classList.add('near-target');
      }
    })();

// Transactions table
    txTableWrap.innerHTML = buildTxTableHTML(pf, filterQueryEl.value.trim());
    try { updateSidebarBlinkStates(); } catch(e) {}
}

  function realizedSums(pf, range){
    let sumGross = 0, sumTax = 0, sumNet = 0;
    for(const t of pf.transactions){
      if(t.type==="sell"){
        try{ const ms = toMs(t && t.date); if(range && !inRangeMs(ms, range)) continue; }catch(_){}
        sumGross += Number(t.grossPL)||0;
        sumTax   += Number(t.tax)||0;
        sumNet   += Number(t.netPL || (t.grossPL - (t.grossPL>0 ? (DB.settings.taxRate||0.19)*t.grossPL : 0)));
      }
    }
    return {sumGross, sumTax, sumNet};
  }

  
  
  
  function buildHoldingsTableHTML(pf){
    const sections = [];
    const __rows = [];
    for(const [ticker, book] of Object.entries(pf.holdings)){
      const __cn = getCompanyName(ticker);
      const displayName = __cn ? `${__esc(ticker)} <span class="muted small" style="font-weight:400">${__esc(__cn)}</span>` : __esc(ticker);
      const lots = book.lots || [];
      const totalQty = lots.reduce((a,l)=>a+Number(l.qty||0),0);
      const costBasis = lots.reduce((a,l)=>a + Number(l.qty||0)*Number(l.unitCost||0),0);
      const avgCost = totalQty>0 ? costBasis / totalQty : 0;
      const lastPrice = getQuote(ticker);

      let nearestTarget = null, statusClass = "";
let nearestDist = Infinity;
let statusRank = -1; // 3: hit-sell, 2: hit-buy, 1: near-sell, 0: near-buy
for(const l of lots){
  if(l && l.autoMutedForTargets) continue;
  l._ticker = ticker;
  const sellT = computeTargetPrice(l);
  const buyT  = computeBuyTargetPrice(l);
  const st = targetStatus(l);
  const rank = st.state==="hit" ? (st.kind==="sell"?3:2) : (st.state==="near" ? (st.kind==="sell"?1:0) : -1);
  if(rank > statusRank){
    statusRank = rank;
    if(rank===3) statusClass = "hit-target-sell";
    else if(rank===2) statusClass = "hit-target-buy";
    else if(rank===1) statusClass = "near-target-sell";
    else if(rank===0) statusClass = "near-target-buy";
  }
  // suppress blinking for acknowledged alarms
  (function(){
    const map = {"hit-target-sell":{state:"hit",kind:"sell"},"hit-target-buy":{state:"hit",kind:"buy"},"near-target-sell":{state:"near",kind:"sell"},"near-target-buy":{state:"near",kind:"buy"}};
    const info = map[statusClass];
    if(info && isAlertAcked(ticker, info.kind, info.state)){ statusClass = ""; }
  })();

  const candidates = [];
  if(sellT!=null) candidates.push(sellT);
  if(buyT!=null)  candidates.push(buyT);
  for(const t of candidates){
    if(lastPrice!=null){
      const d = Math.abs((lastPrice - t)/t);
      if(d < nearestDist){ nearestDist = d; nearestTarget = t; }
    } else {
      if(nearestTarget==null) nearestTarget = t; else nearestTarget = Math.min(nearestTarget, t);
    }
  }
      // Log per-ticker alarm to Firestore (deduplicated)
      (function(){
        const map = {
          "hit-target-sell": {state:"hit",  kind:"sell"},
          "hit-target-buy":  {state:"hit",  kind:"buy"},
          "near-target-sell":{state:"near", kind:"sell"},
          "near-target-buy": {state:"near", kind:"buy"}
        };
        const info = map[statusClass];
        if(info && nearestTarget!=null && lastPrice!=null){
          const key = ['pf', (pf&&pf.id)||'default', ticker, info.kind].join('|');
          if(__shouldLogAlarm(key, info.state)){ try{ window.showToast && showToast({ticker:r.t, state:info.state, kind:info.kind}); }catch(_){} try{ window.showToast && showToast({ticker, state:info.state, kind:info.kind}); }catch(_){}
            try{ logAlarmEvent({scope:'portfolio', pfId:(pf&&pf.id)||null, ticker, state:info.state, kind:info.kind, price:lastPrice, target:nearestTarget}); }catch(_){}
          }
        }
      })();
    
}

      const lotRowsArr = lots.map((l,i)=>{
        const t = computeTargetPrice(l);
        l._ticker = ticker;
        const st = (l && l.autoMutedForTargets) ? {state:"none"} : targetStatus(l);
        const cls = st.state==="hit" ? (st.kind==="sell"?"hit-target-sell":"hit-target-buy") : (st.state==="near" ? (st.kind==="sell"?"near-target-sell":"near-target-buy") : "");
        return (
          `<tr data-lotid="${l.lotId}" class="${cls}">`+
            `<td>${i+1}</td>`+
            `<td>${__esc(l.date||"")}</td>`+
            `<td>${__fmtNum(l.qty)}</td>`+
            `<td>${__go_fmtCurrency(l.unitCost, pf.currency)}</td>`+
            `<td>${__go_fmtCurrency(l.qty*l.unitCost, pf.currency)}</td>`+
            `<td>`+
            ( (t!=null?`<span class="sell-target" style="color:#16a34a">${__go_fmtCurrency(t, pf.currency)}</span>`:``) +
              ( (computeBuyTargetPrice(l)!=null)?`<div class="buy-target" style="color:#dc2626">${__go_fmtCurrency(computeBuyTargetPrice(l), pf.currency)}</div>`:``) +
              (t==null && computeBuyTargetPrice(l)==null? '—': '')
            )+
            `</td>`+
            `<td>${lastPrice!=null?__fmtNum(lastPrice):"—"}</td><td>${(()=>{ const __p = (lastPrice!=null? Number(lastPrice) : null); const __uc = Number(l.unitCost)||0; const __q = Number(l.qty)||0; const __pl = (__p!=null && isFinite(__p)) ? (__q*(__p-__uc)) : null; return (__pl==null) ? "—" : ("<span class='"+(__pl>=0?"ok-text":"danger-text")+"'>"+__go_fmtCurrency(__pl, pf.currency)+"</span>"); })()}</td><td>${(()=>{ const __p = (lastPrice!=null? Number(lastPrice) : null); const __uc = Number(l.unitCost)||0; const __pct = (__p!=null && __uc>0) ? (((__p-__uc)/__uc)*100) : null; return (__pct==null) ? "—" : fmtPct(__pct); })()}</td>`+
            `<td>${(()=>{ 
  const __ch = getQuoteChangePct(ticker); 
  const __tr = getQuoteTrend(ticker); 
  const __arrow = (__tr===1)?'<span class="change-arrow up">▲</span>':(__tr===-1)?'<span class="change-arrow down">▼</span>':'';
  return (__ch!=null) ? (__arrow + "<span class='pct-badge "+(__ch>=0?"pct-pos ok-text":"pct-neg danger-text")+"'>"+fmtPct(__ch)+"</span>") : "—"; 
})()}</td>`+
            `<td>${st.state==="hit"?"🎯":(st.state==="near"?"⏳":"—")}</td>`+
          `<td><button class="btn ghost lot-edit" data-ticker="${ticker}" data-lot="${l.lotId}">📝</button> <button class="btn ok lot-sell" data-ticker="${ticker}" data-lot="${l.lotId}" data-maxqty="${l.qty}">💸</button> <button class="btn ghost lot-mute" data-action="lot-mute" data-ticker="${ticker}" data-lot="${l.lotId}" title="${l.muted?'Włącz alert':'Wycisz alert'}">${l.muted?'🔕':'🔔'}</button></td></tr>`
        );
      });
      const lotRowsHTML = lotRowsArr.join("") || '<tr data-lotid=\"${lot.lotId}\"><td colspan="8" class="center muted">Brak partii</td></tr>';

      const detailsHTML = (
        `<details><summary>${displayName} <button class="btn small ghost add-lot" data-ticker="${__esc(ticker)}" title="Dodaj nową partię">➕</button> <button class="btn small ghost transfer-company" data-ticker="${__esc(ticker)}" title="Przenieś całą spółkę do innego portfela">🔄</button></summary>`+
        `<div style="padding:8px 0">`+
          `<div class="table-wrap">`+
            `<table>`+
              `<thead>`+
                `<tr><th>#</th><th>Data</th><th>Ilość</th><th>Koszt / szt.</th><th>Wartość księgowa</th><th>Sugerowana cena</th><th>Kurs</th><th>P/L</th><th>P/L %</th><th>Δ dzienny</th><th>Status</th><th>Akcje</th></tr>`+
              `</thead>`+
              `<tbody>${lotRowsHTML}</tbody>`+
            `</table>`+
          `</div>`+
        `</div>`+
        `</details>`
      );

      __rows.push({ dist: nearestDist, html: `<tbody>`+
          `<tr class="${statusClass}">`+
            `<td class="ticker">${detailsHTML} </td>`+
            `<td>${__fmtNum(totalQty)}</td>`+
            `<td>${__go_fmtCurrency(avgCost, pf.currency)}</td>`+
            `<td>${__go_fmtCurrency(costBasis, pf.currency)}</td>`+
            `<td>${lastPrice!=null?__fmtNum(lastPrice):"—"}</td>`+
            `<td>${(()=>{ 
  const __ch = getQuoteChangePct(ticker); 
  const __tr = getQuoteTrend(ticker); 
  const __arrow = (__tr===1)?'<span class="change-arrow up">▲</span>':(__tr===-1)?'<span class="change-arrow down">▼</span>':'';
  return (__ch!=null) ? (__arrow + "<span class='pct-badge "+(__ch>=0?"pct-pos ok-text":"pct-neg danger-text")+"'>"+fmtPct(__ch)+"</span>") : "—"; 
})()}</td>`+
            `<td>${(()=>{ if(nearestTarget==null) return "—";  let kind=null, best=Infinity;  for(const l of lots){    if(l && l.autoMutedForTargets) continue;    const s=computeTargetPrice(l); if(s!=null){ const d=Math.abs((nearestTarget-s)/nearestTarget); if(d<best){ best=d; kind='sell'; } }    const b=computeBuyTargetPrice(l); if(b!=null){ const d=Math.abs((nearestTarget-b)/nearestTarget); if(d<best){ best=d; kind='buy'; } }  }  const lbl = kind==='sell'?'cel sprzedaży':(kind==='buy'?'cel zakupu':'');  return __go_fmtCurrency(nearestTarget, pf.currency) + (lbl?`<div class="small" style="opacity:.75; ${kind==='sell'?'color:#16a34a':(kind==='buy'?'color:#dc2626':'')}">${lbl}</div>`:""); })()}</td>`+
            `<td>${(()=>{ const p=lastPrice; const t=nearestTarget; if(p==null||t==null||t<=0) return "—"; const dist = Math.abs(p - t) / t; const pctStr = (dist*100).toFixed(2) + "%"; const localTol = (Number(DB.settings.approachTolerancePct)||1)/100; const cls = (dist<=1e-6) ? "ok-text" : (dist <= (localTol/2) ? "warn-strong-text" : "warn-text"); return `<span class="${cls}">${pctStr}</span>`; })()}</td>`+
            `<td><span class="small">${statusClass? (statusClass==="hit-target"?"🎯 cel osiągnięty":"⏳ blisko celu"):"—"}</span></td>`+
            `<td class="row" style="gap:6px"><button class="btn danger del-company" data-ticker="${__esc(ticker)}">🗑</button> <button class="btn ghost tv-link" data-ticker="${__esc(ticker)}" title="TradingView">📈</button> <button class="btn ghost info-company" data-ticker="${__esc(ticker)}">ℹ️</button></td>`+
          `</tr>`+
        `</tbody>`
      });
    }
    /* sort by nearest target distance */
    if(__rows.length){
      __rows.sort((a,b)=>{
        const ad = (a.dist==null||!isFinite(a.dist))?Infinity:a.dist;
        const bd = (b.dist==null||!isFinite(b.dist))?Infinity:b.dist;
        return ad - bd;
      });
      for(const r of __rows){ sections.push(r.html); }
    }
    const sectionsHTML = sections.join("") || '<tbody><tr><td colspan="8" class="center muted">Brak pozycji</td></tr></tbody>';
    const h = (
      `<div class="table-wrap">`+
        `<table>`+
          `<thead>`+
            `<tr>`+
              `<th>Ticker</th>`+
              `<th>Ilość</th>`+
              `<th>Śr. koszt / szt.</th>`+
              `<th>Wartość księgowa</th>`+
              `<th>Kurs</th><th>Δ dzienny</th>`+
              `<th>Najbliższy cel</th><th>Pozostało do celu</th>`+
              `<th>Status</th>`+
              `<th>Akcje</th>`+
            `</tr>`+
          `</thead>`+
          sectionsHTML+
        `</table>`+
      `</div>`
    );
    return h;
  }

  function parseFilter(q){
    // Simple filter parser: "typ:sell TSLA 2025-09"
    q = (q||"").trim();
    const parts = q.split(/\s+/).filter(Boolean);
    const f = { text: [] };
    for(const p of parts){
      const m = p.match(/^typ:(\w+)/i);
      if(m){ f.type = m[1].toLowerCase(); continue; }
      f.text.push(p.toLowerCase());
    }
    return f;
  }

  
  function buildTxTableHTML(pf, filterQ){
    const f = parseFilter(filterQ);
    const rowsArr = [];
    const txs = pf.transactions;
    for(const t of txs){
      if(f.type && t.type!==f.type) continue;
      const textBlob = JSON.stringify(t).toLowerCase();
      if(f.text?.length){
        let ok = true;
        for(const word of f.text){
          if(!textBlob.includes(word)){ ok=false; break; }
        }
        if(!ok) continue;
      }
      rowsArr.push(txRowHTML(pf, t));
    }
    const rowsHTML = rowsArr.join("") || '<tr><td colspan="11" class="center muted">Brak operacji</td></tr>';
    const h = (
      `<div class="table-wrap">`+
        `<table>`+
          `<thead>`+
            `<tr>`+
              `<th>Data</th>`+
              `<th>Typ</th>`+
              `<th>Ticker</th>`+
              `<th>Ilość</th>`+
              `<th>Cena</th>`+
              `<th>Opłaty</th>`+
              `<th>Gotówka ±</th>`+
              `<th>Zysk brutto</th>`+
              `<th>Podatek</th>`+
              `<th>Zysk netto</th>`+
              `<th>Uwagi</th><th>Akcje</th>`+
            `</tr>`+
          `</thead>`+
          `<tbody>`+ rowsHTML + `</tbody>`+
        `</table>`+
      `</div>`
    );
    return h;
  }

  function txRowHTML(pf, t){
    const cur = pf.currency;
    let cashDelta = 0;
    if(t.type==="deposit") cashDelta = t.amount;
    if(t.type==="withdraw") cashDelta = -t.amount;
    if(t.type==="buy") cashDelta = -(t.qty*t.price + (t.fees||0));
    if(t.type==="sell") cashDelta = (t.proceeds || t.qty*t.price) - (t.fees||0);
    if(t.type==="transfer_in") cashDelta = t.amount;
    if(t.type==="transfer_out") cashDelta = -t.amount;

    return `<tr data-tx="${t.id}" class="tx-row" style="cursor:pointer">
      <td>${__esc(t.date||"")}</td>
      <td>${mapType(t.type)}</td>
      <td class="ticker">${__esc(t.ticker||"")}</td>
      <td>${t.qty?__fmtNum(t.qty):"—"}</td>
      <td>${t.price?__go_fmtCurrency(t.price, cur): (t.amount?__go_fmtCurrency(t.amount, cur):"—")}</td>
      <td>${t.fees?__go_fmtCurrency(t.fees, cur):"—"}</td>
      <td>${__go_fmtCurrency(cashDelta, cur)}</td>
      <td class="${(t.grossPL??0)>=0 ? 'ok-text':'danger-text'}">${t.grossPL!==undefined?__go_fmtCurrency(t.grossPL, cur):"—"}</td>
      <td>${t.tax!==undefined?__go_fmtCurrency(t.tax, cur):"—"}</td>
      <td class="${(t.netPL??0)>=0 ? 'ok-text':'danger-text'}">${t.netPL!==undefined?__go_fmtCurrency(t.netPL, cur):"—"}</td>
      <td class="note">${__esc(t.note||"")}</td>
      <td>
        <button class="btn ghost tx-edit" data-tx="${t.id}">📝</button>
        ${t.type==='buy'?`<button class="btn ok tx-sell-from-buy" data-tx="${t.id}">💸</button>`:''}
        <button class="btn danger tx-del" data-tx="${t.id}">❌</button>
      </td>
    </tr>`;
  }
  // -- Integrity: keep transactions array valid & sorted (desc by date) --
  function ensureTransactionsCoherent(pf){
    try{
      if(!pf || !Array.isArray(pf.transactions)) { pf.transactions = []; return; }
      // drop null/undefined
      pf.transactions = pf.transactions.filter(t => t && typeof t === 'object');
      // normalize date strings and sort newest-first
      pf.transactions.sort((a,b)=>{
        const ad = Date.parse(a.date || '1970-01-01');
        const bd = Date.parse(b.date || '1970-01-01');
        return bd - ad;
      });
    }catch(_){}
  }

  // -- UI helper: show warning banner once per page load
  let __txWarnShown = false;
  function maybeWarnTxLoss(pf){
    try{
      if(!pf) return;
      const KEY = '__txCount_'+pf.id;
      const prev = Number(localStorage.getItem(KEY) || '0');
      const cur = Array.isArray(pf.transactions) ? pf.transactions.length : 0;
      // If it looks like we lost transactions, nudge to use Undo
      if(prev && cur < prev && !__txWarnShown){
        __txWarnShown = true;
        const w = document.createElement('div');
        w.className = 'banner warn';
        w.innerHTML = '⚠️ Wykryto spadek liczby transakcji ('+cur+' z '+prev+'). <button class="btn small" id="txUndoNow">Cofnij</button>';
        const hist = document.getElementById('historyPanel');
        (hist?.parentElement || document.body).insertBefore(w, hist);
        const btn = w.querySelector('#txUndoNow');
        if(btn){ btn.addEventListener('click', ()=>{ try{ undo({mode:'tx'}); }catch(_){ alert("Spróbuj ręcznie kliknąć Cofnij (Ctrl+Z)"); } }); }
        setTimeout(()=>{ w.remove(); }, 12000);
      }
      localStorage.setItem(KEY, String(cur));
    }catch(_){}
  }


  function mapType(t){
    return {
      deposit:"wpłata",
      withdraw:"wypłata",
      transfer_in:"przelew — przychód",
      transfer_out:"przelew — rozchód",
      transfer_company_in:"transfer spółki — przychód",
    transfer_company_out:"transfer spółki — rozchód",
    buy:"zakup",
      sell:"sprzedaż",
    }[t] || t;
  }

  function today(){
    return new Date().toISOString().slice(0,10);
  }

  function __esc(s){
    return (s||"").replace(/[&<>"']/g, m=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  const QUOTES = {};
const COMPANY_NAMES = {}; // ticker -> {name, ts}
 // ticker -> {price, ts}
  let quoteTimer = null;
  let isPollingQuotes = false;
let __pollerStarted = false;

  function setQuote(ticker, price, extras){
  try{
    const prev = QUOTES[ticker] || {
};
    const newPrice = Number(price) || null;
    const prevPrice = (prev && typeof prev.price !== 'undefined') ? prev.price : null;
    let trend = null;
    if(newPrice != null && prevPrice != null){
      trend = (newPrice > prevPrice) ? 1 : (newPrice < prevPrice ? -1 : 0);
    }
    QUOTES[ticker] = {
      price: newPrice,
      prevPrice: prevPrice ?? null,
      trend: trend,
      ts: Date.now(),
      pc: (extras && extras.pc != null) ? Number(extras.pc) : (prev.pc ?? null),
      dp: (extras && extras.dp != null) ? Number(extras.dp) : (prev.dp ?? null),
      d:  (extras && extras.d  != null) ? Number(extras.d)  : (prev.d  ?? null),
    };
  }catch(_){
    QUOTES[ticker] = { price: Number(price)||null, prevPrice: null, trend: null, ts: Date.now() };
  }
  try{ if(typeof maybeScanAlarmsGlobal==='function') maybeScanAlarmsGlobal(); }catch(_){ }
}
  function getQuote(ticker){
  return QUOTES[ticker]?.price ?? null;
}

function setCompanyName(ticker, name){
  try{
    if(!ticker || !name) return;
    const t = String(ticker).toUpperCase();
    COMPANY_NAMES[t] = {name: String(name), ts: Date.now()};
  }catch(_){}
}
function getCompanyName(ticker){
  try{
    const t = String(ticker).toUpperCase();
    return (COMPANY_NAMES[t] && COMPANY_NAMES[t].name) || null;
  }catch(_){ return null; }
}


function getQuotePrevClose(ticker){
  return QUOTES[ticker]?.pc ?? null;
}
function getQuoteChangePct(ticker){
  const q = QUOTES[ticker];
  if(!q) return null;
  if(Number.isFinite(q.dp)) return q.dp;
  const c = q.price, pc = q.pc;
  if(c!=null && pc>0) return ((c - pc) / pc) * 100;
  return null;
}
function getQuoteTrend(ticker){
  return QUOTES[ticker]?.trend ?? null;
}

const fmtPct = (x, d=2)=> (x===null || x===undefined || isNaN(Number(x))) ? "—" : ((Number(x)>=0?"+":"") + Number(x).toFixed(d) + "%");
  async function fetchQuoteFinnhub(ticker, tokenOverride){
  const token = resolveFinnhubToken(tokenOverride, false);
  if(!token){ return {price:null, error:'Brak tokenu (⚙️ Ustawienia)'}; }
  try{
    const url = `https://finnhub.io/api/v1/quote?symbol=${encodeURIComponent(ticker)}&token=${encodeURIComponent(token)}`;
    const res = await fetch(url);
    const j = await res.json().catch(()=>({}));
    const err = j && j.error ? j.error : (!res.ok ? ('HTTP '+res.status) : null);
    const p = (j && (j.c ?? j.pc)) ?? null;
    if(p!=null) setQuote(ticker, p, { pc: j?.pc, dp: j?.dp, d: j?.d });
    return {price: p, error: err};
  }catch(e){ return {price:null, error: e.message||'Fetch error'}; }
}


async function fetchCompanyProfile(ticker, tokenOverride){
  const token = resolveFinnhubToken(tokenOverride, false);
  if(!token){ return {name:null, error:'Brak tokenu'}; }
  try{
    const url = `https://finnhub.io/api/v1/stock/profile2?symbol=${encodeURIComponent(ticker)}&token=${encodeURIComponent(token)}`;
    const res = await fetch(url);
    const j = await res.json().catch(()=>({}));
    const err = j && j.error ? j.error : (!res.ok ? ('HTTP '+res.status) : null);
    const name = (j && j.name) || null;
    return {name, error: err};
  }catch(e){ return {name:null, error: e && e.message || 'Fetch error'}; }
}




  async function searchSymbolFinnhub(query){
  const token = resolveFinnhubToken(null, true);
  if(!token){ return {result:[], error:'Brak tokenu (⚙️ Ustawienia)'}; }
  try{
    const url = `https://finnhub.io/api/v1/search?q=${encodeURIComponent(query)}&token=${encodeURIComponent(token)}`;
    const res = await fetch(url);
    const j = await res.json().catch(()=>({}));
    const err = j && j.error ? j.error : (!res.ok ? ('HTTP '+res.status) : null);
    const result = j && Array.isArray(j.result) ? j.result : [];
    return {result, error: err};
  }catch(e){ return {result:[], error: e && e.message || 'Fetch error'}; }
}


  // Helper function for a single, rate-limited fetch loop
async function runSequentialFetches(tickers, token, delayMs = 1200) {
    if (!token || !tickers.length) {
        return; // Nothing to do
    }
    const uniqueTickers = Array.from(new Set(tickers));

    for (const t of uniqueTickers) {
        // Pass the specific token to the fetch functions
        await fetchQuoteFinnhub(t, token); 

        if (!COMPANY_NAMES[t] || (Date.now() - COMPANY_NAMES[t].ts > 7 * 24 * 60 * 60 * 1000)) {
            try {
                const profile = await fetchCompanyProfile(t, token); 
                if (profile && profile.name) setCompanyName(t, profile.name);
            } catch (_) {}
        }
        // Zachowujemy oryginalne opóźnienie 1.2s, aby nie przekroczyć limitu 60/min dla JEDNEGO klucza
        await new Promise(resolve => setTimeout(resolve, delayMs)); 
    }
}

function startPollingQuotes(){
  if(__pollerStarted){ return; } __pollerStarted = true;
  let secs = Number(DB.settings.pricePollSeconds)||30;
  if(secs < 10) secs = 10;
  if(quoteTimer) clearInterval(quoteTimer);

  const doPoll = async ()=>{
    if (isPollingQuotes) return;
    isPollingQuotes = true;
    try {
        // 1. Podziel tickery na dwie grupy
        const portfolioTickers = Array.from(new Set(
            DB.portfolios.flatMap(pf => Object.keys(pf.holdings || {}))
        ));
        const wishlistTickers = Array.from(new Set(
            (DB.watchlist || []).map(w => (w.ticker || "").toUpperCase())
        ));

        // 2. Pobierz oba klucze
        let tokenPortfolio = DB.settings.finnhubToken || "";
        let tokenWishlist = DB.settings.finnhubTokenWishlist || "";

        // Oryginalne opóźnienie 1.2s (1200ms) z Twojego kodu
        const delay = 1200; 

        // 2b. Jeśli użytkownik nie podał żadnego klucza, użyj wbudowanego tokenu demo (jedna wspólna pętla)
        const hasUserToken = !!(tokenPortfolio || tokenWishlist);
        if (!hasUserToken) {
            const demoToken = FINNHUB_DEMO_TOKEN;
            console.log("Finnhub: używam wbudowanego demo tokenu dla nowych użytkowników (1 sekwencyjna pętla)");
            const allTickers = Array.from(new Set([...portfolioTickers, ...wishlistTickers]));
            await runSequentialFetches(allTickers, demoToken, delay);
        } else if (tokenWishlist && tokenWishlist !== tokenPortfolio) {
            // --- TRYB RÓWNOLEGŁY ---
            // Mamy dwa różne klucze. Uruchamiamy dwie pętle fetch w tym samym czasie.
            console.log("Finnhub: Uruchamiam 2 równoległe pętle odświeżania (Portfel + Wishlista)");
            const portfolioTask = runSequentialFetches(portfolioTickers, tokenPortfolio, delay);
            const wishlistTask = runSequentialFetches(wishlistTickers, tokenWishlist, delay);

            // Czekamy na zakończenie obu
            await Promise.all([portfolioTask, wishlistTask]);

        } else {
            // --- TRYB SEKWENCYJNY ---
            // Mamy tylko jeden klucz (lub ten sam w obu polach).
            // Używamy jednego klucza dla wszystkich tickerów w jednej pętli.
            console.log("Finnhub: Uruchamiam 1 sekwencyjną pętlę odświeżania (Wspólny klucz)");
            const tokenToUse = tokenPortfolio || tokenWishlist; // Użyj któregokolwiek, który istnieje

            // Łączymy wszystkie tickery w jedną listę
            const allTickers = Array.from(new Set([...portfolioTickers, ...wishlistTickers]));

            await runSequentialFetches(allTickers, tokenToUse, delay);
        }

        // 4. Wszystkie pobrania zakończone, renderuj (logika jak wcześniej)
        window.__lastApiRefreshAt = Date.now(); 
        try{ if(window.setApiTime) window.setApiTime(window.__lastApiRefreshAt); }catch(_){}
        try { renderMain(); } catch(e) {}
        try { renderWishlist(); } catch(e) {}
        try { updateSidebarBlinkStates(); } catch(e) {}
        try { updateWishlistBlinkState(); } catch(e) {}
        try { checkAndPlayPortfolioAlerts(); checkAndPlayWishlistAlert(); } catch(e) {}

    } finally {
      isPollingQuotes = false;
    }
  };

  doPoll(); // Uruchom natychmiast
  quoteTimer = setInterval(doPoll, secs*1000); // I ustaw interwał
}

  
function __gt_updateActiveTargetLotForTicker(book){
  try{
    if(!book || !Array.isArray(book.lots)) return;
    let activeIndex = -1;
    for(let i = book.lots.length - 1; i >= 0; i--){
      const lot = book.lots[i];
      if(!lot) continue;
      const q = Number(lot.qty)||0;
      if(q > 1e-9){
        activeIndex = i;
        break;
      }
    }
    for(let i = 0; i < book.lots.length; i++){
      const lot = book.lots[i];
      if(!lot) continue;
      lot.autoMutedForTargets = (activeIndex !== -1 && i !== activeIndex);
    }
  }catch(_){}
}

function computeTargetPrice(lot){
    // Sprzedaż (take-profit)
    if(lot?.targetPrice && Number(lot.targetPrice)>0) return Number(lot.targetPrice);
    if(lot?.targetPct && Number(lot.targetPct)!=0){
      return Number(lot.unitCost) * (1 + Number(lot.targetPct)/100);
    }
    return null;
  }

  function computeBuyTargetPrice(lot){
    if(lot?.buyTargetPrice && Number(lot.buyTargetPrice)>0) return Number(lot.buyTargetPrice);
    if(lot?.buyTargetPct && Number(lot.buyTargetPct)!=0){
      return Number(lot.unitCost) * (1 - Number(lot.buyTargetPct)/100);
    }
    return null;
  }

function targetStatus(lot){ if(lot && (lot.muted || lot.autoMutedForTargets)) return {state:'none'}; 
  const price = getQuote(lot._ticker||"");
  const sellT = computeTargetPrice(lot);
  const buyT  = computeBuyTargetPrice(lot);
  if(price==null) return {state:"none"};
  const tol = (Number(DB.settings.approachTolerancePct)||1)/100; // np. 1%

  const cand = [];

  if(sellT!=null){
    if(price >= sellT) cand.push({state:"hit", kind:"sell", price, target:sellT});
    else if(price >= sellT*(1 - tol)) cand.push({state:"near", kind:"sell", price, target:sellT});
    else cand.push({state:"far", kind:"sell", price, target:sellT});
  }

  if(buyT!=null){
    if(price <= buyT) cand.push({state:"hit", kind:"buy", price, target:buyT});
    else if(price <= buyT*(1 + tol)) cand.push({state:"near", kind:"buy", price, target:buyT});
    else cand.push({state:"far", kind:"buy", price, target:buyT});
  }

  if(cand.length===0) return {state:"none"};

  const prio = { "hit":0, "near":1, "far":2 };
  cand.sort((a,b)=>{
    if(prio[a.state]!==prio[b.state]) return prio[a.state]-prio[b.state];
    const da = Math.abs((price - a.target)/a.target);
    const db = Math.abs((price - b.target)/b.target);
    return da - db;
  });
  return cand[0];
}

  // Compute portfolio-level alert state based on current quotes and lot targets
  function portfolioTargetState(pf){
  // returns {state: "hit"|"near"|"none", kind: "sell"|"buy"|null}
  let hitSell=false, hitBuy=false, nearSell=false, nearBuy=false;
  const tol = (Number(DB.settings.approachTolerancePct)||1)/100;
  for(const [ticker, book] of Object.entries(pf.holdings||{})){
    const lots = book?.lots || [];
    const price = getQuote(ticker);
    if(price==null) continue;
    for(const l of lots){
      if(l && l.autoMutedForTargets) continue;
      const sellT = computeTargetPrice(l);
      const buyT  = computeBuyTargetPrice(l);
      if(sellT!=null){
        if (price >= sellT && !(l && l.muted)) { hitSell = true; break; }
        if(price >= sellT*(1 - tol) && !(l && l.muted)) nearSell = true;
      }
      if(buyT!=null){
        if (price <= buyT && !(l && l.muted)) { hitBuy = true; break; }
        if(price <= buyT*(1 + tol) && !(l && l.muted)) nearBuy = true;
      }
    }
    if(hitSell || hitBuy) break;
  }
  if(hitSell) return {state:"hit",  kind:"sell"};
  if(hitBuy)  return {state:"hit",  kind:"buy"};
  if(nearSell) return {state:"near", kind:"sell"};
  if(nearBuy)  return {state:"near", kind:"buy"};
  return {state:"none", kind:null};
}


function updateSidebarBlinkStates(){
  // Clear previous blinking classes on all sidebar items
  document.querySelectorAll('.portfolio-item').forEach(el=>{
    el.classList.remove('hit-target','near-target','hit-target-sell','near-target-sell','hit-target-buy','near-target-buy');
  });
  // For each portfolio, add blink only if there's at least one NON-ACKED ticker with hit/near
  for(const pf of ((typeof ST!=='undefined' && ST.DB && Array.isArray(ST.DB.portfolios)) ? ST.DB.portfolios : ((typeof DB!=='undefined' && Array.isArray(DB.portfolios)) ? DB.portfolios : []))){
    const el = document.querySelector(`.portfolio-item[data-pf-id="${pf.id}"]`);
    if(!el) continue;
    let pfState = null;
    try{
      for(const [ticker, book] of Object.entries(pf.holdings||{})){
        const lots = book.lots||[];
        let rank=-1, state='none', kind=null;
        for(const l of lots){
          l._ticker = ticker;
          const st = targetStatus(l);
          const r = st.state==="hit" ? (st.kind==="sell"?3:2) : (st.state==="near" ? (st.kind==="sell"?1:0) : -1);
          if(r>rank){ rank=r; state=st.state; kind=st.kind; }
        }
        if(rank>=0 && (state==='hit' || state==='near') && kind && !isAlertAcked(ticker, kind, state)){
          pfState = {state, kind};
          break;
        }
      }
    }catch(_){}
    if(pfState){
      if(pfState.state === "hit") el.classList.add(pfState.kind==="sell"?'hit-target-sell':'hit-target-buy');
      else if(pfState.state === "near") el.classList.add(pfState.kind==="sell"?'near-target-sell':'near-target-buy');
    }
  }
}




  
  // === Sound Alerts Engine ===
(function(){
  let __audio = { ctx: null, unlocked: false };
  let __lastPortfolioSig = 'none';
  let __lastWishlistSig = 'none';
  let __lastPortfolioBeep = 0;
  let __lastWishlistBeep = 0;
  function __repeatMs(){ return Math.max(5000, Number(DB?.settings?.soundRepeatSeconds ?? 60) * 1000); }

  function __getSoundVolumePct(){
    try { return Math.max(0, Math.min(100, Number(DB?.settings?.soundVolume ?? 40))); }
    catch(_) { return 40; }
  }
  function __gainFromVol(mult){ const base = (__getSoundVolumePct()/100); return Math.max(0.0005, Math.min(1.0, base * 0.20 * (mult||1))); }

  function ensureAudio(){
    try{
      if(!__audio.ctx){
        const AC = window.AudioContext || window.webkitAudioContext;
        if(!AC) return null;
        __audio.ctx = new AC();
      }
      return __audio.ctx;
    }catch(e){ return null; }
  }

  function unlockAudio(){
    const ctx = ensureAudio();
    if(!ctx) return;
    if(ctx.state === 'suspended'){
      ctx.resume().catch(()=>{}).then(()=>{ __audio.unlocked = true; });
    }else{
      __audio.unlocked = true;
    }
    window.removeEventListener('pointerdown', unlockAudio);
    window.removeEventListener('keydown', unlockAudio);
    window.removeEventListener('click', unlockAudio);
  }
  window.addEventListener('pointerdown', unlockAudio, { once:false, capture:true });
  window.addEventListener('keydown', unlockAudio, { once:false, capture:true });
  window.addEventListener('click', unlockAudio, { once:false, capture:true });


// === Web Audio unlock helper to comply with Chrome autoplay policy ===
(function(){
  try{
    if(!window.__AUDIO){
      window.__AUDIO = { ctx: null, unlocked: false, queue: [] };
    }
    function __resumeAudio(){
      try{
        const A = window.__AUDIO;
        if(!A.ctx){
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if(!Ctx) return;
          A.ctx = new Ctx();
        }
        A.ctx.resume().then(function(){
          A.unlocked = (A.ctx && A.ctx.state === 'running');
          if(A.unlocked){
            ['pointerdown','touchstart','click','keydown'].forEach(function(ev){
              document.removeEventListener(ev, __resumeAudio, { once: true });
            });
            // flush pending beeps
            var q = A.queue.splice(0);
            q.forEach(function(fn){ try{ fn(); }catch(e){} });
            if(typeof console!=='undefined' && console.debug){
              console.debug('[audio] unlocked + queue flushed');
            }
          }
        }).catch(function(_){});
      }catch(_){}
    }
    window.ensureAudioUnlocked = function(){
      try{
        const A = window.__AUDIO;
        if(A.unlocked) return true;
        if(!A.ctx){
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if(!Ctx) return false;
          A.ctx = new Ctx();
        }
        ['pointerdown','touchstart','click','keydown'].forEach(function(ev){
          document.addEventListener(ev, __resumeAudio, { once: true, passive: true });
        });
        if(typeof console!=='undefined' && console.debug){
          console.debug('[audio] waiting for user gesture to unlock...');
        }
        return false;
      }catch(_){ return false; }
    };
  }catch(_){}
})();
// === end unlock helper ===


  
function playBeep(freq, durationMs, gainVal){
  try{
    var f = Number(freq)||1000;
    var ms = Number(durationMs)||200;
    var g = Number(gainVal); 
    if(!isFinite(g) || g<=0) g = 1.0;
    var ok = (typeof ensureAudioUnlocked==='function') ? ensureAudioUnlocked() : true;

    var doPlay = function(){
      try{
        var A = window.__AUDIO || (window.__AUDIO = { ctx:null, unlocked:false, queue:[] });
        var Ctx = window.AudioContext || window.webkitAudioContext;
        if(!A.ctx) A.ctx = new Ctx();
        // Ensure context is running
        if(A.ctx.state !== 'running'){
          // Best effort resume
          if (A.ctx.resume) A.ctx.resume().catch(function(){ });
        }
        var ctx = A.ctx;
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f;

        // simple anti-click envelope
        var t = ctx.currentTime;
        var dur = ms/1000;
        gain.gain.setValueAtTime(0.0001, t);
        gain.gain.exponentialRampToValueAtTime(Math.max(0.0002, Math.min(g, 2.0)), t + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + dur);

        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(t);
        osc.stop(t + dur);
      }catch(_){}
    };

    if((window.__AUDIO && window.__AUDIO.unlocked) || ok){
      doPlay();
    }else{
      // queue until unlock via first click/touch/keydown
      try{
        var A = window.__AUDIO || (window.__AUDIO = { ctx:null, unlocked:false, queue:[] });
        // Keep queue small
        if (A.queue.length < 5) A.queue.push(doPlay);
      }catch(_){}
    }
  }catch(_){}
}


  function portfolioGlobalSignal(){
    let anyHit=false, anyNear=false;
    for(const pf of (DB.portfolios||[])){
      const sig = (typeof portfolioTargetState==='function') ? portfolioTargetState(pf) : {state:'none'};
      if(sig.state==='hit'){ anyHit=true; break; }
      if(sig.state==='near'){ anyNear=true; }
    }
    return anyHit ? 'hit' : (anyNear ? 'near' : 'none');
  }

  function checkAndPlayPortfolioAlerts(){
    const s = portfolioGlobalSignal();
    const nowMs = Date.now();
    if(s==='hit' && DB?.settings?.soundHitTarget !== false){
      if(__lastPortfolioSig!=='hit' || (nowMs - __lastPortfolioBeep) >= __repeatMs()){
        playBeep(1100, 260, 1.3);  try{ if(__shouldIncrementBadge('portfolio_global', 'hit')){ const k='alerts_unread_count'; const n=Number(localStorage.getItem(k)||0)||0; localStorage.setItem(k, String(Math.min(n+1,999))); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); } }catch(_){} __lastPortfolioBeep = nowMs;
      }
    }else if(s==='near' && DB?.settings?.soundNearTarget !== false){
      if(__lastPortfolioSig!=='near' || (nowMs - __lastPortfolioBeep) >= __repeatMs()){
        playBeep(650, 220, 1.0);  try{ if(__shouldIncrementBadge('portfolio_global', 'near')){ const k='alerts_unread_count'; const n=Number(localStorage.getItem(k)||0)||0; localStorage.setItem(k, String(Math.min(n+1,999))); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); } }catch(_){} __lastPortfolioBeep = nowMs;
      }
    }
     __lastPortfolioSig = s;
  }

  function checkAndPlayWishlistAlert(){
    if(typeof wishlistSignal!=='function') return;
    const s = wishlistSignal(); // 'hit' | 'near' | 'none'
    const nowMs = Date.now();
    if(s==='hit' && DB?.settings?.soundHitTarget !== false){
      if(__lastWishlistSig!=='hit' || (nowMs - __lastWishlistBeep) >= __repeatMs()){
        playBeep(1000, 240, 1.3);  try{ if(__shouldIncrementBadge('wishlist_global', 'hit')){ const k='alerts_unread_count'; const n=Number(localStorage.getItem(k)||0)||0; localStorage.setItem(k, String(Math.min(n+1,999))); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); } }catch(_){} __lastWishlistBeep = nowMs;
      }
    }else if(s==='near' && DB?.settings?.soundNearTarget !== false){
      if(__lastWishlistSig!=='near' || (nowMs - __lastWishlistBeep) >= __repeatMs()){
        playBeep(600, 200, 1.0);  try{ if(__shouldIncrementBadge('wishlist_global', 'near')){ const k='alerts_unread_count'; const n=Number(localStorage.getItem(k)||0)||0; localStorage.setItem(k, String(Math.min(n+1,999))); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); } }catch(_){} __lastWishlistBeep = nowMs;
      }
    }
    __lastWishlistSig = s;
  }

  try{
    window.checkAndPlayPortfolioAlerts = checkAndPlayPortfolioAlerts;
    window.checkAndPlayWishlistAlert = checkAndPlayWishlistAlert;
    window.__testBeep = (f=800,d=250,m=1.0)=>{ try{ playBeep(f,d,m); }catch(_){ } };
  }catch(_){}
})();;

  
/* === Acknowledged Alerts (suppress blinking for read ones) === */
window.__ackedAlerts = window.__ackedAlerts || {};
function __ackKey(ticker, kind, state){ try{ return [String(ticker||'').toUpperCase(), String(kind||''), String(state||'')].join('|'); }catch(_){ return String(ticker||''); } }
function isAlertAcked(ticker, kind, state){ try{ return !!window.__ackedAlerts[__ackKey(ticker,kind,state)]; }catch(_){ return false; } }
function ackAlert(ticker, kind, state){ try{ window.__ackedAlerts[__ackKey(ticker,kind,state)] = Date.now(); }catch(_){} }

function ackCurrentAlerts(){
  try{
    // Portfolios - per ticker best state
    const tol = (Number(DB?.settings?.approachTolerancePct)||1)/100;
    for(const pf of (DB?.portfolios||[])){
      for(const [ticker, book] of Object.entries(pf.holdings||{})){
        const lots = book.lots||[];
        const price = getQuote(ticker);
        if(price==null) continue;
        let rank = -1, state='none', kind=null;
        for(const l of lots){
          l._ticker = ticker;
          const st = targetStatus(l);
          const r = st.state==="hit" ? (st.kind==="sell"?3:2) : (st.state==="near" ? (st.kind==="sell"?1:0) : -1);
          if(r > rank){ rank=r; state = st.state; kind = st.kind; }
        }
        if(rank>=0 && (state==='hit' || state==='near') && kind) ackAlert(ticker, kind, state);
      }
    }
    // Wishlist - active target only
    const tol2 = (Number(DB?.settings?.approachTolerancePct)||1)/100;
    (DB?.watchlist||[]).forEach(w=>{
      const t = (w.ticker||'').toUpperCase();
      const p = getQuote(t);
      const targets = Array.isArray(w.targets) ? w.targets.map(x=>Number(x)||0).filter(x=>x>0) : [];
      const ai = Math.min(Math.max(Number(w.activeIndex)||0, 0), Math.max(targets.length-1,0));
      const d = targets.length ? Number(targets[ai])||0 : (Number(w.price)||0);
      if(!t || !(d>0) || p==null) return;
      if(p <= d) ackAlert(t, 'buy', 'hit');
      else if(p <= d*(1+tol2)) ackAlert(t, 'buy', 'near');
    });
  }catch(_){}
}
/* === Wishlist (Lista życzeń) === */
  
  function ensureWatchlistStructure(){
    try{
      DB.watchlist = DB.watchlist || [];
      for(const w of DB.watchlist){
        if(!Array.isArray(w.targets)){
          const base = Number(w.price)||0;
          w.targets = base>0 ? [base] : [];
          try{ delete w.price; }catch(_){}
        }
        if(typeof w.activeIndex!=='number') w.activeIndex = 0;
        if(typeof w.name!=='string') w.name = w.name||'';
      }
    }catch(_){}
  }
function ensureWatchlist(){ DB.watchlist = DB.watchlist || []; ensureWatchlistStructure(); }

  
function setActiveView(v){
  const main = document.querySelector('.main') || document.querySelector('main');
  if(!main) return;
  const panels = main.querySelectorAll(':scope > section');
  panels.forEach(sec=>{
    if(v==='wishlist') sec.style.display = (sec.id==='wishlistPanel') ? '' : 'none';
    else if(v==='alerts') sec.style.display = (sec.id==='alertsPanel') ? '' : 'none';
    else sec.style.display = (sec.id==='wishlistPanel' || sec.id==='alertsPanel') ? 'none' : '';
  });
  const btnW = document.getElementById('wishlistTabBtn');
  if(btnW){ btnW.classList.toggle('secondary', v!=='wishlist'); }
  const btnA = document.getElementById('alertsTabBtn');
  if(btnA){ btnA.classList.toggle('secondary', v!=='alerts'); }
}


  function wishlistSignal(){
    ensureWatchlist();
    const tol = (Number(DB.settings.approachTolerancePct)||1)/100;
    let hit=false, near=false;
    for(const w of DB.watchlist){
      const t = (w.ticker||'').toUpperCase();
      const p = getQuote(t);
      const targets = Array.isArray(w.targets) ? w.targets.map(x=>Number(x)||0).filter(x=>x>0) : [];
      const ai = Math.min(Math.max(Number(w.activeIndex)||0, 0), Math.max(targets.length-1,0));
      const d = (targets.length ? Number(targets[ai])||0 : (Number(w.price)||0));
      if(!t || !(d>0) || p==null) continue;
      if(p <= d){ hit = true; break; }
      if(p <= d*(1+tol)) near = true;
    }
    return hit ? 'hit' : (near ? 'near' : 'none');
  }

  function updateWishlistBlinkState(){
    try{
      const btn = document.getElementById('wishlistTabBtn');
      if(!btn) return;
      btn.classList.remove('hit-target-buy','near-target-buy');
      const sig = wishlistSignal();
      if(sig==='hit') btn.classList.add('hit-target-buy');
      else if(sig==='near') btn.classList.add('near-target-buy');
    }catch(e){}
  }

  function addWatchItem(ticker, price){
    ensureWatchlist();
    ticker = (ticker||'').toUpperCase().trim();
    const p = Number(price)||0;
    if(!ticker || !(p>0)){ alert('Podaj poprawny ticker i cenę.'); return; }
    const ex = DB.watchlist.find(w=> w.ticker===ticker);
    if(ex){ ex.price = p; ex.updatedAt = new Date().toISOString(); }
    else { DB.watchlist.push({ id:id(), ticker, price:p, createdAt:new Date().toISOString(), updatedAt:new Date().toISOString() }); }
    save(); renderWishlist(); updateWishlistBlinkState();
  }

  function removeWatchItem(wid){
    ensureWatchlist();
    const i = DB.watchlist.findIndex(w=> w.id===wid);
    if(i>=0){ DB.watchlist.splice(i,1); save(); renderWishlist(); updateWishlistBlinkState(); }
  }

  async function editWatchItem(wid){
    ensureWatchlist();
    const item = DB.watchlist.find(w=> w.id===wid);
    if(!item) return;
    const t = (item.ticker||'').toUpperCase();
    // Build default targets string from existing targets or fallback to old price
    const defaultTargets = (Array.isArray(item.targets) && item.targets.length) 
      ? item.targets.join(', ')
      : ((item.price!=null && item.price!=='') ? (item.price+'') : '');
    const data = await openModal({
      title: `Edytuj cele kupna — ${__esc(t)}`,
      innerHTML: `<form class="grid">
        <div class="col-12"><label>Ceny docelowe (kupno) — wpisz po przecinku, w kolejności realizacji</label>
          <input name="targets" type="text" placeholder="np. 350, 300, 250" value="${__esc(defaultTargets)}" />
          <div class="muted small">Aktywna będzie pierwsza; po zakupie przełączy się na kolejną.</div>
        </div>
      </form>`,
      okText:"Zapisz"
    });
    if(!data) return;
    const raw = (data.targets||'')+'';
    const targets = raw.split(/[,;\s]+/).map(x=>Number(x)).filter(x=>x>0);
    if(!targets.length){ alert('Podaj co najmniej jedną poprawną cenę docelową.'); return; }
    item.targets = targets;
    if(typeof item.activeIndex!=='number' || item.activeIndex>=targets.length) item.activeIndex = 0;
    try{ delete item.price; }catch(_){}
    item.updatedAt = new Date().toISOString();
    save(); renderWishlist(); updateWishlistBlinkState();
  }

  function renderWishlist(){
    ensureWatchlist();
    const wrap = document.getElementById('wlTableWrap');
    if(!wrap) return;
    const tol = (Number(DB.settings.approachTolerancePct)||1)/100;
    const rows = (DB.watchlist||[]).map(w=>{
      const t = (w.ticker||'').toUpperCase();
      const price = getQuote(t);
      const targets = Array.isArray(w.targets) ? w.targets.map(x=>Number(x)||0).filter(x=>x>0) : ((Number(w.price)||0)?[Number(w.price)]:[]);
      const ai = Math.min(Math.max(Number(w.activeIndex)||0, 0), Math.max(targets.length-1,0));
      const desired = targets.length ? Number(targets[ai])||0 : 0;
      let dist = null, status='—', cls='';
      if(price!=null && desired>0){
        dist = (price - desired)/desired;
        if(price <= desired){ status = '🎯 KUP'; cls='hit-target-buy'; }
        else if(price <= desired*(1+tol)){ status = '⏳ blisko'; cls='near-target-buy'; }
      }
      return { ...w, t, price, desired, dist, status, cls };
    }).sort((a,b)=>{
      const ad = (a.dist==null) ? 1e9 : Math.abs(a.dist);
      const bd = (b.dist==null) ? 1e9 : Math.abs(b.dist);
      return ad - bd;
    });

    
    // Log wishlist alarms (deduplicated), for rows in 'near' or 'hit' states
    try{
      rows.forEach(r=>{
        const info = (r.cls==='hit-target-buy') ? {state:'hit', kind:'buy'}
                    : (r.cls==='near-target-buy') ? {state:'near', kind:'buy'}
                    : null;
        if(info && r.desired>0 && r.price!=null){
          const key = ['wl', r.id || r.t, info.kind].join('|');
          if(__shouldLogAlarm(key, info.state)){ try{ window.showToast && showToast({ticker:r.t, state:info.state, kind:info.kind}); }catch(_){} try{ window.showToast && showToast({ticker, state:info.state, kind:info.kind}); }catch(_){}
            logAlarmEvent({scope:'wishlist', ticker:r.t, state:info.state, kind:info.kind, price:r.price, target:r.desired});
          }
        }
      });
    }catch(_){}
const body = rows.map(r=>{
      const priceTxt = (r.price!=null) ? __fmtNum(r.price) : '—';
      const distTxt = (r.dist==null) ? '—' : ( (r.dist*100).toFixed(2) + '%' );
      return `<tr class="${r.cls}">
        <td class="ticker">${__esc(r.t)}${(()=>{ const cn=getCompanyName(r.t); return cn?`<div class="muted small" style="font-weight:400;margin-top:2px">${__esc(cn)}</div>`:''; })()}</td>
        <td>${priceTxt}</td>
        <td>${(()=>{ const ch=getQuoteChangePct(r.t); return (ch!=null)? ("<span class='pct-badge "+(ch>=0?"pct-pos ok-text":"pct-neg danger-text")+"'>"+fmtPct(ch)+"</span>") : "—"; })()}</td>
        <td>${__fmtNum(r.desired)}</td>
        <td>${(()=>{ const _c = r.cls||''; const _d=(typeof r.dist==='number')?r.dist:null; let _cls=''; if(_c.includes('hit-target-buy')){ _cls='ok-text'; } else if(_c.includes('near-target-buy')){ _cls = (_d!=null && _d<= (tol/2)) ? 'warn-strong-text' : 'warn-text'; } return `<span class="${_cls}">${distTxt}</span>`; })()}</td>
        <td>${r.status}</td>
        <td class="row" style="gap:6px">
          <button class="btn ok wl-buy" data-id="${r.id}">Kup</button>
          <button class="btn ghost wl-edit" data-id="${r.id}">Edytuj</button>
          <button class="btn danger wl-del" data-id="${r.id}">Usuń</button> <button class="btn ghost tv-link" data-ticker="${r.t}" title="TradingView">TV</button>
          <button class="btn ghost wl-info" data-ticker="${r.t}">ℹ️</button>
        </td>
      </tr>`;
    }).join('') || `<tr><td colspan="8" class="center muted">Brak pozycji. Dodaj pierwszy cel kupna powyżej.</td></tr>`;

    const html = `<div class="table-wrap">
      <table>
        <thead><tr>
          <th>Ticker</th><th>Kurs (live)</th><th>Δ dzienny</th><th>Cel kupna</th><th>Odległość</th><th>Status</th><th>Akcje</th>
        </tr></thead>
        <tbody>${body}</tbody>
      </table>
    </div>`;

    wrap.innerHTML = html;

    // bind row actions
    
    wrap.querySelectorAll('.wl-info').forEach(btn=>{ btn.addEventListener('click', e=>{ const t=e.currentTarget.getAttribute('data-ticker'); if(t) openCompanyInfoModal(t); }); });
wrap.querySelectorAll('.wl-del').forEach(btn=>{
      btn.addEventListener('click', e=>{
        const id = e.currentTarget.getAttribute('data-id'); removeWatchItem(id);
      });
    });
    wrap.querySelectorAll('.wl-edit').forEach(btn=>{
      btn.addEventListener('click', e=>{
        const id = e.currentTarget.getAttribute('data-id'); editWatchItem(id);
      });
    });
    wrap.querySelectorAll('.wl-buy').forEach(btn=>{
      btn.addEventListener('click', async e=>{
        const id = e.currentTarget.getAttribute('data-id');
        const item = (DB.watchlist||[]).find(w=> w.id===id);
        if(!item) return;
        const t = (item.ticker||'').toUpperCase();
        try{ await fetchQuoteFinnhub(t); }catch(e){}
        const lastPrice = getQuote(t);
        const opts = DB.portfolios.map(p=>`<option value="${p.id}">${__esc(p.name)} (${p.currency})</option>`).join('');
        const data = await openModal({
          title: `Kup ${__esc(t)} (z listy życzeń)`,
          innerHTML: `<form class="grid">
            <div class="col-6"><label>Portfel</label><select name="pfId">${opts}</select></div>
            <div class="col-6"><label>Ilość</label><input name="qty" type="number" step="0.0001" min="0" required /></div>
            <div class="col-6"><label>Cena / szt.</label><input name="price" type="number" step="0.0001" min="0" value="${lastPrice!=null?lastPrice:''}" required oninput="__wlSyncTargets(this.form)" /></div>
            <div class="col-3"><label>Opłaty</label><input name="fees" type="number" step="0.01" min="0" value="0" /></div>
            <div class="col-3"><label>Data</label><input name="date" type="date" value="${today()}" /></div>
            <div class="col-6"><label>Cel SPRZEDAŻY %</label><input name="targetPct" type="number" step="0.01" placeholder="np. 5 = +5%" oninput="__wlSyncTargets(this.form)" /></div><div class="col-6"><label>Cel SPRZEDAŻY (cena)</label><input name="targetPrice" type="number" step="0.0001" min="0" placeholder="np. 350.00" oninput="__wlSyncTargets(this.form)" /></div>
            <div class="col-6"><label>Kolejne kupno %</label><input name="buyTargetPct" type="number" step="0.01" placeholder="np. 5 = kup przy -5%" oninput="__wlSyncTargets(this.form)" /></div><div class="col-6"><label>Kolejne kupno (cena)</label><input name="buyTargetPrice" type="number" step="0.0001" min="0" placeholder="np. 280.00" oninput="__wlSyncTargets(this.form)" /></div>
            <div class="col-12"><label>Usuń z listy po zakupie</label><input type="checkbox" name="remove" /></div>
          </form>`,
          okText:"Zaksięguj zakup"
        });
        if(!data) return;
        const pfId = data.pfId || currentPfId;
        const payload = { ticker:t, date:data.date, qty:data.qty, price:data.price, fees:data.fees, targetPct: data.targetPct||"", targetPrice: data.targetPrice||"", buyTargetPct: data.buyTargetPct||"", buyTargetPrice: data.buyTargetPrice||"" };
        const ts = Number(data.targetSell)||0;
        const tbn = Number(data.targetBuyNext)||0;
        if(ts>0) payload.targetSell = ts;
        if(tbn>0) payload.targetBuyNext = tbn;
        await buy(pfId, payload);
        if(data.remove){ removeWatchItem(id); } else { renderWishlist(); }
      });
    });
  }

  // Search helper for wishlist
  async function wlSearchSymbols(q){
    const {result, error} = await searchSymbolFinnhub(q||'*');
    if(error){ alert('Błąd wyszukiwania: '+error); return; }
    const box = document.getElementById('wlSearchResults');
    if(!box) return;
    const list = (result||[]).slice(0,20).map(r=>`
      <div class="row" data-sym="${r.symbol}" style="padding:4px 6px; border-bottom:1px solid #1f2937; cursor:pointer">
        <div class="ticker" style="min-width:120px">${r.symbol}</div>
        <div class="small" style="opacity:.9">${r.description||''}</div>
      </div>`).join('') || '<div class="small muted">Brak wyników.</div>';
    box.innerHTML = list;
    box.querySelectorAll('[data-sym]').forEach(el=>{
      el.addEventListener('click', async (e)=>{
        const sym = e.currentTarget.getAttribute('data-sym');
        const tEl = document.getElementById('wlTicker');
        if(tEl) tEl.value = sym;
        try{ await fetchQuoteFinnhub(sym); }catch(e){}
        // Fetch and cache company name
try{ const profile = await fetchCompanyProfile(sym); if(profile && profile.name) setCompanyName(sym, profile.name);}catch(_){}
renderWishlist(); updateWishlistBlinkState();
      });
    });
  }

  
  // Live sync between % and absolute targets in wishlist modal
  function __wlSyncTargets(form){
    if(!form) return;
    const priceEl = form.querySelector('input[name="price"]');
    const tgtPctEl = form.querySelector('input[name="targetPct"]');
    const tgtPriceEl = form.querySelector('input[name="targetPrice"]');
    const buyPctEl = form.querySelector('input[name="buyTargetPct"]');
    const buyPriceEl = form.querySelector('input[name="buyTargetPrice"]');
    const p = Number(priceEl && priceEl.value) || 0;
    // SELL target
    if(p>0){
      if(document.activeElement===tgtPctEl || (tgtPctEl && tgtPctEl._lastChanged)){
        const pct = Number(tgtPctEl.value);
        if(!Number.isNaN(pct)) { const v = p * (1 + pct/100); if(tgtPriceEl) tgtPriceEl.value = v ? v.toFixed(4) : ""; }
      }else if(tgtPriceEl){
        const abs = Number(tgtPriceEl.value);
        if(abs>0){ const pct = ((abs/p)-1)*100; if(tgtPctEl) tgtPctEl.value = pct.toFixed(2); }
      }
      // BUY-NEXT target: interpret % literally (np. 5 => -5% od ceny zakupu)
      if(document.activeElement===buyPctEl || (buyPctEl && buyPctEl._lastChanged)){
        const pct = Number(buyPctEl.value);
        if(!Number.isNaN(pct)) { const v = p * (1 + pct/100); if(buyPriceEl) buyPriceEl.value = v ? v.toFixed(4) : ""; }
      }else if(buyPriceEl){
        const abs2 = Number(buyPriceEl.value);
        if(abs2>0){ const pct2 = ((abs2/p)-1)*100; if(buyPctEl) buyPctEl.value = pct2.toFixed(2); }
      }
    }
    // mark last-changed inputs (to avoid ping-pong)
    [tgtPctEl, buyPctEl].forEach(el=>{
      if(el){
        el.addEventListener('input', ()=>{ el._lastChanged = true; });
        el.addEventListener('blur', ()=>{ el._lastChanged = false; });
      }
    });
  }

  
  // Responsive tables: wrap any table without wrapper to enable horizontal scroll on mobile
  function ensureResponsiveTables(){
    document.querySelectorAll('table').forEach(tbl=>{
      if(!tbl.closest('.table-wrap')){
        const wrap = document.createElement('div');
        wrap.className = 'table-wrap';
        tbl.parentNode.insertBefore(wrap, tbl);
        wrap.appendChild(tbl);
      }
    });
  }

  // Event wiring
  $("#addPortfolioBtn").addEventListener('click', async()=>{
    await openModal({
      title:"Nowy portfel",
      innerHTML:`<form class="row">
        <div style="flex:1">
          <label>Nazwa portfela</label>
          <input name="name" placeholder="np. Dywidendy 2026" required />
        </div>
        <div style="width:180px">
          <label>Waluta</label>
          <input name="currency" value="${ensureCurrency()}" placeholder="PLN" />
        </div>
      </form>`
    }).then(data=>{
      if(!data) return;
      addPortfolio();
      renamePortfolio(currentPfId, data.name || "Nowy portfel");
      const pf = getPf(currentPfId);
      if(pf){ pf.currency = (data.currency||"PLN").toUpperCase(); save(); render(); }
    });
  });

  $("#renameBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Zmień nazwę",
      innerHTML:`<form>
        <label>Nazwa</label>
        <input name="name" value="${__esc(pf.name)}" />
      </form>`
    });
    if(data && data.name){ renamePortfolio(currentPfId, data.name); }
  });

  $("#deleteBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return;
    const confirmData = await openModal({
      title:"Usuń portfel",
      okText:"Tak, usuń",
      cancelText:"Jednak nie",
      innerHTML:`<div class="content">
        <p>Czy na pewno chcesz usunąć portfel <b>${__esc(pf.name)}</b>? Operację można cofnąć przez 2 dni (↩️ Cofnij)..</p>
        <p class="small">Saldo: ${__go_fmtCurrency(pf.cash, pf.currency)} • Pozycje: ${Object.keys(pf.holdings).length}</p>
      </div>`
    });
    if(confirmData!==null){ deletePortfolio(currentPfId); }
  });

  $("#settingsBtn").addEventListener('click', async ()=>{
    const s = DB.settings;
    const data = await openModal({
      title:"Ustawienia",
      innerHTML:`<form class="settings-form">
  <style>
    /* Scoped styles for Settings modal */
    .settings-form{ display:flex; flex-direction:column; gap:14px; }
    .settings-sections{ display:grid; grid-template-columns: 1fr; gap:12px; }
    .settings-card{
      border:1px solid #334155; border-radius:12px; padding:12px;
      background: linear-gradient(180deg, rgba(17,24,39,.96), rgba(15,23,42,.96));
    }
    .settings-card h4{ margin:0 0 8px 0; font-size:15px; display:flex; align-items:center; gap:8px; }
    .settings-grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:10px; }
    .s-col-3{ grid-column: span 3; }
    .s-col-4{ grid-column: span 4; }
    .s-col-6{ grid-column: span 6; }
    .s-col-12{ grid-column: span 12; }
    @media (max-width: 720px){
      .settings-grid > *{ grid-column: span 12 !important; }
    }
    .desc{ font-size:12px; opacity:.8; margin-top:6px; }
    .switch{
      display:inline-flex; align-items:center; gap:10px; cursor:pointer; user-select:none;
      padding:8px 10px; border-radius:10px; border:1px solid #334155; background:#0b1222;
    }
    .switch input{ appearance:none; width:36px; height:20px; border-radius:999px; background:#334155; position:relative; outline:none; transition:.2s; }
    .switch input:before{ content:""; position:absolute; width:16px; height:16px; top:2px; left:2px; border-radius:50%; background:#e5e7eb; transition:.2s; }
    .switch input:checked{ background:#10b981; }
    .switch input:checked:before{ transform: translateX(16px); background:#0b1222; }
    .inline{ display:flex; align-items:center; gap:10px; }
    .muted{ color:#94a3b8; }
    .kv{ display:flex; align-items:center; justify-content:space-between; gap:10px; font-size:12px; }
    .kv code{ font-size:12px; opacity:.9; }
    .row{ display:flex; align-items: center; gap:8px; }
    .small{ font-size:12px; color:#94a3b8; }
  
  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

  <div class="settings-sections">

    <!-- OGÓLNE -->
    <div class="settings-card">
      <h4>⚙️ Ogólne</h4>
      <div class="settings-grid">
        <div class="s-col-4">
          <label>Domyślna waluta</label>
          <input name="currencyDefault" value="${s.currencyDefault||'PLN'}" />
          <div class="desc">Używana przy nowych portfelach i formatowaniu wartości.</div>
        </div>
        <div class="s-col-4">
          <label>Stawka podatku (Belki)</label>
          <input name="taxRate" type="number" step="0.01" min="0" max="1" value="${s.taxRate}" />
          <div class="desc">np. 0.19 = 19% (naliczane tylko przy zysku ze sprzedaży).</div>
        </div>
        <div class="s-col-4">
          <label>Saldo ujemne</label>
          <label class="switch">
            <input type="checkbox" name="allowNegativeCash" ${s.allowNegativeCash?'checked':''} />
            <span>Zezwól na saldo ujemne (kredyt/margin)</span>
          </label>
        </div>
      </div>
    </div>

    <!-- API i CENY -->
    <div class="settings-card">
      <h4 class="settings-title-row">
        <span>📡 API i ceny</span>
        <a href="https://finnhub.io/" target="_blank" rel="noopener noreferrer" class="btn ghost">
          Zdobądź darmowy klucz API
        </a>
      </h4>
      <div class="settings-grid">
        <div class="s-col-6">
          <label>Finnhub API Token</label>
          <input name="finnhubToken" value="${s.finnhubToken||''}" />
          
        </div>

<div class="s-col-6">
  <label>Finnhub API Token (Wishlist)</label>
  <input name="finnhubTokenWishlist" value="${s.finnhubTokenWishlist||''}" />
  <div class="desc">Osobny klucz dla Listy Życzeń (przyspiesza odświeżanie).</div>
</div>
        <div class="s-col-3">
          <label>Odświeżanie kursów [s]</label>
          <input name="pricePollSeconds" type="number" min="5" step="1" value="${s.pricePollSeconds||30}" />
          <div class="desc">Częstotliwość pobierania cen.</div>
        </div>
        <div class="s-col-3">
          <label>Tolerancja „zbliża się” [%]</label>
          <input name="approachTolerancePct" type="number" step="0.1" min="0" value="${s.approachTolerancePct||1}" />
          <div class="desc">Ile % od celu uznajemy za „blisko”.</div>
        </div>
      </div>
    </div>

    <!-- ALERTY DŹWIĘKOWE -->
    <div class="settings-card">
      <h4>🛎️ Alerty dźwiękowe</h4>
      <div class="settings-grid">
        <div class="s-col-4">
          <label>Główne</label>
          <label class="switch">
            <input type="checkbox" name="soundAlertsEnabled" ${s.soundAlertsEnabled!==false?'checked':''} />
            <span>Włącz alarmy dźwiękowe</span>
          </label>
        </div>
        <div class="s-col-4">
          <label>„Cel osiągnięty”</label>
          <label class="switch">
            <input type="checkbox" name="soundHitTarget" ${s.soundHitTarget!==false?'checked':''} />
            <span>Odtwarzaj przy trafieniu w cel</span>
          </label>
        </div>
        <div class="s-col-4">
          <label>„Blisko celu”</label>
          <label class="switch">
            <input type="checkbox" name="soundNearTarget" ${s.soundNearTarget!==false?'checked':''} />
            <span>Odtwarzaj przy zbliżeniu</span>
          </label>
        </div>

        <div class="s-col-6">
          <label>Głośność alarmu</label>
          <div class="inline">
            <input name="soundVolume" type="range" min="0" max="150" step="1"
                   value="${(s.soundVolume??60)}"
                   oninput="this.nextElementSibling.value=this.value + '%'" />
            <output class="small">${(s.soundVolume??60)}%</output>
          </div>
        </div>
        <div class="s-col-6">
          <label>Powtarzanie alarmu [s]</label>
          <input name="soundRepeatSeconds" type="number" min="5" step="5" value="${(s.soundRepeatSeconds??60)}" />
          <div class="desc">Co ile sekund ponowić sygnał, gdy stan nadal trwa.</div>
        </div>
      </div>
    </div>

  </div>

    <div class="settings-card">
      <h4>Historia i cofanie</h4>
      <div class="row">
        <button class="btn ghost" id="undoBtn" title="Cofnij ostatnią zmianę (historia 2 dni)">↩️ Cofnij</button>
        <span class="small muted">Ctrl/Cmd+Z — cofnij transakcję • Shift+↩️ / Ctrl/Cmd+Shift+Z — krokowo</span>
      </div>
    </div>
    <div class="settings-card">
      <h4>🧨 Ustawienia konta</h4>
      <div class="settings-grid">
        <div class="s-col-12">
          <label>Nowe hasło</label>
          <input name="newPassword" type="password" minlength="6" autocomplete="new-password" placeholder="min. 6 znaków" />
          <div class="desc">Nowe hasło zostanie zapisane po kliknięciu przycisku "Zapisz" na dole okna.</div>
        </div>
        <div class="s-col-12">
          <label>Powtórz nowe hasło</label>
          <input name="newPasswordConfirm" type="password" minlength="6" autocomplete="new-password" placeholder="wpisz ponownie nowe hasło" />
        </div>
        <div class="s-col-12">
          <div class="banner warn">
            <div>
              <strong>Uwaga!</strong>
              <div class="small">Dezaktywacja usunie Twoje konto i dane z serwera. Operacja jest nieodwracalna.</div>
            </div>
            <button type="button" class="btn warn" onclick="if(window.parent && window.parent.__requestAccountDeletion){ window.parent.__requestAccountDeletion(); }">
              Dezaktywuj konto
            </button>
          </div>
        </div>
      </div>
    </div>

</form>`
    });
    if(data){
      // Zmiana hasła (obsługiwana przez aplikację główną)
      if (data.newPassword || data.newPasswordConfirm) {
        if (!data.newPassword || !data.newPasswordConfirm) {
          alert("Aby zmienić hasło, wypełnij oba pola: nowe hasło i powtórzenie.");
        } else if (data.newPassword !== data.newPasswordConfirm) {
          alert("Nowe hasło i potwierdzenie nie są takie same.");
        } else if (data.newPassword.length < 6) {
          alert("Hasło musi mieć co najmniej 6 znaków.");
        } else if (window.parent && window.parent.__requestPasswordChange) {
          window.parent.__requestPasswordChange(data.newPassword);
        } else {
          alert("Zmiana hasła nie jest dostępna w tej wersji aplikacji.");
        }
      }

      DB.settings.taxRate = Number(data.taxRate)||0.19;
      DB.settings.currencyDefault = (data.currencyDefault||"PLN").toUpperCase();
      DB.settings.allowNegativeCash = !!data.allowNegativeCash;
      DB.settings.finnhubToken = data.finnhubToken||"";
      DB.settings.finnhubTokenWishlist = data.finnhubTokenWishlist||"";
      DB.settings.pricePollSeconds = Number(data.pricePollSeconds)||30;
      DB.settings.approachTolerancePct = Number(data.approachTolerancePct)||1;
      DB.settings.soundAlertsEnabled = !!data.soundAlertsEnabled;
      DB.settings.soundHitTarget = !!data.soundHitTarget;
      DB.settings.soundNearTarget = !!data.soundNearTarget;
      DB.settings.soundVolume = Number(data.soundVolume ?? DB.settings.soundVolume ?? 40);
      DB.settings.soundRepeatSeconds = Number(data.soundRepeatSeconds ?? DB.settings.soundRepeatSeconds ?? 60);
      save(); render();
      startPollingQuotes();
    }
    if(data){
      DB.settings.taxRate = Number(data.taxRate)||0.19;
      DB.settings.currencyDefault = (data.currencyDefault||"PLN").toUpperCase();
      DB.settings.allowNegativeCash = !!data.allowNegativeCash;
      save(); render();
    }
  });

  $("#depositBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Wpłata do portfela",
      innerHTML:`<form class="grid">
        <div class="col-6">
          <label>Kwota (${pf.currency})</label>
          <input name="amount" type="number" step="0.01" min="0" required />
        </div>
        <div class="col-12">
          <label>Notatka (opcjonalnie)</label>
          <input name="note" />
        </div>
      </form>`
    });
    if(data && data.amount){ deposit(currentPfId, data.amount, data.note||""); }
  });

  $("#cashActionsBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Operacje gotówkowe",
      innerHTML:`<form class="grid">
        <div class="col-6">
          <label>Kwota (${pf.currency})</label>
          <input name="amount" type="number" step="0.01" min="0" required />
        </div>
        <div class="col-6">
          <label>Rodzaj</label>
          <select name="kind">
            <option value="deposit">Wpłata</option>
            <option value="withdraw">Wypłata</option>
          </select>
        </div>
        <div class="col-12">
          <label>Notatka</label>
          <input name="note" />
        </div>
      </form>`
    });
    if(!data) return;
    if(data.kind==="deposit") deposit(currentPfId, data.amount, data.note||"");
    else withdraw(currentPfId, data.amount, data.note||"");
  });

  $("#withdrawBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Wypłata z portfela",
      innerHTML:`<form class="grid">
        <div class="col-6">
          <label>Kwota (${pf.currency})</label>
          <input name="amount" type="number" step="0.01" min="0" required />
        </div>
        <div class="col-12">
          <label>Notatka (opcjonalnie)</label>
          <input name="note" />
        </div>
      </form>`
    });
    if(data && data.amount){ withdraw(currentPfId, data.amount, data.note||""); }
  });

  $("#transferBtn").addEventListener('click', async ()=>{
    if(DB.portfolios.length<2){ return alert("Dodaj przynajmniej dwa portfele, aby wykonać przelew."); }
    const opts = DB.portfolios.map(p=>`<option value="${p.id}">${__esc(p.name)} (${p.currency})</option>`).join("");
    const data = await openModal({
      title:"Przelew między portfelami",
      innerHTML:`<form class="grid">
        <div class="col-6">
          <label>Źródło</label>
          <select name="fromId">${opts}</select>
        </div>
        <div class="col-6">
          <label>Cel</label>
          <select name="toId">${opts}</select>
        </div>
        <div class="col-6">
          <label>Kwota</label>
          <input name="amount" type="number" step="0.01" min="0" required />
        </div>
        <div class="col-6">
          <label>Data</label>
          <input name="date" type="date" value="${today()}" />
        </div>
        <div class="col-12">
          <label>Notatka</label>
          <input name="note" placeholder="np. pożyczka z firmy A do B" />
        </div>
      </form>`
    });
    if(!data) return;
    transfer(data.fromId, data.toId, data.amount, data.note||"");
  });

  $("#buyBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); 
    if(!pf) return alert("Najpierw wybierz portfel.");

    // Otwórz modal z formularzem zakupu nowej pozycji
    const prom = openModal({
      title:"Zakup (nowa partia)",
      innerHTML:`<form class="grid">
        <div class="col-12">
          <label>Ticker <span class="small">(Enter pobierze kurs z Finnhub)</span></label>
          <div class="row" style="gap:6px">
            <input name="ticker" id="buyTicker" placeholder="np. TSLA" required />
            <button type="button" class="btn secondary" id="btnFetchPrice">Pobierz cenę</button>
            <button type="button" class="btn ghost" id="btnSearchSymbol">Szukaj symbolu</button>
          </div>
        </div>

        <div class="col-4">
          <label>Ilość</label>
          <input name="qty" type="number" step="0.0001" min="0" required />
        </div>
        <div class="col-4">
          <label>Cena / szt.</label>
          <input name="price" id="buyPrice" type="number" step="0.0001" min="0" required />
        </div>
        <div class="col-4">
          <label>Opłaty</label>
          <input name="fees" type="number" step="0.01" min="0" value="0" />
        </div>
        <div class="col-12">
          <label>Data</label>
          <input name="date" type="date" value="${today()}" />
        </div>

        <!-- DÓŁ: cele zysku (lewa) i cele kupna (prawa) -->
        <div class="col-6">
          <div class="grid">
            <div class="col-12">
              <label>Cel zysku % (opcjonalnie)</label>
              <input name="targetPct" type="number" step="0.01" placeholder="np. 5 = +5%" />
            </div>
            <div class="col-12">
              <label>Cel zysku CENA/szt. (opcjonalnie)</label>
              <input name="targetPrice" type="number" step="0.0001" placeholder="np. 120.00" />
            </div>
          </div>
        </div>
        <div class="col-6">
          <div class="grid">
            <div class="col-12">
              <label>Cel KUPNA % (spadek, opcj.)</label>
              <input name="buyTargetPct" type="number" step="0.01" placeholder="np. 5 = kup przy -5%" />
            </div>
            <div class="col-12">
              <label>Cel KUPNA CENA/szt. (opcj.)</label>
              <input name="buyTargetPrice" type="number" step="0.0001" placeholder="np. 95.00" />
            </div>
          </div>
        </div>

        <div class="col-12 small" id="buyPriceMsg" style="min-height:20px"></div>
        <div class="col-12">
          <label>Notatka</label>
          <input name="note" placeholder="np. zakup wg strategii momentum" />
        </div>
        <div class="col-12 small">Uwaga: kurs z Finnhub może być w walucie notowania instrumentu (bez konwersji).</div>
      </form>`
    });

    // Po wyrenderowaniu modala spinamy logikę pól
    const tEl = $("#buyTicker"), pEl = $("#buyPrice"), msgEl = $("#buyPriceMsg");

    async function uiFetchPrice(){
      if(!msgEl) return;
      msgEl.textContent = "Pobieram cenę z Finnhub…";
      const sym = (tEl?.value||"").trim().toUpperCase();
      if(!sym){ msgEl.textContent = "Podaj symbol (np. TSLA)"; return; }
      const {price, error} = await fetchQuoteFinnhub(sym);
      if(price!=null){ 
        if(pEl) pEl.value = price; 
        msgEl.textContent = "OK: " + price; 
      } else { 
        msgEl.textContent = "Błąd: " + (error||"brak danych"); 
      }
    }

    if(tEl){
      tEl.addEventListener('keydown', async (ev)=>{
        if(ev.key==="Enter"){
          ev.preventDefault();
          await uiFetchPrice();
        }
      });
    }
    $("#btnFetchPrice")?.addEventListener('click', uiFetchPrice);

    $("#btnSearchSymbol")?.addEventListener('click', async ()=>{
      const q = (tEl?.value||"").trim();
      const {result, error} = await searchSymbolFinnhub(q||"*");
      if(error){ alert("Szukaj symbolu — błąd: "+error); return; }
      if(!result || !result.length){ alert("Brak wyników dla: "+q); return; }

      const rows = result.slice(0,10).map(r=>`
        <tr data-sym="${r.symbol}">
          <td>${r.symbol}</td>
          <td>${r.description||''}</td>
          <td class="small">${r.displaySymbol||''}</td>
        </tr>
      `).join("");

      const picker = document.createElement('div');
      picker.className = "card panel";
      picker.innerHTML = `
        <div class="small" style="margin:6px 0 4px">Wybierz symbol z listy:</div>
        <div style="max-height:260px; overflow:auto; margin-top:4px">
          <table style="width:100%; border-collapse:collapse; font-size:13px">
            <thead>
              <tr><th>Symbol</th><th>Opis</th><th>Display</th></tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
      modalContent.appendChild(picker);
      picker.addEventListener('click', async (e)=>{
        const tr = e.target.closest('tr[data-sym]');
        if(!tr) return;
        const sym = tr.getAttribute('data-sym');
        if(tEl) tEl.value = sym || "";
        picker.remove();
        await uiFetchPrice();
      }, {once:false});
    });

    // Blokada: nie pozwalaj wpisywać jednocześnie celu % i cenowego
    setTimeout(()=>{
      try{
        const modalRoot = document.getElementById('modalContent') || document.querySelector('#modalContent');
        if(!modalRoot) return;

        const targetPctEl = modalRoot.querySelector('input[name="targetPct"]');
        const targetPriceEl = modalRoot.querySelector('input[name="targetPrice"]');
        const buyTargetPctEl = modalRoot.querySelector('input[name="buyTargetPct"]');
        const buyTargetPriceEl = modalRoot.querySelector('input[name="buyTargetPrice"]');

        function bindExclusive(a, b){
          if(!a || !b) return;
          a.addEventListener('input', ()=>{
            if(a.value && b.value){
              alert("Nie możesz jednocześnie podać celu procentowego i cenowego w tej sekcji. Czyszczę drugie pole.");
              b.value = "";
            }
          });
        }

        bindExclusive(targetPctEl, targetPriceEl);
        bindExclusive(targetPriceEl, targetPctEl);
        bindExclusive(buyTargetPctEl, buyTargetPriceEl);
        bindExclusive(buyTargetPriceEl, buyTargetPctEl);
      }catch(_){}
    }, 0);

    const data = await prom;
    if(!data) return;

    buy(currentPfId, {
      ticker: data.ticker, 
      date: data.date, 
      qty: data.qty, 
      price: data.price, 
      fees: data.fees, 
      note: data.note,
      targetPct: data.targetPct, 
      targetPrice: data.targetPrice,
      buyTargetPct: data.buyTargetPct, 
      buyTargetPrice: data.buyTargetPrice
    });
  });
  
$("#sellBtn").addEventListener('click', ()=>{
  const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
  const tickers = Object.keys(pf.holdings||{});
  if(!tickers.length) return alert("Brak pozycji do sprzedaży.");
  const optsTick = tickers.map(t=>`<option value="${t}">${t}</option>`).join("");

  const prom = openModal({
    title:"Sprzedaż — wybierz partie i ilości",
    innerHTML:`<form id="sellForm" class="content">
      <label>Ticker</label>
      <select name="ticker" id="sellTicker">${optsTick}</select>
      <div id="sellLotsBox" style="margin-top:12px"></div>
    </form>`,
    okText:"Zaksięguj"
  });

  const selEl = $("#sellTicker");
  const lotsBox = $("#sellLotsBox");
  function renderLots(){
    const t = selEl.value;
    const book = pf.holdings[t];
    if(!book){ lotsBox.innerHTML = "<div class='small'>Brak partii.</div>"; return; }
    const rows = (book.lots||[]).map(l=>`
      <tr>
        <td><code>${l.lotId.slice(0,8)}</td>
        <td>${__esc(l.date||"")}</td>
        <td>${__fmtNum(l.qty)}</td>
        <td>${__go_fmtCurrency(l.unitCost, pf.currency)}</td>
        <td><input name="lot_${l.lotId}" type="number" step="0.0001" min="0" max="${l.qty}" placeholder="0" /></td>
      </tr>
    `).join("");
    lotsBox.innerHTML = `
      <div class="grid">
        <div class="col-4">
          <label>Cena sprzedaży / szt.</label>
          <input name="sellPrice" id="sellPrice" type="number" step="0.0001" min="0" required />
        </div>
        <div class="col-4">
          <label>Opłaty</label>
          <input name="sellFees" id="sellFees" type="number" step="0.01" min="0" value="0" />
        </div>
        <div class="col-4">
          <label>Data</label>
          <input name="sellDate" id="sellDate" type="date" value="${today()}" />
        </div>
        <div class="col-12">
          <label>Notatka</label>
          <input name="sellNote" id="sellNote" placeholder="np. realizacja zysku" />
        </div>
      </div>
      <div style="margin-top:10px"></div>
      <table>
        <thead>
          <tr><th>Partia</th><th>Data</th><th>Ilość dostępna</th><th>Koszt / szt.</th><th>Ilość do sprzedaży</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <div class="small">Wpisz ilości do sprzedaży w wybranych partiach (sprzedaż specyficzna — nie FIFO).</div>
    `;
  }
  renderLots();
  selEl.addEventListener('change', renderLots);

  prom.then(data=>{
    if(!data) return; // cancel
    const t = (data.ticker||"").toUpperCase().trim();
    const pSell = Number(data.sellPrice||0);
    const fees = Number(data.sellFees||0);
    const date = data.sellDate || today();
    const note = data.sellNote || "";
    const allocations = Object.entries(data)
      .filter(([k,v])=> k.startsWith('lot_') && Number(v)>0)
      .map(([k,v])=>({ lotId: k.slice(4), qty: Number(v) }));
    sell(currentPfId, { ticker: t, date, sellPrice: pSell, fees, allocations, note });
  });
});

  // Ex/Im port
  function exportJSON(){
    const data = JSON.stringify(DB, null, 2);
    const blob = new Blob([data], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `portfele_firmy_backup_${new Date().toISOString().slice(0,10)}.json`;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      URL.revokeObjectURL(url);
      a.remove();
    }, 1000);
  }
  $("#exportBtn").addEventListener('click', exportJSON);
  $("#exportLink2").addEventListener('click', exportJSON);
  $("#importLink2").addEventListener('click', ()=> $("#importFile").click());
  $("#importFile").addEventListener('change', async (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const txt = await file.text();
    try{
      const obj = JSON.parse(txt);
      if(!obj.portfolios) throw new Error("Brak klucza portfolios.");
      DB = obj; try{ ensureWatchlistStructure(); }catch(_){} save(); render(); startPollingQuotes();
      alert("Zaimportowano dane.");
    }catch(err){
      alert("Błąd importu: "+err.message);
    }
    e.target.value = "";
  });

  
  // History actions: Edit / Delete
  txTableWrap.addEventListener('click', async (e)=>{
    const row = e.target.closest('tr.tx-row');
    const btn = e.target.closest('button');
    const pf = getPf(currentPfId); if(!pf) return;
    if(row && !btn){ // click row to edit
      const txId = row.getAttribute('data-tx');
      const txIndex = pf.transactions.findIndex(x=>x.id===txId);
      if(txIndex>=0){ const fakeBtn = document.createElement('button'); fakeBtn.className='tx-edit'; fakeBtn.setAttribute('data-tx', txId); fakeBtn.click(); }
      return;
    }
    if(!btn) return;
    const txId = btn.getAttribute('data-tx'); if(!txId) return;
    const txIndex = pf.transactions.findIndex(x=>x.id===txId);
    if(txIndex<0) return;

    if(btn.classList.contains('tx-sell-from-buy')){
      const txId = btn.getAttribute('data-tx');
      const txIndex = pf.transactions.findIndex(x=>x.id===txId);
      if(txIndex<0) return;
      const t = pf.transactions[txIndex];
      if(t.type!=='buy'){ return; }
      const lotId = t.lotId; const ticker = t.ticker; const maxQty = t.qty;
      const formHTML = `<form class="grid">
          <div class="col-4">
            <label>Cena sprzedaży / szt.</label>
            <input name="sellPrice" type="number" step="0.0001" min="0" required />
          </div>
          <div class="col-4">
            <label>Opłaty</label>
            <input name="fees" type="number" step="0.01" min="0" value="0" />
          </div>
          <div class="col-4">
            <label>Data</label>
            <input name="date" type="date" value="${today()}" />
          </div>
          <div class="col-4">
            <label>Ilość do sprzedaży</label>
            <input name="qty" type="number" step="0.0001" min="0" max="${maxQty}" value="${maxQty}" />
          </div>
          <div class="col-12">
            <label>Notatka</label>
            <input name="note" placeholder="sprzedaż tej transakcji (szybka)" />
          </div>
        </form>`;
      openModal({ title:`Sprzedaj tę transakcję — ${__esc(ticker)}`, innerHTML: formHTML, okText:'Zaksięguj' }).then(data=>{
        if(!data) return;
        const qty = Number(data.qty||0);
        const price = Number(data.sellPrice||0);
        const fees = Number(data.fees||0);
        const date = data.date || today();
        const note = data.note || '';
        if(qty<=0 || price<=0){ alert('Podaj ilość i cenę.'); return; }
        sell(currentPfId, { ticker, date, sellPrice: price, fees, allocations: [{ lotId, qty }], note });
      });
      return;
    }

    if(btn.classList.contains('tx-del')){
      const ok = confirm("Usunąć tę transakcję? Operacja nieodwracalna.");
      if(!ok) return;
      pf.transactions.splice(txIndex,1);
      rebuildPortfolio(pf); save(); render();
      return;
    }

    if(btn.classList.contains('tx-edit')){
      const t = pf.transactions[txIndex];
      // Nowa blokada — brak edycji transferów, żeby nie rozjechać drugiej strony
      if(t.type==="transfer_in" || t.type==="transfer_out" || t.type==="transfer_company_in" || t.type==="transfer_company_out"){
        alert("Edycja transferów jest zablokowana, aby uniknąć rozspójnienia danych.\nUsuń i utwórz transfer ponownie.");
        return;
      }
      // Build form per type
      let formHTML = "";
      if(t.type==="deposit" || t.type==="withdraw" || t.type==="transfer_in" || t.type==="transfer_out"){
        formHTML = `<form>
          <label>Kwota (${pf.currency})</label>
          <input name="amount" type="number" step="0.01" value="${t.amount||0}" />
          <label>Data</label>
          <input name="date" type="date" value="${t.date||today()}" />
          <label>Notatka</label>
          <input name="note" value="${__esc(t.note||'')}" />
        </form>`;
      }else if(t.type==="buy"){
        formHTML = `<form>
          <label>Ticker</label>
          <input name="ticker" value="${__esc(t.ticker||'')}" />
          <label>Ilość</label>
          <input name="qty" type="number" step="0.0001" value="${t.qty||0}" />
          <label>Cena / szt.</label>
          <input name="price" type="number" step="0.0001" value="${t.price||0}" />
          <label>Opłaty</label>
          <input name="fees" type="number" step="0.01" value="${t.fees||0}" />
          <label>Data</label>
          <input name="date" type="date" value="${t.date||today()}" />
          <label>Notatka</label>
          <input name="note" value="${__esc(t.note||'')}" />
        
        <label>Cel zysku % (opcjonalnie)</label>
        <input name="targetPct" type="number" step="0.01" value="${t.targetPct ?? ''}" placeholder="np. 5 = +5%" />
        <label>Cel cena / szt. (opcjonalnie)</label>
        <input name="targetPrice" type="number" step="0.0001" value="${t.targetPrice ?? ''}" placeholder="np. 120.00" />
        <label>Cel KUPNA % (spadek, opcj.)</label>
        <input name="buyTargetPct" type="number" step="0.01" value="${t.buyTargetPct ?? ''}" placeholder="np. 5 = -5%" />
        <label>Cel KUPNA cena / szt. (opcj.)</label>
        <input name="buyTargetPrice" type="number" step="0.0001" value="${t.buyTargetPrice ?? ''}" placeholder="np. 95.00" />
        
        </form>`;
      }else if(t.type==="sell"){
        // For now: edit price/fees/date/note; allocations pozostają bez zmian
        formHTML = `<form>
          <div class="small">Edycja sprzedaży dotyczy ceny/opłat/daty/uwag. (Alokacje partii bez zmian w tej wersji)</div>
          <label>Ticker</label>
          <input name="ticker" value="${__esc(t.ticker||'')}" />
          <label>Łączna ilość (informacyjnie)</label>
          <input type="number" step="0.0001" value="${t.qty||0}" disabled />
          <label>Cena sprzedaży / szt.</label>
          <input name="price" type="number" step="0.0001" value="${t.price||0}" />
          <label>Opłaty</label>
          <input name="fees" type="number" step="0.01" value="${t.fees||0}" />
          <label>Data</label>
          <input name="date" type="date" value="${t.date||today()}" />
          <label>Notatka</label>
          <input name="note" value="${__esc(t.note||'')}" />
        </form>`;
      }

      const data = await openModal({ title:"Edytuj transakcję", innerHTML: formHTML, okText:"Zapisz" });
      if(!data) return;

      // Apply edits
      if(t.type==="deposit" || t.type==="withdraw" || t.type==="transfer_in" || t.type==="transfer_out"){
        t.amount = Number(data.amount)||0;
        t.date = data.date || t.date;
        t.note = data.note || "";
      }else if(t.type==="buy"){
        t.ticker = (data.ticker||t.ticker||"").toUpperCase().trim();
        t.qty = Number(data.qty)||t.qty;
        t.price = Number(data.price)||t.price;
        t.fees = Number(data.fees)||t.fees;
        t.date = data.date || t.date;
        t.note = data.note || "";
        ensureBuyLotIdInTx(t);
      }else if(t.type==="sell"){
        t.ticker = (data.ticker||t.ticker||"").toUpperCase().trim();
        t.price = Number(data.price)||t.price;
        t.fees = Number(data.fees)||t.fees;
        t.date = data.date || t.date;
        t.note = data.note || "";
        // gross/net will be recomputed during rebuild
      }
      // Rebuild to keep everything consistent
      try{
        rebuildPortfolio(pf);
      }catch(err){
        alert("Edycja powoduje niespójność (np. sprzedaż > posiadane). Szczegóły: "+err.message);
        return; // do not save/render on failure
      }
      save(); render();
    }
  });

  
  // Quick actions in holdings: edit lot (buy tx) or sell this lot
  holdingsTableWrap.addEventListener('click', async (e)=>{
    const btn = e.target.closest('button'); if(!btn) return;
    

    if (btn.classList.contains('del-company')){
      const ticker = btn.getAttribute('data-ticker');
      if(!ticker) return;
      const pf = getPf(currentPfId); if(!pf) return;
      const ok = confirm(`Na pewno usunąć spółkę ${ticker} z portfela (skasuje WSZYSTKIE transakcje tej spółki)?`);
      if(!ok) return;
      try{
        pf.transactions = (pf.transactions||[]).filter(tx => (tx.ticker||'').toUpperCase() !== ticker);
        try{ delete pf.holdings[ticker]; }catch(_){}
        rebuildPortfolio(pf);
        save(); render();
        try{ showToast && showToast({title:'Usunięto spółkę', message:ticker}); }catch(_){}
      }catch(err){
        alert('Nie udało się usunąć spółki: ' + (err && err.message || err));
      }
      return;
    }
    if (btn.classList.contains('info-company')){
      const ticker = btn.getAttribute('data-ticker');
      if(!ticker) return;
      openCompanyInfoModal(ticker);
      return;
    }
    if(btn.classList.contains('transfer-company')){
  const ticker = btn.getAttribute('data-ticker');
  await transferCompanyDialog(currentPfId, ticker);
  return;
}
const pf = getPf(currentPfId); if(!pf) return;
    if(btn.classList.contains('lot-edit')){
      const ticker = btn.getAttribute('data-ticker');
      const lotId = btn.getAttribute('data-lot');
      // Szukamy zarówno zakupu, jak i ewentualnego transferu do portfela
      const txIndex = pf.transactions.findIndex(x=> 
        (
          (x.type==='buy' && x.lotId===lotId) ||
          (x.type==='transfer_company_in' && (x.newLotId===lotId || x.lotId===lotId))
        )
      );
      if(txIndex<0) { alert('Nie znaleziono transakcji źródłowej dla tej partii.'); return; }
      const t = pf.transactions[txIndex];
      const formHTML = `<form>
          <label>Ticker</label>
          <input name="ticker" value="${__esc(t.ticker||'')}" />
          <label>Ilość</label>
          <input name="qty" type="number" step="0.0001" value="${t.qty||0}" />
          <label>Cena / szt.</label>
          <input name="price" type="number" step="0.0001" value="${t.price||0}" />
          <label>Opłaty</label>
          <input name="fees" type="number" step="0.01" value="${t.fees||0}" />
          <label>Data</label>
          <input name="date" type="date" value="${t.date||today()}" />
          <label>Cel zysku %</label>
          <input name="targetPct" type="number" step="0.01" value="${t.targetPct??''}" />
          <label>Cel cena / szt.</label>
          <input name="targetPrice" type="number" step="0.0001" value="${t.targetPrice??''}" />
          <label>Cel KUPNA %</label>
          <input name="buyTargetPct" type="number" step="0.01" value="${t.buyTargetPct??''}" />
          <label>Cel KUPNA cena / szt.</label>
          <input name="buyTargetPrice" type="number" step="0.0001" value="${t.buyTargetPrice??''}" />
          <label>Notatka</label>
          <input name="note" value="${__esc(t.note||'')}" />
        </form>`;
      const data = await openModal({ title:"Edytuj zakup (partia)", innerHTML: formHTML, okText:"Zapisz"  });
      if(!data) return;
      t.ticker = (data.ticker||t.ticker||'').toUpperCase().trim();
      t.qty = Number(data.qty)||t.qty;
      t.price = Number(data.price)||t.price;
      // W przypadku partii przeniesionej dbamy też o unitCost/rawPrice,
      // żeby przebudowa portfela dała poprawne wyniki.
      if(t.type === 'transfer_company_in'){
        t.unitCost = t.price;
        t.rawPrice = t.price;
      }
      t.fees = Number(data.fees)||t.fees;
      t.date = data.date || t.date;
      t.note = data.note || "";
      t.targetPct = (data.targetPct!=='' && data.targetPct!==undefined) ? Number(data.targetPct) : null;
      t.targetPrice = (data.targetPrice!=='' && data.targetPrice!==undefined) ? Number(data.targetPrice) : null;
      t.buyTargetPct = (data.buyTargetPct!=='' && data.buyTargetPct!==undefined) ? Number(String(data.buyTargetPct).replace(',', '.')) : null;
      t.buyTargetPrice = (data.buyTargetPrice!=='' && data.buyTargetPrice!==undefined) ? Number(String(data.buyTargetPrice).replace(',', '.')) : null;
      try{
        rebuildPortfolio(pf);
      }catch(err){
        alert("Edycja powoduje niespójność (np. sprzedaż > posiadane). Szczegóły: "+err.message);
        return;
      }
      save(); render();
    }
    if(btn.classList.contains('lot-sell')){
      const ticker = btn.getAttribute('data-ticker');
      const lotId = btn.getAttribute('data-lot');
      const maxQty = Number(btn.getAttribute('data-maxqty')||0);
      const formHTML = `<form class="grid">
          <div class="col-4">
            <label>Cena sprzedaży / szt.</label>
            <input name="sellPrice" type="number" step="0.0001" min="0" required />
          </div>
          <div class="col-4">
            <label>Opłaty</label>
            <input name="fees" type="number" step="0.01" min="0" value="0" />
          </div>
          <div class="col-4">
            <label>Data</label>
            <input name="date" type="date" value="${today()}" />
          </div>
          <div class="col-4">
            <label>Ilość do sprzedaży</label>
            <input name="qty" type="number" step="0.0001" min="0" max="${maxQty}" value="${maxQty}" />
          </div>
          <div class="col-12">
            <label>Notatka</label>
            <input name="note" placeholder="sprzedaż partii # (szybka)" />
          </div>
        </form>`;
      const data = await openModal({ title:`Sprzedaj partię — ${__esc(ticker)}`, innerHTML: formHTML, okText:"Zaksięguj" });
      if(!data) return;
      const qty = Number(data.qty||0);
      const price = Number(data.sellPrice||0);
      const fees = Number(data.fees||0);
      const date = data.date || today();
      const note = data.note || "";
      if(qty<=0 || price<=0){ alert("Podaj ilość i cenę."); return; }
      sell(currentPfId, { ticker, date, sellPrice: price, fees, allocations: [{ lotId, qty }], note });
    }
    if(btn.classList.contains('add-lot')){
      const ticker = (btn.getAttribute('data-ticker')||'').trim().toUpperCase();
      const pf = getPf(currentPfId); if(!pf) return;
      const lastPrice = getQuote(ticker);

      const prom = openModal({
        title: `Zakup (nowa partia) — ${ticker}`,
        innerHTML: `<form class="grid">
          <!-- GÓRA: podstawowe pola transakcji -->
          <div class="col-4">
            <label>Ticker</label>
            <input name="ticker" value="${ticker}" readonly />
          </div>
          <div class="col-4">
            <label>Ilość</label>
            <input name="qty" type="number" step="0.0001" min="0" required />
          </div>
          <div class="col-4">
            <label>Cena / szt.</label>
            <input name="price" type="number" step="0.0001" min="0" value="${lastPrice!=null?lastPrice:''}" required />
          </div>
          <div class="col-4">
            <label>Opłaty</label>
            <input name="fees" type="number" step="0.01" min="0" value="0" />
          </div>
          <div class="col-4">
            <label>Data</label>
            <input name="date" type="date" value="${today()}" />
          </div>

          <!-- DÓŁ: cele zysku (lewa) i cele kupna (prawa) -->
          <div class="col-6">
            <div class="grid">
              <div class="col-12">
                <label>Cel zysku % (opcjonalnie)</label>
                <input name="targetPct" type="number" step="0.01" placeholder="np. 5 = +5%" />
              </div>
              <div class="col-12">
                <label>Cel zysku CENA/szt. (opcjonalnie)</label>
                <input name="targetPrice" type="number" step="0.0001" placeholder="np. 120.00" />
              </div>
            </div>
          </div>
          <div class="col-6">
            <div class="grid">
              <div class="col-12">
                <label>Cel KUPNA % (spadek, opcj.)</label>
                <input name="buyTargetPct" type="number" step="0.01" placeholder="np. 5 = kup przy -5%" />
              </div>
              <div class="col-12">
                <label>Cel KUPNA CENA/szt. (opcjonalnie)</label>
                <input name="buyTargetPrice" type="number" step="0.0001" placeholder="np. 90.00" />
              </div>
            </div>
          </div>

          <div class="col-12">
            <label>Notatka</label>
            <textarea name="note" rows="2" placeholder="np. dokup pod odbicie"></textarea>
          </div>
          <div class="col-12 small">
            Uwaga: cele zysku i cele kupna można podawać albo w procentach, albo jako cenę — nie jednocześnie.
          </div>
        </form>`
      });

      // Blokada: nie pozwalaj wpisywać jednocześnie celu % i cenowego
      setTimeout(()=>{
        try{
          const modalRoot = document.getElementById('modalContent') || document.querySelector('#modalContent');
          if(!modalRoot) return;

          const targetPctEl = modalRoot.querySelector('input[name="targetPct"]');
          const targetPriceEl = modalRoot.querySelector('input[name="targetPrice"]');
          const buyTargetPctEl = modalRoot.querySelector('input[name="buyTargetPct"]');
          const buyTargetPriceEl = modalRoot.querySelector('input[name="buyTargetPrice"]');

          function bindExclusive(a, b){
            if(!a || !b) return;
            a.addEventListener('input', ()=>{
              if(a.value && b.value){
                alert("Nie możesz jednocześnie podać celu procentowego i cenowego w tej sekcji. Czyszczę drugie pole.");
                b.value = "";
              }
            });
          }

          bindExclusive(targetPctEl, targetPriceEl);
          bindExclusive(targetPriceEl, targetPctEl);
          bindExclusive(buyTargetPctEl, buyTargetPriceEl);
          bindExclusive(buyTargetPriceEl, buyTargetPctEl);
        }catch(_){}
      }, 0);

      const data = await prom;
      if(!data) return;
      buy(currentPfId, {
        ticker: data.ticker, date: data.date, qty: data.qty, price: data.price, fees: data.fees, note: data.note,
        targetPct: data.targetPct, targetPrice: data.targetPrice,
        buyTargetPct: data.buyTargetPct, buyTargetPrice: data.buyTargetPrice
      });
      return;
    }

 else if(btn.classList.contains('lot-mute')){
      const lotId = btn.getAttribute('data-lot');
      // find the lot in current portfolio
      let target = null, targetTicker=null;
      for(const [tk, book] of Object.entries(pf.holdings||{})){
        const found = (book.lots||[]).find(x=> x.lotId === lotId);
        if(found){ target = found; targetTicker=tk; break; }
      }
      if(!target) return;
      target.muted = !target.muted;
      save(); render();
      return;
    }
});


  // Tab button
  document.getElementById('wishlistTabBtn')?.addEventListener('click', ()=>{
    const isWishlistVisible = document.getElementById('wishlistPanel')?.style.display !== 'none';
    setActiveView(isWishlistVisible ? 'portfolio' : 'wishlist');
  });

  // Wishlist form actions
  document.getElementById('wlSearch')?.addEventListener('click', async ()=>{
    const q = (document.getElementById('wlTicker')?.value||'').trim();
    await wlSearchSymbols(q);
  });
  document.getElementById('wlAdd')?.addEventListener('click', async ()=>{
    const t = document.getElementById('wlTicker')?.value||'';
    const p = document.getElementById('wlPrice')?.value||'';
    addWatchItem(t, p);
    const tEl=document.getElementById('wlTicker'); if(tEl) tEl.value='';
    const pEl=document.getElementById('wlPrice'); if(pEl) pEl.value='';
    try{ const t=document.getElementById('wlTicker')?.value||''; if(t){ const profile = await fetchCompanyProfile(t); if(profile && profile.name) setCompanyName(t, profile.name); } }catch(_){}
    renderWishlist();
  });


  // Filters
  filterQueryEl.addEventListener('input', ()=> renderMain());

  // Strategy autosave
  strategyBox.addEventListener('input', ()=>{
    const pf = getPf(currentPfId); if(!pf) return;
    pf.strategy = strategyBox.value;
    pf.updatedAt = new Date().toISOString();
    save();
  });

  function render(){
    renderPortfolioList();
    renderMain();
    try{ ensureResponsiveTables(); }catch(_){ }
  try { updateSidebarBlinkStates(); } catch(e) {}
  try { updateWishlistBlinkState(); } catch(e) {}
    
  // Filter clear
  const filterClearBtn = document.getElementById('filterClearBtn');
  if(filterClearBtn && !filterClearBtn.dataset.bound){
    filterClearBtn.dataset.bound='1';
    filterClearBtn.addEventListener('click', ()=>{ filterQueryEl.value=''; renderMain(); });
  }
startPollingQuotes();
  }

  // Initial render
  render();
  try { renderWishlist(); updateWishlistBlinkState(); } catch(e) {}
  // Upublicznienie wiązań dla Firebase
  try{
    window.save = save;
    window.render = render;
    window.__setAppDB = (obj)=>{ 
      DB = obj; 
      try{
        // Migrate wishlist items to multi-target schema after loading from server
        DB.watchlist = DB.watchlist || [];
        for(const w of DB.watchlist){
          if(!Array.isArray(w.targets)){
            const base = Number(w.price)||0;
            w.targets = base>0 ? [base] : [];
            try{ delete w.price; }catch(_){}
          }
          if(typeof w.activeIndex!=='number') w.activeIndex = 0;
          if(typeof w.name!=='string') w.name = w.name||'';
        }
      }catch(_){}
      save(); 
      try { render(); } catch(_){}
      try { renderWishlist(); updateWishlistBlinkState(); } catch(_){}
    };
  }catch(e){ console.warn('Expose bindings failed', e); }
})();
</script>
<script>
// === Collapsible History (persist state) ===
(function(){
  function setupHistoryCollapse(){
    const panel = document.getElementById('historyPanel');
    if(!panel) return;
    const btn = document.getElementById('historyCollapseBtn');
    const title = document.getElementById('historyTitle');
    const KEY = 'historyCollapsed';
    try{
      const initial = localStorage.getItem(KEY) === '1';
      if(initial) panel.classList.add('collapsed');
    }catch(e){}
    function toggle(){
      panel.classList.toggle('collapsed');
      try{ localStorage.setItem(KEY, panel.classList.contains('collapsed') ? '1':'0'); }catch(e){}
    }
    if(btn && !btn.dataset.bound){ btn.addEventListener('click', toggle); btn.dataset.bound='1'; }
    if(title && !title.dataset.bound){ title.addEventListener('click', toggle); title.dataset.bound='1'; }
  }
  // run now (scripts loaded at end of body), and also after any global re-render if needed
  try { setupHistoryCollapse(); } catch(e) {}
  // re-apply on renderMain
  if(typeof renderMain === 'function'){
    const orig = renderMain;
    window.renderMain = function(){
      const result = orig.apply(this, arguments);
      try { setupHistoryCollapse(); } catch(e) {}
      return result;
    }
  }
})();
</script>

  <script>
  // Status UI between title and actions
  (function(){
    function findHeader(){ return document.querySelector('header'); }
    function findActions(){ return document.querySelector('header .actions'); }
    function ensureStatusBetween(){
      const h = findHeader(); const a = findActions(); if(!h) return null;
      let wrap = document.getElementById('syncStatusWrap');
      if(!wrap){
        wrap = document.createElement('div');
        wrap.id='syncStatusWrap';
        wrap.style.display='inline-flex';
        wrap.style.alignItems='center';
        wrap.style.gap='6px';
        wrap.style.marginLeft='16px';
        const dot = document.createElement('span'); dot.id='syncDot';
        dot.style.width='12px'; dot.style.height='12px'; dot.style.borderRadius='50%'; dot.style.display='inline-block';
        dot.style.boxShadow='0 0 0 1px rgba(0,0,0,0.25) inset'; dot.style.background='#9ca3af';
        const txt = document.createElement('span'); txt.id='syncText'; txt.style.fontSize='12px'; txt.style.opacity='0.9'; txt.textContent='Firebase: ...';
        wrap.appendChild(dot); wrap.appendChild(txt);
        if(a){ h.insertBefore(wrap, a); } else { h.appendChild(wrap); }
      }
      return wrap;
    }
    function color(c){ const d=document.getElementById('syncDot'); if(d) d.style.background=c; }
    function label(t){ const e=document.getElementById('syncText'); if(e) e.textContent=t; }
    function pad(n){ return (n<10?'0':'')+n; } function hhmmss(ts){ const d=new Date(ts); return pad(d.getHours())+':'+pad(d.getMinutes())+':'+pad(d.getSeconds()); }
    window.setSyncStatus = function(state){
      ensureStatusBetween();
      if(state==='syncing'){ color('#f59e0b'); label('Firebase: Synchronizacja...'); return; }
      if(state==='ok'){ color('#10b981'); var t=window.__lastSyncAt?(' ('+hhmmss(window.__lastSyncAt)+')'):''; label('Firebase: OK'+t); return; }
      if(state==='error'){ color('#ef4444'); label('Firebase: Błąd'); return; }
      if(state==='offline'){ color('#ef4444'); label('Firebase: OFFLINE'); return; }
      if(state==='ready'){ color('#3b82f6'); label('Firebase: Gotowe'); return; }
      color('#9ca3af'); label('Firebase: ...');
    };
    document.addEventListener('DOMContentLoaded', ()=>{
      ensureStatusBetween();
      window.setSyncStatus(navigator.onLine?'ready':'offline');
      window.addEventListener('online', ()=>window.setSyncStatus('ready'));
      window.addEventListener('offline', ()=>window.setSyncStatus('offline'));
    }, {once:true});
  })();
  </script>


  <script>
  // --- HARDFIX: manual Firebase Wyślij/Pobierz + incognito auth ---
  window.setSyncStatus = window.setSyncStatus || function(){};
  function fbLog(msg, cls){
    // pokaż tylko błędy/ostrzeżenia — brak toastów dla OK
    if (cls!=='err' && cls!=='warn') return;

    try{
      const box = document.getElementById('fbLog'); if(!box) return;
      box.innerHTML = '<b>Firebase</b>: ' + (msg||'') + (cls?('<span class="'+cls+'"></span>'):''); 
      box.classList.add('show');
      clearTimeout(window.__fbLogTimer); window.__fbLogTimer = setTimeout(()=>{ box.classList.remove('show'); }, 6000);
    }catch(_){}
  }

  const FB_CFG = {
    apiKey: "AIzaSyBGFuXxLYQfmyo-TaxJGER2qZ0wzEvPPxk",
    authDomain: "gt-portfolios.firebaseapp.com",
    projectId: "gt-portfolios",
    appId: "1:224230120021:web:87901a167e1fc6079792dc",
    storageBucket: "gt-portfolios.appspot.com",
    messagingSenderId: "224230120021"
  };
  const FB_COL = "gt_portfolios";
  const FB_DOC = "default";

  function detectLSKey(){
  const FIXED = "portfele_firmy_v1"; // stały klucz
  // jeśli już istnieje — użyj
  try{ if(localStorage.getItem(FIXED)) return FIXED; }catch(_){}
  // migracja z innych potencjalnych kluczy
  try{
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      try{
        const v = JSON.parse(localStorage.getItem(k));
        if (v && typeof v==='object' && v.settings && Array.isArray(v.portfolios)) {
          console.log(`Znaleziono dane w kluczu: ${k}, migruję do ${FIXED}`);
          localStorage.setItem(FIXED, JSON.stringify(v));
          return FIXED;
        }
      }catch(_){}
    }
  }catch(_){}
  // jeśli nic nie znaleziono — zwróć stały
  return FIXED;
}
const LS_KEY = detectLSKey();

  async function fbInit(){
    
    // Ensure single initialization per page (singleton)
    if (window.__fbInitPromise) return window.__fbInitPromise;
    window.__fbInitPromise = (async () => {
try{
      if (!window.firebase || !firebase.apps) throw new Error("Brak Firebase SDK");
      if (!firebase.apps.length) firebase.initializeApp(FB_CFG);
      const auth = firebase.auth();
      // diagnostyka stanu auth (zabezpieczone przed wielokrotnym podpięciem)
      try{
        if(!window.__fbAuthBound){
          auth.onAuthStateChanged((user)=>{
            if(user){
              console.log('Firebase auth: zalogowano anonimowo', user.uid);
              if(typeof window.setSyncStatus==='function') window.setSyncStatus('ready');
            }else{
              console.log('Firebase auth: brak użytkownika');
            }
          });
          window.__fbAuthBound = true;
        }
      }catch(_){}
      try{ await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL); }catch(_){}
      if (!auth.currentUser) await auth.signInAnonymously();
      const db = firebase.firestore();
      return {auth, db};
    }catch(e){
      console.warn("fbInit error:", e); alert("Błąd inicjalizacji Firebase: " + (e && e.message || e)); return {};
    }
  
    })();
    return window.__fbInitPromise;
}

  
// === AutoSync Helpers ===

// === Alarm Logging (Firestore) ===
const ALARM_LOG_REPEAT_MS = 15 * 60 * 1000; // re-log same state after 15 minutes
window.__lastLoggedAlerts = window.__lastLoggedAlerts || {};

function __shouldLogAlarm(key, state){
  try{
    const now = Date.now();
    const prev = window.__lastLoggedAlerts[key];
    if(!prev || prev.state !== state || (now - prev.time) > ALARM_LOG_REPEAT_MS){
      window.__lastLoggedAlerts[key] = {state, time: now};
      return true;
    }
    return false;
  }catch(_){ return true; }
}

// Track state changes for badge counting (separate from logging)
window.__lastBadgeStates = window.__lastBadgeStates || {};

function __shouldIncrementBadge(key, state){
  try{
    const prev = window.__lastBadgeStates[key];
    const changed = !prev || prev !== state;
    if(changed){
      window.__lastBadgeStates[key] = state;
      return true;
    }
    return false;
  }catch(_){ return false; }
}



/**
 * Save alarm event to Firestore.
 * data: {scope:'portfolio'|'wishlist', pfId?, ticker, state:'hit'|'near', kind:'sell'|'buy', price, target}
 */
async function logAlarmEvent(data){
  try{
    const pack = Object.assign({}, data||{});
    const {auth, db, firebase} = await fbInit();
    if(!db || !auth || !auth.currentUser){ return; }
    const uid = auth.currentUser.uid;
    pack.uid = uid;
    // Normalize ticker/kind/state
    if(pack.ticker) pack.ticker = String(pack.ticker||'').toUpperCase();
    if(pack.kind)   pack.kind   = String(pack.kind||'').toLowerCase();
    if(pack.state)  pack.state  = String(pack.state||'').toLowerCase();
    // Add createdAt server timestamp if available, else client
    try{
      const nowClient = new Date();
      // Zapisujemy również znacznik czasu po stronie klienta,
      // żeby w trybie stub (bez serverTimestamp/toDate) mieć normalną datę.
      pack.createdAtClient = nowClient.toISOString();
      pack.createdAt = (firebase?.firestore?.FieldValue?.serverTimestamp && firebase.firestore.FieldValue.serverTimestamp()) || nowClient;
    }catch(_){
      const nowFallback = new Date();
      pack.createdAtClient = nowFallback.toISOString();
      pack.createdAt = nowFallback;
    }
    await db.collection('alerts').add(pack);
  }catch(e){
    console.warn('logAlarmEvent failed:', e);
  }
}
const AUTO_SYNC_ENABLED = true;
const AUTO_SYNC_INTERVAL_MS = 8000; // co kilka sekund
const DEVICE_KEY = 'gt_deviceId';
function getDeviceId(){
  try{
    let id = localStorage.getItem(DEVICE_KEY);
    if(!id){ id = 'dev_' + Math.random().toString(36).slice(2,10); localStorage.setItem(DEVICE_KEY, id); }
    return id;
  }catch(_){ return 'dev_unknown'; }
}
function djb2(str){
  let h = 5381, i = str.length;
  while(i) h = (h * 33) ^ str.charCodeAt(--i);
  return (h>>>0).toString(16);
}
window.__dirtySince = null;
window.__lastUploadHash = null;
window.__isSyncing = false;
window.__syncDisabled = false;
window.__deviceId = getDeviceId();
window.__markDirty = function(){
  window.__dirtySince = Date.now();
  // opcjonalny log
  try{ fbLog('Zmieniono dane lokalne — auto-sync wkrótce wyśle', 'ok'); }catch(_){}
};
async function hardUpload(){
    const {db} = await fbInit(); if(!db) return false;
    let data=null; try{ data = JSON.parse(localStorage.getItem(LS_KEY)); }catch(_){}
    if (!data){ alert("Brak danych lokalnych do wysłania (klucz: "+LS_KEY+")"); return false; }
    data._ts = Date.now(); data._ver = data.version||1;
    try{
      window.setSyncStatus('syncing');
      await db.collection(FB_COL).doc(FB_DOC).set(data, {merge:false});
    try{
      const raw2 = localStorage.getItem(LS_KEY) || '';
      window.__lastUploadHash = djb2(raw2);
    }catch(_){}
    window.__dirtySince = null;
      window.__lastSyncAt = Date.now(); window.setSyncStatus('ok');
      return true;
    }catch(e){
      console.warn("UPLOAD error:", e);
      window.setSyncStatus('error');
      try{
        const code = (e && (e.code || e.message || e.toString())) || '';
        if (typeof code === 'string' && code.indexOf('resource-exhausted') !== -1){
          window.__syncDisabled = true;
          try{ stopAutoSync(); }catch(_){}
        }
      }catch(_){}
      alert("Błąd zapisu: " + (e && e.message || e));
      return false;
    }
  }

  async function hardDownload(silent=false){
    
    const {db} = await fbInit(); if(!db) return false;
    try{
      window.setSyncStatus('syncing');
      const snap = await db.collection(FB_COL).doc(FB_DOC).get();
      if(!snap.exists){ window.setSyncStatus('error'); if(!silent) alert("Brak dokumentu w chmurze. Najpierw użyj 'Wyślij'."); fbLog('Brak dokumentu '+FB_COL+'/'+FB_DOC, 'err'); return false; }
      const data = snap.data(); if(!data){ window.setSyncStatus('error'); alert("Dokument pusty/niepoprawny."); return false; }
      localStorage.setItem(LS_KEY, JSON.stringify(data));
      
      // aktualizacja aplikacji
      if (typeof window.__setAppDB === 'function') {
        try { window.__setAppDB(data); } catch(e){ console.error('Błąd __setAppDB:', e); }
      } else {
        if (typeof window.save==='function') try{ window.save(); }catch(_){}
        if (typeof window.render==='function') try{ window.render(); }catch(_){}
      }
      if (typeof DB!=='undefined') window.DB = data;
      if (typeof save==='function') try{ save(); }catch(_){}
      if (typeof render==='function') try{ render(); }catch(_){}
      window.__lastSyncAt = Date.now(); window.setSyncStatus('ok');
      /* success alert suppressed */fbLog('Pobrano dane z chmury', 'ok');
      return true;
    }catch(e){
      console.warn("DOWNLOAD error:", e); window.setSyncStatus('error'); alert("Błąd odczytu: " + (e && e.message || e)); fbLog('Błąd odczytu: '+(e&&e.message||e), 'err'); return false;
    }
  }

  
  
  function updateSyncCheckIndicator(ok){
    try{
      const wrap = document.getElementById('syncCheckLabel');
      const val = document.getElementById('syncCheckValue');
      if (!wrap || !val) return;
      wrap.style.display = 'inline';
      if (ok === true){
        val.textContent = 'TAK';
        val.style.color = '#10b981';
      } else if (ok === false){
        val.textContent = 'NIE';
        val.style.color = '#ef4444';
      } else {
        val.textContent = '?';
        val.style.color = '#9ca3af';
      }
    }catch(_e){}
  }

async function hardDiag(){
  function foldCounts(db){
    const out = { portfolios: 0, companies: 0, positions: 0 };
    try{
      const setTickers = new Set();
      const pfs = Array.isArray(db?.portfolios) ? db.portfolios : [];
      out.portfolios = pfs.length;
      for(const pf of pfs){
        const holdings = pf && pf.holdings ? pf.holdings : {};
        for(const [ticker, h] of Object.entries(holdings)){
          if (ticker) setTickers.add(String(ticker).trim());
          const lots = (h && Array.isArray(h.lots)) ? h.lots.length : 0;
          out.positions += lots;
        }
      }
      out.companies = setTickers.size;
    }catch(_){}
    return out;
  }

  let local = {portfolios:0, companies:0, positions:0};
  try{
    const localData = JSON.parse(localStorage.getItem(LS_KEY)||'null');
    local = foldCounts(localData);
    console.log('Diag lokalnie:', {exists: !!localData, ...local});
  }catch(e){ console.warn('Błąd odczytu lokalnego:', e); }

  let syncOk = null;
  try{
    if (window.parent && typeof window.parent.__GT_GET_SYNC_OK__ === 'function') {
      syncOk = !!window.parent.__GT_GET_SYNC_OK__();
    }
  }catch(_e){ syncOk = null; }

  const {db} = await fbInit(); 
  if(!db){ 
    updateSyncCheckIndicator(false);
    return false;
  }
  try{
    window.setSyncStatus('syncing');
    await db.collection(FB_COL).doc(FB_DOC).set({_ping: Date.now(), _diag:'test connection'}, {merge:true});
    const snap = await db.collection(FB_COL).doc(FB_DOC).get();
    if(!snap.exists){ fbLog('Diag: zapis ok, odczyt brak dokumentu', 'err'); window.setSyncStatus('error'); return false; }
    const data = snap.data();
    const remote = foldCounts(data);
    const lastTs = data? (data._ts? new Date(data._ts).toLocaleString() : 'brak') : 'brak';

    fbLog('Diag: zapis/odczyt OK', 'ok');
    window.setSyncStatus('ok');
    updateSyncCheckIndicator(syncOk === false ? false : true);

    const msg = `Diagnostyka OK!

Lokalnie (${LS_KEY}):
- Portfeli: ${local.portfolios}
- Spółek (unikalne tickery): ${local.companies}
- Pozycji (lotów): ${local.positions}

W chmurze:
- Portfeli: ${remote.portfolios}
- Spółek (unikalne tickery): ${remote.companies}
- Pozycji (lotów): ${remote.positions}

Ostatni upload: ${lastTs}

Synchronizacja (konto multi-device): ${syncOk === null ? 'nieznana' : (syncOk ? 'TAK' : 'NIE')}`;
    alert(msg);
    return true;
  }catch(e){
    fbLog('Diag error: '+(e&&e.message||e), 'err');
    window.setSyncStatus('error');
    alert('Diag error: '+(e&&e.message||e));
    updateSyncCheckIndicator(false);
    return false;
  }
}

document.addEventListener('DOMContentLoaded', ()=>{
    try{
      let initialOk = null;
      if (window.parent && typeof window.parent.__GT_GET_SYNC_OK__ === 'function') {
        initialOk = !!window.parent.__GT_GET_SYNC_OK__();
      }
      updateSyncCheckIndicator(initialOk);
    }catch(_e){}
    const up = document.getElementById('firebaseUploadBtn');

    const down = document.getElementById('firebaseDownloadBtn');
    if (up) up.addEventListener('click', hardUpload);
    if (down) down.addEventListener('click', ()=>hardDownload(true));
    const diag = document.getElementById('firebaseDiagBtn'); if (diag) diag.addEventListener('click', hardDiag);
    // auto-silent download on start if doc exists (no alert)
    (async ()=>{
      const {db} = await fbInit(); if(!db) return;
    // === Real-time nasłuch zdalnych zmian ===
    if (db) {
  if (window.__fb_unsub) { try{ window.__fb_unsub(); }catch(_){ } }
  window.__fb_unsub = db.collection(FB_COL).doc(FB_DOC).onSnapshot((snap)=>{
    if (window.__UNDO_RESTORING) { try{console.log('[UNDO] ignore remote during restore');}catch(_){ } return; }

    try{
      if (!snap.exists) return;
      const remote = snap.data();
      if (remote && remote._device && remote._device === getDeviceId()) return; // nasza zmiana
      fbLog('Wykryto zdalną zmianę — auto pobieranie…', 'ok');
      hardDownload(true);
    }catch(e){ console.warn('onSnapshot error', e); }
  });
}
// === Auto PUSH (co kilka sekund) ===
    try{
      function startAutoSync(){
        if (window.__autoSyncTimer) return;
        window.__autoSyncTimer = setInterval(async ()=>{
          try{
            if (!AUTO_SYNC_ENABLED || window.__syncDisabled) return;
            if (window.__isSyncing) return;
            if (!navigator.onLine) return;
            const raw = localStorage.getItem(LS_KEY) || '';
            if (!raw) return;
            const h = djb2(raw);
            if (window.__lastUploadHash && window.__lastUploadHash === h && !window.__dirtySince) return;
            window.__isSyncing = true;
          }catch(e){}
          try{
            fbLog('Auto: wysyłam zmiany…', 'ok');
            await hardUpload();
          }catch(e){ console.warn('AutoSync upload error', e); }
          finally {
            window.__isSyncing = false;
          }
        }, AUTO_SYNC_INTERVAL_MS);
      }
      function stopAutoSync(){ if (window.__autoSyncTimer){ clearInterval(window.__autoSyncTimer); window.__autoSyncTimer = null; } }
      // wrap save()
      if (typeof window.save==='function' && !window.__saveWrapped){
        const __origSave = window.save;
        window.save = function(){
          const r = __origSave.apply(this, arguments);
          try{ window.__markDirty(); }catch(_){}
          return r;
        };
        window.__saveWrapped = true;
      }
      // flush on hide/unload
      document.addEventListener('visibilitychange', ()=>{
        if (document.visibilityState==='hidden'){ try{ if (window.__dirtySince) hardUpload(); }catch(_){ } }
      });
      window.addEventListener('beforeunload', ()=>{ try{ if (window.__dirtySince) navigator.sendBeacon && navigator.sendBeacon('/noop'); }catch(_){ } });
      startAutoSync();
    }catch(e){ console.warn('AutoSync init error', e); }

      try{
        const snap = await db.collection(FB_COL).doc(FB_DOC).get();
        if(snap.exists){ await hardDownload(true); }
        else { fbLog('Auto: brak dokumentu do pobrania', 'err'); }
      }catch(e){ fbLog('Auto-load błąd: '+(e&&e.message||e), 'err'); }
    })();
  });
  </script>


  <style>
    #fbLog {
      position: fixed; right: 12px; bottom: 12px; z-index: 9999;
      max-width: 38ch; background: rgba(17,24,39,0.9); color: #eee;
      border-radius: 12px; padding: 10px 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.4);
      font: 12px/1.35 system-ui, Segoe UI, Roboto, Arial, sans-serif;
      display: none;
    }
    #fbLog.show{ display:block; }
    #fbLog b{ color:#93c5fd; }
    #fbLog .err{ color:#fca5a5; }
    #fbLog .ok{ color:#86efac; }
  /* === Daily change arrows === */
.change-arrow{ font-weight: 700; margin-right: 4px; }
.change-arrow.up{ color: var(--ok); }
.change-arrow.down{ color: var(--danger); }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
  <div id="fbLog"></div>


<script>
// Global click delegate for per-lot mute/unmute
document.addEventListener('click', (e)=>{
  const btn = e.target.closest('button.lot-mute');
  if(!btn) return;
  try{
    const DBref = window.DB || {};
    const pfId = DBref.currentPfId || DBref.selectedPfId || (DBref.portfolios && Object.keys(DBref.portfolios)[0]);
    const pf = (DBref.portfolios && pfId) ? DBref.portfolios[pfId] : null;
    if(!pf) return;
    const lotId = btn.getAttribute('data-lot');
    let lot = null;
    for(const [tk, book] of Object.entries(pf.holdings||{})){
      lot = (book.lots||[]).find(x=> x.lotId === lotId);
      if(lot) break;
    }
    if(!lot) return;
    lot.muted = !lot.muted;
    if(typeof save === 'function') save();
    if(typeof render === 'function') render();
  }catch(err){
    console.error("lot-mute toggle error", err);
  }
});</script>


<script>
// === Persist expanded company panels across mute/refresh renders ===
(function(){
  const SS_KEY = 'openDetailsTickers_v2';

  function loadSet(){
    try{ const raw = sessionStorage.getItem(SS_KEY); const arr = raw? JSON.parse(raw): []; return new Set(Array.isArray(arr)? arr: []);}catch(_){ return new Set(); }
  }
  function saveSet(set){
    try{ sessionStorage.setItem(SS_KEY, JSON.stringify(Array.from(set||[]))); }catch(_){}
  }
  window.__openDetailsTickers = window.__openDetailsTickers || loadSet();

  function ensureDataTicker(root){
    const ctx = root || document;
    const nodes = ctx.querySelectorAll('#holdingsTableWrap details:not([data-ticker]) summary');
    nodes.forEach(sum=>{
      try{
        // Take the first text node content as ticker (before any buttons/icons)
        let txt = '';
        for(const n of sum.childNodes){
          if(n.nodeType === Node.TEXT_NODE){
            txt = (n.textContent||'').trim();
            if(txt){ break; }
          }
        }
        if(!txt){
          // fallback: whole text without inner button labels
          txt = (sum.textContent||'').trim().split('\n')[0].trim();
        }
        const details = sum.closest('details');
        if(details && txt) details.dataset.ticker = txt;
      }catch(_){}
    });
  }

  function rememberOpen(){
    try{
      ensureDataTicker();
      const wrap = document.getElementById('holdingsTableWrap');
      if(!wrap) return;
      const opened = Array.from(wrap.querySelectorAll('details[open][data-ticker]')).map(d=>d.dataset.ticker);
      window.__openDetailsTickers = new Set(opened);
      saveSet(window.__openDetailsTickers);
    }catch(_){}
  }

  function restoreOpen(root){
    try{
      ensureDataTicker(root);
      const ctx = root || document;
      const wrap = ctx.getElementById ? ctx : document;
      (wrap.querySelectorAll ? wrap.querySelectorAll('#holdingsTableWrap details[data-ticker]') : []).forEach(d=>{
        const t = d.dataset.ticker;
        if(window.__openDetailsTickers && window.__openDetailsTickers.has(t)) d.setAttribute('open','');
      });
    }catch(_){}
  }

  // Keep set in sync when user toggles any details
  document.addEventListener('toggle', (e)=>{
    const d = e.target && e.target.closest && e.target.closest('#holdingsTableWrap details[data-ticker]');
    if(!d) return;
    const t = d.dataset.ticker;
    if(!t) return;
    if(!window.__openDetailsTickers) window.__openDetailsTickers = new Set();
    if(d.open) window.__openDetailsTickers.add(t); else window.__openDetailsTickers.delete(t);
    saveSet(window.__openDetailsTickers);
  }, true);

  // Before any click that might re-render, snapshot the state (capture phase)
  document.addEventListener('click', ()=>{ try{ rememberOpen(); }catch(_){} }, true);

  // Observe DOM mutations and re-open after changes
  const mo = new MutationObserver((list)=>{
    let need = false;
    for(const m of list){
      if(m.addedNodes && m.addedNodes.length){
        need = true; break;
      }
      if(m.type === 'childList') { need = true; break; }
    }
    if(need){
      // slight delay to allow innerHTML to settle
      setTimeout(()=>restoreOpen(), 0);
    }
  });
  mo.observe(document.documentElement, {subtree:true, childList:true});

  // Wrap all known render* functions
  function wrapRenders(){
    const names = ['render','renderMain','renderLots','renderPortfolioList','renderWishlist'];
    names.forEach(n=>{
      try{
        const fn = window[n];
        if(typeof fn === 'function' && !fn.__patchedKeepOpen){
          const wrapped = function(){
            rememberOpen();
            const res = fn.apply(this, arguments);
            setTimeout(()=>restoreOpen(), 0);
            return res;
          };
          wrapped.__patchedKeepOpen = true;
          window[n] = wrapped;
        }
      }catch(_){}
    });
  }

  // Initial restore after first paint
  window.addEventListener('DOMContentLoaded', ()=>{ setTimeout(()=>{ wrapRenders(); restoreOpen(); }, 0); });
  // Also try soon in case scripts define renders later
  setTimeout(wrapRenders, 0);
  setTimeout(restoreOpen, 50);
})();

// === API last refresh clock ===
window.setApiTime = function(ts){
  try{
    if(typeof ensureStatusBetween === 'function') ensureStatusBetween();
    const wrap = document.getElementById('syncStatusWrap');
    if(!wrap) return;
    let el = document.getElementById('apiTime');
    if(!el){
      el = document.createElement('span');
      el.id = 'apiTime';
      el.style.marginLeft = '6px';
      el.className = 'muted';
      wrap.appendChild(el);
    }
    function pad(n){ return (n<10?'0':'')+n; }
    const d = new Date(ts || (window.__lastApiRefreshAt||Date.now()));
    el.textContent = '• API: ' + pad(d.getHours())+':'+pad(d.getMinutes())+':'+pad(d.getSeconds());
  }catch(_){}
};

</script>

<script>
// === Toasts & Unread badge ===
(function(){
  function ensureWrap(){ return document.getElementById('toastsWrap'); }
  window.showToast = function({ticker, state, kind}){
    try{
  const wrap = (typeof ensureWrap==='function') ? ensureWrap() : null;
  if(wrap){
    const el = document.createElement('div');
    el.className = 'toast ' + (state||'');
    const label = state==='hit' ? '🎯 Cel osiągnięty' : (state==='near' ? '⏳ Blisko celu' : '🔔 Alarm');
    el.innerHTML = `<strong>${label}</strong> • ${ticker ? (ticker.toUpperCase?.()||ticker) : '—'} • ${kind ? kind.toUpperCase?.() : '—'} <span class="time">${new Date().toLocaleTimeString()}</span>`;
    wrap.appendChild(el);
    setTimeout(()=>{ try{ el.remove(); }catch(_){ } }, 6000);
  }
  // bump unread regardless of toast container availability
  try{
    const k='alerts_unread_count';
    const curr = Number(localStorage.getItem(k)||0) || 0;
    const val = Math.min(curr+1, 999);
    localStorage.setItem(k, String(val));
    if(typeof updateAlertsBadge==='function') updateAlertsBadge();
  }catch(_){}
}catch(_){}

  };
  window.updateAlertsBadge = function(){
    try{
      const el = document.getElementById('alertsTabBtn');
      if(!el) return;
      const k='alerts_unread_count';
      const n = Number(localStorage.getItem(k)||0) || 0;
      let b = el.querySelector('.badge');
      if(n>0){
        if(!b){ b = document.createElement('span'); b.className='badge'; el.appendChild(b); }
        b.textContent = String(n);
      }else if(b){ b.remove(); }
    }catch(_){}
  };
  window.resetAlertsUnread = function(){
    try{ localStorage.setItem('alerts_unread_count', '0'); updateAlertsBadge(); }catch(_){}
  };
  document.addEventListener('DOMContentLoaded', updateAlertsBadge);
})();
</script>


<script>
(function(){
  function __fallbackSetActive(v){
    try{
      const main = document.querySelector('.main') || document.querySelector('main');
      if(!main) return;
      const panels = main.querySelectorAll(':scope > section');
      panels.forEach(sec=>{
        if(v==='wishlist') sec.style.display = (sec.id==='wishlistPanel') ? '' : 'none';
        else if(v==='alerts') sec.style.display = (sec.id==='alertsPanel') ? '' : 'none';
        else sec.style.display = (sec.id==='wishlistPanel' || sec.id==='alertsPanel') ? 'none' : '';
      });
      const btnW = document.getElementById('wishlistTabBtn');
      if(btnW){ btnW.classList.toggle('secondary', v!=='wishlist'); }
      const btnA = document.getElementById('alertsTabBtn');
      if(btnA){ btnA.classList.toggle('secondary', v!=='alerts'); }
      const btnP = document.getElementById('portfoliosTabBtn');
      if(btnP){ btnP.classList.toggle('secondary', !(v!=='wishlist' && v!=='alerts')); } // primary when main
    }catch(_){}
  }
  const navSet = (window.setActiveView || __fallbackSetActive);
  try{
    const btnP = document.getElementById('portfoliosTabBtn');
    if(btnP){ btnP.addEventListener('click', ()=>{ navSet('main'); }); }
    const btnA = document.getElementById('alertsTabBtn');
    if(btnA){ btnA.addEventListener('click', ()=>{ navSet('alerts'); window.resetAlertsUnread && window.resetAlertsUnread(); try{ ackCurrentAlerts(); updateSidebarBlinkStates && updateSidebarBlinkStates(); }catch(_){ } window.renderAlerts && window.renderAlerts(); }); }
    const btnW = document.getElementById('wishlistTabBtn');
    if(btnW){ btnW.addEventListener('click', ()=>{ navSet('wishlist'); }); }
  }catch(_){}
})();
</script>


<script>
(function(){
  async function jumpToTicker(ticker){
    try{
      ticker = (ticker||'').toUpperCase();
      if(!ticker) return;
      // pick first portfolio that contains this ticker
      let pfId = null;
      try{
        for(const pf of (window.DB?.portfolios||[])){
          if(pf && pf.holdings && Object.prototype.hasOwnProperty.call(pf.holdings, ticker)){
            pfId = pf.id || pf.name || null;
            break;
          }
        }
      }catch(_){}
      // switch view to main
      const navSet = (window.setActiveView || function(v){ 
        const main = document.querySelector('.main') || document.querySelector('main');
        if(!main) return;
        const panels = main.querySelectorAll(':scope > section');
        panels.forEach(sec=>{
          if(v==='wishlist') sec.style.display = (sec.id==='wishlistPanel') ? '' : 'none';
          else if(v==='alerts') sec.style.display = (sec.id==='alertsPanel') ? '' : 'none';
          else sec.style.display = (sec.id==='wishlistPanel' || sec.id==='alertsPanel') ? 'none' : '';
        });
      });
      navSet('main');
      // optionally select portfolio if app exposes API
      try{
        if(pfId && typeof window.setCurrentPortfolioId==='function'){
          await window.setCurrentPortfolioId(pfId);
        }
      }catch(_){}
      // ensure render
      try{ if(typeof window.render==='function') window.render(); else if(typeof window.renderMain==='function') window.renderMain(); }catch(_){}
      // scroll to row containing ticker
      setTimeout(()=>{
        try{
          const candidates = Array.from(document.querySelectorAll('td.ticker'));
          const cell = candidates.find(td => (td.textContent||'').toUpperCase().includes(ticker));
          if(cell){
            cell.scrollIntoView({behavior:'smooth', block:'center'});
            cell.classList.add('highlight');
            setTimeout(()=>{ try{ cell.classList.remove('highlight'); }catch(_){} }, 2000);
          }
        }catch(_){}
      }, 50);
    }catch(_){}
  }
  // simple highlight style
  try{
    const css = document.createElement('style');
    css.textContent = '.highlight{outline:3px solid #f59e0b; border-radius:6px; transition: outline-color .3s}';
    document.head.appendChild(css);
  }catch(_){}
  // event delegation
  document.addEventListener('click', (e)=>{
    const a = e.target.closest('a.alert-ticker');
    if(a){
      e.preventDefault();
      const t = a.getAttribute('data-ticker');
      jumpToTicker(t);
    }
  });
  // expose for debugging
  window.jumpToTicker = jumpToTicker;
})();
</script>

<script>
// === Alerts panel logic ===
// (local helpers for Alerts panel to avoid global deps)
const __esc = (s)=>{
  try{
    if (typeof window.escapeHtml === 'function') return window.escapeHtml(String(s||''));
  }catch(_){}
  const t = document.createElement('textarea');
  t.textContent = String(s||'');
  return t.innerHTML;
};
const __fmtNum = (v)=>{
  try{
    if (typeof window.fmtNum === 'function') return window.fmtNum(v);
  }catch(_){}
  const n = Number(v);
  if (!isFinite(n)) return '—';
  return n.toLocaleString(undefined, {maximumFractionDigits: 2});
};


async function fetchAlertsPage({limit=100, startAfter=null}={}){
  const empty = {items:[], lastDoc:null};
  try{
    const {auth, db} = await fbInit(); if(!db || !auth || !auth.currentUser) return empty;
    const uid = auth.currentUser.uid;
    let qBase = db.collection('alerts').where('uid','==', uid);
    let q = qBase.orderBy('createdAt','desc');
    if(limit) q = q.limit(limit);
    if(startAfter) q = q.startAfter(startAfter);
    try{
      const snap = await q.get();
      const out = []; let lastDoc = null;
      snap.forEach(doc=>{
        const d = doc.data() || {};
        const createdAt = (d.createdAt && d.createdAt.toDate) ? d.createdAt.toDate() : (d.createdAtClient ? new Date(d.createdAtClient) : null);
        out.push({
          id: doc.id,
          ticker: (d.ticker||'').toUpperCase(),
          state: d.state||'',
          kind: d.kind||'',
          price: (d.price!=null? Number(d.price): null),
          target: (d.target!=null? Number(d.target): null),
          scope: d.scope||'',
          pfId: d.pfId||'',
          createdAt
        });
        lastDoc = doc;
      });
      return {items: out, lastDoc};
    }catch(e){
      const msg = (e && (e.message||e.toString())) || '';
      if(msg.includes('requires an index')){
        console.info('Alerts: falling back to client-side sort (no composite index yet).');
        let q2 = qBase;
        if(limit) q2 = q2.limit(limit * 5);
        const snap2 = await q2.get();
        const items = [];
        snap2.forEach(doc=>{
          const d = doc.data() || {};
          const createdAt = (d.createdAt && d.createdAt.toDate) ? d.createdAt.toDate() : (d.createdAtClient ? new Date(d.createdAtClient) : null);
          items.push({
            id: doc.id,
            ticker: (d.ticker||'').toUpperCase(),
            state: d.state||'',
            kind: d.kind||'',
            price: (d.price!=null? Number(d.price): null),
            target: (d.target!=null? Number(d.target): null),
            scope: d.scope||'',
            pfId: d.pfId||'',
            createdAt
          });
        });
        items.sort((a,b)=> (b.createdAt?.getTime()||0) - (a.createdAt?.getTime()||0));
        return {items: items.slice(0, limit||items.length), lastDoc: null};
      }else{
        console.warn('fetchAlertsPage failed', e);
        return empty;
      }
    }
  }catch(e){
    console.warn('fetchAlertsPage failed', e);
    return empty;
  }
}

function fmtDateTime(dt){
  try{
    if(!dt) return '—';
    const pad = n=> (n<10?'0':'')+n;
    return dt.getFullYear()+'-'+pad(dt.getMonth()+1)+'-'+pad(dt.getDate())+' '+pad(dt.getHours())+':'+pad(dt.getMinutes())+':'+pad(dt.getSeconds());
  }catch(_){ return '—'; }
}

async function renderAlerts(){
  const body = document.getElementById('alertsTableBody');
  const stats = document.getElementById('alertsStats');
  if(!body) return;
  body.innerHTML = `<tr><td colspan="7" class="muted">Ładowanie…</td></tr>`;
  const res = await fetchAlertsPage({limit:200});
  let rows = res.items;

  // Local fallback "clear history" cutoff – hide alerts logged before
  // the last successful/attempted clear (when Firestore delete is blocked
  // or db.batch() is not available in the stub).
  try{
    const hiddenSinceStr = localStorage.getItem('alerts_hidden_all_until');
    const hiddenSince = Number(hiddenSinceStr);
    // Jeśli użytkownik nigdy nie czyścił historii (brak / 0 / NaN), nie filtrujemy nic.
    if(Number.isFinite(hiddenSince) && hiddenSince > 0){
      rows = rows.filter(r => {
        try{
          const t = (r.createdAt instanceof Date) ? r.createdAt.getTime() : 0;
          // Brak daty traktujemy jako "stary wpis" (schowany po czyszczeniu).
          if(!t) return false;
          return t > hiddenSince;
        }catch(_){ return true; }
      });
    }
  }catch(_){}


  // Filters
  const fScope = document.getElementById('alertsScope')?.value || '';
  const fState = document.getElementById('alertsState')?.value || '';
  const fKind  = document.getElementById('alertsKind')?.value  || '';
  rows = rows.filter(r=> (!fScope || r.scope===fScope) && (!fState || r.state===fState) && (!fKind || r.kind===fKind));

  // Stats
  const total = rows.length;
  const hits = rows.filter(r=> r.state==='hit').length;
  const nears = rows.filter(r=> r.state==='near').length;
  if(stats) stats.textContent = `Wpisów: ${total} — 🎯 hit: ${hits}, ⏳ near: ${nears}`;

  // Render
  if(!rows.length){
    body.innerHTML = `<tr><td colspan="7" class="muted">Brak alarmów do wyświetlenia.</td></tr>`;
    return;
  }
  body.innerHTML = rows.map(r=>{
    const stateTxt = r.state==='hit' ? '🎯 cel osiągnięty' : (r.state==='near' ? '⏳ blisko celu' : r.state);
    const kindTxt = r.kind ? r.kind.toUpperCase() : '—';
    const scopeTxt = r.scope==='wishlist' ? 'Wishlist' : (r.scope==='portfolio' ? 'Portfel' : '—');
    return `<tr class="${r.state==='hit'?(r.kind==='sell'?'hit-target-sell':'hit-target-buy'):(r.state==='near'?(r.kind==='sell'?'near-target-sell':'near-target-buy'):'')}">
      <td>${fmtDateTime(r.createdAt)}</td>
      <td><a href=\"#\" class=\"alert-ticker\" data-ticker=\"${__esc(r.ticker||'')}\">${__esc(r.ticker||'')}</a></td>
      <td>${stateTxt}</td>
      <td>${kindTxt}</td>
      <td>${r.price!=null? __fmtNum(r.price) : '—'}</td>
      <td>${r.target!=null? __fmtNum(r.target) : '—'}</td>
      <td>${scopeTxt}</td>
    </tr>`;
  }).join('');
}


(function wireAlertsUI(){
  try{
    const clr = document.getElementById('alertsClearBtn');
    if(clr){
      clr.addEventListener('click', async ()=>{
        try{
          clr.disabled = true;
          const old = clr.textContent;
          clr.textContent = 'Kasuję…';
          await clearAlertsHistory();
          clr.textContent = old;
        }finally{
          clr.disabled = false;
        }
      });
    }
  }catch(_){}

  try{
    function __fallbackSetActive(v){
      try{
        const main = document.querySelector('.main') || document.querySelector('main');
        if(!main) return;
        const panels = main.querySelectorAll(':scope > section');
        panels.forEach(sec=>{
          if(v==='wishlist') sec.style.display = (sec.id==='wishlistPanel') ? '' : 'none';
          else if(v==='alerts') sec.style.display = (sec.id==='alertsPanel') ? '' : 'none';
          else sec.style.display = (sec.id==='wishlistPanel' || sec.id==='alertsPanel') ? 'none' : '';
        });
        const btnW = document.getElementById('wishlistTabBtn');
        if(btnW){ btnW.classList.toggle('secondary', v!=='wishlist'); }
        const btnA = document.getElementById('alertsTabBtn');
        if(btnA){ btnA.classList.toggle('secondary', v!=='alerts'); }
      }catch(_){}
    }
    const navSet = (window.setActiveView || __fallbackSetActive);

    const btn = document.getElementById('alertsTabBtn');
    if(btn){
      btn.addEventListener('click', ()=>{ navSet('alerts'); renderAlerts(); try{ localStorage.setItem('alerts_unread_count','0'); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); }catch(_){} });
    }
    const ref = document.getElementById('alertsRefreshBtn');
    if(ref){
      ref.addEventListener('click', ()=> renderAlerts());
    }
    ['alertsScope','alertsState','alertsKind'].forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.addEventListener('change', ()=> renderAlerts());
    });
  }catch(_){}
})();
</script>

<script>
try{
  window.addEventListener('storage', function(e){
    try{
      if(e && e.key === 'alerts_unread_count'){
        if(typeof updateAlertsBadge === 'function') updateAlertsBadge();
      }
    }catch(_){}
  });
  document.addEventListener('visibilitychange', function(){
    try{
      if(document.visibilityState === 'visible' && typeof updateAlertsBadge === 'function') updateAlertsBadge();
    }catch(_){}
  });
}catch(_){}
</script>


<script>
/* === Global Alarm Scanner (runs on price updates) === */
try{
  window.__lastGlobalAlarmScanAt = window.__lastGlobalAlarmScanAt || 0;
  const SCAN_MIN_INTERVAL_MS = 1000; // throttle to avoid heavy loops each tick

  window.scanAlarmsGlobal = function(){
    try{
      const now = Date.now();
      if((now - window.__lastGlobalAlarmScanAt) < SCAN_MIN_INTERVAL_MS) return;
      window.__lastGlobalAlarmScanAt = now;

      const tol = (Number(DB?.settings?.approachTolerancePct)||1)/100;

      // --- Portfolio holdings ---
      try{
        const pfs = Array.isArray(DB?.portfolios) ? DB.portfolios : [];
        for(const pf of pfs){
          const holdings = pf?.holdings || {};
          for(const [ticker, book] of Object.entries(holdings)){
            const lots = Array.isArray(book?.lots) ? book.lots : [];
            for(const lot of lots){
              try{
                lot._ticker = ticker;
                if(lot && lot.muted) continue;
                const st = (typeof targetStatus==='function') ? targetStatus(lot) : {state:'none'};
                if(st.state==='hit' || st.state==='near'){
                  const kind = st.kind || (st.state==='hit' ? 'sell' : 'buy');
                  const price = getQuote(ticker);
                  const target = (kind==='sell') 
                                  ? (typeof computeTargetPrice==='function' ? computeTargetPrice(lot) : null)
                                  : (typeof computeBuyTargetPrice==='function' ? computeBuyTargetPrice(lot) : null);
                  if(price!=null && target!=null){
                    const key = ['pf', pf?.id || 'default', ticker, kind].join('|');
                    if(typeof __shouldLogAlarm==='function' ? __shouldLogAlarm(key, st.state) : true){
                      try{ if(window.showToast) showToast({ticker, state:st.state, kind}); }catch(_){}
                      try{ logAlarmEvent({scope:'portfolio', pfId:(pf&&pf.id)||'', ticker, state:st.state, kind, price, target}); }catch(_){}
                    }
                  }
                }
              }catch(_){}
            }
          }
        }
      }catch(_){}

      // --- Wishlist (buy targets only) ---
      try{
        const wl = Array.isArray(DB?.watchlist) ? DB.watchlist : [];
        for(const w of wl){
          try{
            const t = (w?.ticker||'').toUpperCase();
            const price = getQuote(t);
            const targets = Array.isArray(w?.targets) ? (w.targets || []).map(Number).filter(x=>x>0)
                           : ((Number(w?.price)||0) ? [Number(w.price)] : []);
            const ai = Math.min(Math.max(Number(w?.activeIndex)||0, 0), Math.max(targets.length-1,0));
            const desired = targets.length ? Number(targets[ai])||0 : 0;
            if(price!=null && desired>0){
              let state = null;
              if(price <= desired){ state = 'hit'; }
              else if(price <= desired*(1+tol)){ state = 'near'; }
              if(state){
                const key = ['wl', w?.id || t, 'buy'].join('|');
                if(typeof __shouldLogAlarm==='function' ? __shouldLogAlarm(key, state) : true){
                  try{ if(window.showToast) showToast({ticker:t, state, kind:'buy'}); }catch(_){}
                  try{ logAlarmEvent({scope:'wishlist', ticker:t, state, kind:'buy', price, target:desired}); }catch(_){}
                }
              }
            }
          }catch(_){}
        }
      }catch(_){}
    }catch(_){}
  };

  // Helper that can be called from setQuote
  window.maybeScanAlarmsGlobal = function(){
    try{ window.scanAlarmsGlobal && window.scanAlarmsGlobal(); }catch(_){}
  };
}catch(_){}
</script>


<script>
// === Clear Alerts History ===
async function clearAlertsHistory(){
  try{
    const go = (typeof window.confirm==='function') ? window.confirm('Skasować historię alarmów? Operację można cofnąć przez 2 dni (↩️ Cofnij)..') : true;
    if(!go) return;
    const ctx = await fbInit();
    const {auth, db} = ctx || {};
    if(!db || !auth || !auth.currentUser){ throw new Error('no-auth'); }
    const uid = auth.currentUser.uid;
    const q = db.collection('alerts').where('uid','==', uid);
    const snap = await q.get();
    if(snap && !snap.empty){
      let batch = db.batch();
      let i = 0, commits = [];
      snap.forEach(doc=>{
        batch.delete(doc.ref);
        i++;
        if(i % 400 === 0){
          commits.push(batch.commit());
          batch = db.batch();
        }
      });
      commits.push(batch.commit());
      await Promise.all(commits);
    }
    // success path
    try{ window.__lastLoggedAlerts = {}; }catch(_){}
    try{ const k='alerts_unread_count'; localStorage.setItem(k,'0'); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); }catch(_){}
    // Refresh list
    return renderAlerts();
  }catch(e){
    // Fallback: local clear (hide all alerts locally)
    try{
      const ts = Date.now();
      localStorage.setItem('alerts_hidden_all_until', String(ts));
      window.__lastLoggedAlerts = {};
      const k='alerts_unread_count';
      localStorage.setItem(k,'0');
      if(typeof updateAlertsBadge==='function') updateAlertsBadge();
      if(typeof renderAlerts==='function') renderAlerts();
      // Logika komunikatu zależnie od typu błędu:
      try{
        const code = e && (e.code || e.message || e.toString() || '');
        if(typeof code === 'string' &&
           (code.includes('permission-denied') || code.includes('Missing or insufficient permissions'))){
          console.warn('clearAlertsHistory: firestore permission error, using local fallback', code);
          alert('Brak uprawnień do kasowania w Firestore — wyczyszczono lokalnie (widok).');
        }else{
          // Tryb stub / brak batch / inne łagodne błędy – czyścimy lokalnie po cichu
          console.info('clearAlertsHistory: local fallback (stub / batch unavailable).');
        }
      }catch(_ignore){}
      return;
    }catch(_){}
  }
}
</script>


<!-- ALLOW_RULES_ALERTS_SNIPPET
Suggested Firestore rules for alerts collection (replace with your setup):
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /alerts/{alertId} {
      allow read: if request.auth != null && resource.data.uid == request.auth.uid;
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.uid == request.auth.uid;
    }
  }
}
-->


<!-- === [GT ADDON] Global Overview Tab (Osobna Zakładka) === -->
<style>
  /* Namespaced styles to avoid collisions */
  #go-tab-overlay[hidden]{ display:none !important }
  #go-tab-overlay{
    position:fixed; inset:0; z-index:9999;
    background: radial-gradient(1200px 600px at 10% -10%, rgba(34,211,238,.06), transparent 40%),
                radial-gradient(1200px 600px at 110% 110%, rgba(16,185,129,.06), transparent 40%),
                linear-gradient(120deg,#0b1222 0%,#0f172a 40%, #101525 100%);
    color:#e5e7eb; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Noto Sans, Ubuntu, Cantarell, Arial;
  }
  #go-tab-header{
    display:flex; align-items:center; gap:10px; justify-content:space-between;
    padding:12px 14px; border-bottom:1px solid #1f2937;
    background: linear-gradient(0deg, rgba(15,23,42,.75), rgba(15,23,42,.75));
    backdrop-filter: blur(8px);
  }
  #go-tab-main{ padding:14px; display:flex; flex-direction:column; gap:14px; height: calc(100% - 60px); overflow:auto }
  #go-fab{
    position:fixed; right:16px; bottom:16px; z-index:9998;
    border:none; border-radius:14px; padding:12px 14px; cursor:pointer; font-weight:800;
    background:var(--ok); color:#001018; box-shadow:0 12px 25px rgba(16,185,129,.35);
  }
  #go-fab:hover{ transform: translateY(-1px); filter: brightness(1.05) }
  #go-close{ border:none; border-radius:10px; padding:8px 10px; cursor:pointer; font-weight:800; background:#334155; color:#e5e7eb }
  #go-close:hover{ filter:brightness(1.1) }
  /* Cards, tables, etc. (scoped) */
  #go-tab-overlay .go-card{ background:linear-gradient(180deg, rgba(17,24,39,.92), rgba(16,23,42,.98)); border:1px solid #1f2937; border-radius:16px }
  #go-tab-overlay .go-panel{ padding:14px }
  #go-tab-overlay .go-grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:14px }
  #go-tab-overlay .go-col-3{ grid-column: span 3 } .go-col-4{ grid-column: span 4 } .go-col-6{ grid-column: span 6 } .go-col-8{ grid-column: span 8 } .go-col-12{ grid-column: span 12 }
  @media (max-width: 980px){ #go-tab-overlay .go-col-3, #go-tab-overlay .go-col-4, #go-tab-overlay .go-col-6, #go-tab-overlay .go-col-8{ grid-column: span 12 } }
  #go-tab-overlay table{ width:100%; border-collapse:collapse }
  #go-tab-overlay th, #go-tab-overlay td{ padding:10px; border-bottom:1px solid #1f2937; text-align:left; vertical-align: top }
  #go-tab-overlay th{ color:#cbd5e1; background:#0b1222; position:sticky; top:0 }
  #go-tab-overlay .go-ticker{ font-family: ui-monospace, Menlo, Consolas, "Courier New", monospace; letter-spacing:.3px; font-weight:700 }
  #go-tab-overlay input, #go-tab-overlay select{
    width:100%; padding:10px 12px; border-radius:12px; border:1px solid #334155;
    background:#0b1222; color:#e5e7eb; outline:none; font-size:14px
  }
  #go-tab-overlay .go-chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#0b1222; border:1px solid #1f2937; font-weight:700 }
  #go-tab-overlay .go-tag{ padding:3px 8px; border-radius:999px; border:1px solid #334155; color:#cbd5e1; font-size:12px; background:#0c1426 }
  #go-tab-overlay .go-stat{ display:flex; align-items:flex-start; justify-content:space-between; gap:8px; padding:12px; border-radius:14px; background:#0b1222; border:1px solid #1f2937 }
  #go-tab-overlay .go-big{ font-size:22px; font-weight:900 }
  #go-tab-overlay .go-muted{ color:#94a3b8 }
  #go-tab-overlay .go-badge{ font-weight:800; padding:2px 6px; border-radius:8px; background: rgba(255,255,255,.04); display:inline-block; min-width:62px; text-align:right }
  #go-tab-overlay .go-pos{ color:#10b981 } .go-neg{ color:#ef4444 }
  #go-tab-overlay .go-mini{ font-size:12px }
  #go-tab-overlay .go-switch{ display:flex; align-items:center; gap:8px }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style>
  /* Details row in Positions (aggregation) */
  #go-tab-overlay .go-detail-row td { padding: 0; }
  #go-tab-overlay .go-detail-row .table-wrap { margin: 6px 0; }


  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<button id="go-fab" title="Statystyki – osobna zakładka">📈 Statystyki</button>

<section id="go-tab-overlay" hidden>
  <div id="go-tab-header">
    <h3 style="margin:0;font-size:18px">📈 Globalne Statystyki Majątku </h3>
    <div style="display:flex;gap:8px;align-items:center">


      <span class="go-switch go-mini"><input type="checkbox" id="go-no-api"> <label for="go-no-api">Bez API (tylko istniejące ceny)</label></span>
      <button id="go-refresh" title="Odśwież">🔄</button>
      <button id="go-export-csv" title="Eksport CSV">⬇️ CSV</button>
      <button id="go-export-json" title="Eksport JSON">⬇️ JSON</button>
      <button id="go-close">✖ Zamknij</button>
    </div>
  </div>


  <div id="go-tab-main">
    <section class="go-card go-panel">
      <div class="go-grid" style="align-items:end">
        <div class="go-col-4">
          <label>Waluta bazowa</label>
          <select id="go-base">
            <option value="PLN">PLN</option>
            <option value="USD">USD</option>
            <option value="EUR">EUR</option>
          </select>
          <div class="go-muted go-mini">Sumy przeliczane bieżącym FX.</div>
        </div>
        <div class="go-col-4">
          <label>Token Finnhub</label>
          <input id="go-token" placeholder="np. d0b..." />
          <div class="go-muted go-mini">Jeśli puste — spróbuję z Ustawień.</div>
        </div>
        <div class="go-col-4">
          <label>Odświeżanie (sek.)</label>
          <input id="go-poll" type="number" min="5" step="1" value="45" />
        </div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <div class="go-chip">💱 FX: <span id="go-fx" style="font-family:ui-monospace">—</span></div>
<div class="go-chip">✏️ USD→PLN: <input id="go-fx-usdpln" type="number" min="0" step="0.0001" style="width:110px"> <button id="go-fx-apply" class="go-mini" title="Ustaw kurs ręcznie">Ustaw</button> <button id="go-fx-clear" class="go-mini" title="Wyczyść ręczny kurs">Wyczyść</button></div>
<script id="go-fx-storage">
(function(){
  const KEY = 'gt_fx_usd_pln';
  function toNum(v){
    if (v===undefined || v===null) return NaN;
    const s = String(v).replace(',', '.').trim();
    return Number(s);
  }
  function readSaved(){
    try{
      const v = localStorage.getItem(KEY);
      const n = toNum(v);
      return (Number.isFinite(n) && n>0) ? n : null;
    }catch(_){ return null; }
  }
  function save(val){
    try{
      const n = toNum(val);
      if (!Number.isFinite(n) || n<=0){ localStorage.removeItem(KEY); return null; }
      localStorage.setItem(KEY, String(n));
      return n;
    }catch(_){ return null; }
  }
  function clearSaved(){
    try{ localStorage.removeItem(KEY); }catch(_){}
  }

  function bind(){
    const root = document.getElementById('go-tab-overlay');
    if(!root) return;
    const input = root.querySelector('#go-fx-usdpln');
    const btnApply = root.querySelector('#go-fx-apply');
    const btnClear = root.querySelector('#go-fx-clear');
    if(!input) return;

    const saved = readSaved();
    if(saved){ input.value = saved; }

    if(btnApply){
      btnApply.addEventListener('click', function(){ save(input.value); }, {passive:true});
    }
    input.addEventListener('keydown', function(ev){
      if(ev.key==='Enter'){
        save(input.value);
        if(btnApply){ try{ btnApply.click(); }catch(_){ } }
      }
    });
    if(btnClear){
      btnClear.addEventListener('click', function(){ clearSaved(); }, {passive:true});
    }
    input.addEventListener('blur', function(){ save(input.value); });
  }

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', bind);
  }else{
    bind();
  }
})();
</script>

        <div class="go-chip">🧾 Źródła: Finnhub Quote, Frankfurter (ECB) / exchangerate.host</div>
        <div class="go-chip">🧊 Cache TTL: <span id="go-ttl" class="go-mini">60s</span></div>
        <div style="flex:1"></div>
        <button id="go-save" style="border:none;border-radius:12px;padding:10px 14px;font-weight:800;background:#22d3ee;color:#001018">💾 Zapisz</button>
      </div>
    </section>

    <section class="go-card go-panel">
      <h4 style="margin:0 0 8px 0">🔎 Szybkie statystyki (waluta bazowa)</h4>
      <div class="go-grid">
        <div class="go-col-3"><div class="go-stat"><div><div class="go-muted">Wartość akcji</div><div id="go-tot-hold" class="go-big">—</div></div><span class="go-tag">live</span></div></div>
        <div class="go-col-3"><div class="go-stat"><div><div class="go-muted">Gotówka</div><div id="go-tot-cash" class="go-big">—</div></div><span class="go-tag">suma</span></div></div>
        <div class="go-col-3"><div class="go-stat"><div><div class="go-muted">Suma majątku</div><div id="go-tot-eq" class="go-big">—</div></div><span class="go-tag">akcje+cash</span></div></div>
        <div class="go-col-3"><div class="go-stat"><div><div class="go-muted">Niezreal. P/L</div><div class="go-big"><span id="go-tot-unr">—</span> <span id="go-tot-unr-pct" class="go-badge">—</span></div><div class="go-muted go-mini">vs koszt własny</div></div><span id="go-day" class="go-tag">Δ dzienny: —</span></div></div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:6px">
        <div class="go-chip">💰 Zreal. P/L (brutto): <span id="go-real-g" style="font-family:ui-monospace">—</span></div>
        <div class="go-chip">🧾 Podatek: <span id="go-real-tax" style="font-family:ui-monospace">—</span></div>
        <div class="go-chip">🏁 Zreal. P/L (netto): <span id="go-real-n" style="font-family:ui-monospace">—</span></div>
        <div class="go-chip">⏱️ Śr. czas (zamknięte): <span id="go-avg-hold" style="font-family:ui-monospace">—</span></div>
        
        <div class="go-chip">📈 Śr. zysk % / pozycję (brutto): <span id="go-avg-pct" style="font-family:ui-monospace">—</span></div>

    
        <div class="go-chip">🎯 TP: <span id="go-tp-count">—</span></div><div class="go-chip"><label for="go-period" class="go-chip-label">📅 Okres</label> <select id="go-period" style="width:auto"><option value="day">Dzień</option><option value="week">Tydzień</option><option value="month">Miesiąc</option><option value="ytd">Ten rok</option><option value="1y">Rok</option><option value="2y">2 lata</option><option value="3y">3 lata</option><option value="all">Cały okres</option></select></div>
        
</section>

<!-- 🧭 [GO] Wkład vs Wartość — wykres liniowy -->
<style>
  /* Minimal styles for the GO line chart */
  #go-line-chart-card{ margin-top: 12px; }
  .go-legend{ display:flex; gap:16px; align-items:center; margin:6px 0 10px 0; flex-wrap:wrap; }
  .go-legend .dot{ width:12px; height:12px; border-radius:999px; display:inline-block; vertical-align:middle; margin-right:6px; }
  .go-legend .blue{ background:#3b82f6; }
  .go-legend .green{ background:#22c55e; }
  .go-legend .muted{ opacity:0.65; font-size:12px; }
  .go-chart-wrap{ width:100%; height:260px; position:relative; border:1px solid #1f2937; border-radius:10px; overflow:hidden; }
  #go-line-chart{ width:100%; height:100%; display:block; }
  #go-chart-empty{ padding:12px; font-size:13px; opacity:0.8; }
  .go-chart-tooltip{
    position:absolute; pointer-events:none; background:#0b1220; border:1px solid #1f2937;
    padding:6px 8px; border-radius:8px; font-size:12px; white-space:nowrap;
    transform:translate(-50%, -120%);
  }
  .go-gridline{ opacity:0.15; }
</style>
<section class="go-card go-panel" id="go-line-chart-card">
  <h4 style="margin:0 0 8px 0">📈 Wkład własny vs wartość (zakres czasu jak w filtrze)</h4>
  <div class="go-legend">
    <span><span class="dot blue"></span>Wkład własny (wpłaty − wypłaty)</span>
    <span><span class="dot green"></span>Wartość majątku (akcje + gotówka, wg bieżących cen)</span>
    <span class="muted">* brak historii cen — linia wartości zmienia się przy transakcjach/zastrzykach gotówki</span>
  </div>
  <div id="go-line-chart-info" class="muted" style="margin-bottom:6px">
    <span id="go-info-blue"></span> • <span id="go-info-green"></span>
  </div>
  <div class="go-chart-wrap">
    <canvas id="go-line-chart"></canvas>
    <canvas id="go-line-chart-overlay"></canvas>

    <div class="chart-tooltip-improved" id="go-chart-tooltip-imp">
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">Data:</span><span class="tooltip-value-improved" id="tt-date-imp">-</span></div>
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">Wkład własny:</span><span class="tooltip-value-improved" id="tt-invested-imp">-</span></div>
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">Wartość portfela:</span><span class="tooltip-value-improved" id="tt-value-imp">-</span></div>
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">Zysk/Strata:</span><span class="tooltip-value-improved" id="tt-profit-imp">-</span></div>
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">ROI (%):</span><span class="tooltip-value-improved" id="tt-roi-imp">-</span></div>
    </div>
    
    <div id="go-chart-empty" style="display:none">Brak danych do wykresu w wybranym okresie.</div>
  </div>
</section>

    <section class="go-card go-panel">
      <div style="display:flex;align-items:center;gap:8px">
        <h4 style="margin:0">📂 Portfele</h4><div style="flex:1"></div><span class="go-muted go-mini">Kliknij, by rozwinąć pozycje.</span>
      </div>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Portfel</th><th>Waluta</th><th>Gotówka</th><th>Akcje</th><th>Razem (nat.)</th><th>Razem (baz.)</th><th>Koszt własny</th><th>Unreal. P/L</th><th>Unreal. %</th><th>Real. netto</th></tr></thead>
          <tbody id="go-pf-body"><tr><td colspan="10" class="go-muted">Brak danych…</td></tr></tbody>
        </table>
      </div>
    </section>

    <section class="go-card go-panel">
      <div style="display:flex;gap:8px;align-items:center">
        <h4 style="margin:0">🧩 Pozycje (agregacja)</h4>
        <div style="flex:1"></div>
        <input id="go-filter" placeholder="np. TSLA, .WA, zysk>0, strata>0, pf:Nazwa" style="max-width:320px">
      </div>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Ticker</th><th>Portfel</th><th>Ilość</th><th>Śr. koszt</th><th>Koszt własny</th><th>Kurs</th><th>Wartość</th><th>Unreal. P/L</th><th>%</th><th>Δ dzienny</th></tr></thead>
          <tbody id="go-pos-body"><tr><td colspan="10" class="go-muted">Brak pozycji…</td></tr></tbody>
        </table>
      </div>
    </section>
  </div>
</section>

<script>
(function(){
  "use strict";

// === Period filter helpers ===
function toMs(d){
  try{
    if(d==null) return NaN;
    if(typeof d === 'number') return d;
    if(typeof d === 'string'){ const ms = Date.parse(d); return Number.isFinite(ms)?ms:NaN; }
    if(d && typeof d.toDate === 'function'){ try{ return d.toDate().getTime(); }catch(_){ return NaN; } }
    if(d && typeof d.seconds !== 'undefined'){ return Number(d.seconds)*1000; }
  }catch(_){}
  return NaN;
}
function getPeriodKey(){
  try{ return localStorage.getItem('global_overview_period') || 'all'; }catch(_){ return 'all'; }
}
function setPeriodKey(k){
  try{ localStorage.setItem('global_overview_period', String(k||'all')); }catch(_){}
}
function getPeriodRange(key){
  const now = new Date();
  const end = now.getTime();
  const msDay = 24*60*60*1000;
  const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
  switch(key){
    case 'day':  return {start:startOfToday, end};
    case 'week': return {start:end - 7*msDay, end};
    case 'month':return {start:end - 30*msDay, end};
    case 'ytd':  return {start:new Date(now.getFullYear(),0,1).getTime(), end};
    case '1y':   return {start:end - 365*msDay, end};
    case '2y':   return {start:end - 2*365*msDay, end};
    case '3y':   return {start:end - 3*365*msDay, end};
    default:     return {start:-Infinity, end};
  }
}
function inRangeMs(ms, range){
  if(!range) return true;
  if(!Number.isFinite(ms)) return false;
  const s = Number(range.start ?? -Infinity);
  const e = Number(range.end ?? Infinity);
  return ms >= s && ms <= e;
}

  // === GLOBAL, COOPERATIVE RATE-LIMITED QUOTE LAYER (shared across modules) ===
  const MIN_INTERVAL_MS = 1100;       //  ~1 req/sec (safe for free tiers)
  const CACHE_TTL_MS   = 60*1000;     //  60s cache per symbol
  const BACKOFF_429_MS = 15*1000;     //  15s cooldown on 429

  const W = window;
  W.__GT_QUOTE_CACHE = W.__GT_QUOTE_CACHE || new Map(); // symbol -> {q, at}
  W.__GT_QUOTE_PENDING = W.__GT_QUOTE_PENDING || new Map(); // symbol -> Promise
  W.__GT_QUOTE_LAST_CALL = W.__GT_QUOTE_LAST_CALL || 0;
  W.__GT_QUOTE_COOLDOWN_UNTIL = W.__GT_QUOTE_COOLDOWN_UNTIL || 0;

  function now(){ return Date.now(); }

  function readFromAppQuotes(symbol){
    try{
      // próbujemy współdzielić dane głównej aplikacji, jeśli ma global QUOTES
      const Q = W.QUOTES || W.__QUOTES || null;
      if(!Q || !Q[symbol]) return null;
      const v = Q[symbol];
      // heurystyka: rozmaite formaty
      if (typeof v === 'object'){
        const price = Number(v.price ?? v.c ?? v.last ?? v.p) || null;
        if (price){ return { c: price, pc: Number(v.prevPrice ?? v.pc ?? 0) || null, t: now() }; }
      }else if (isFinite(Number(v))){
        return { c: Number(v), pc: null, t: now() };
      }
    }catch(_){}
    return null;
  }

  async function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }

  async function fetchQuoteCoop(symbol, token, opts={}){
    const noApi = !!opts.noApi;
    const ttl = isFinite(opts.ttlMs) ? opts.ttlMs : CACHE_TTL_MS;
    const key = String(symbol).toUpperCase();

    // (1) cache
    const cached = W.__GT_QUOTE_CACHE.get(key);
    if (cached && (now() - cached.at) < ttl){ return cached.q; }

    // (2) try read from app's existing quotes
    const fromApp = readFromAppQuotes(key);
    if (fromApp){
      W.__GT_QUOTE_CACHE.set(key, {q: fromApp, at: now()});
      return fromApp;
    }

    // (3) no external calls mode
    if (noApi || !token){
      // keep last known cache or return null
      return cached ? cached.q : null;
    }

    // de-dup concurrent fetches for the same symbol
    if (W.__GT_QUOTE_PENDING.has(key)) return await W.__GT_QUOTE_PENDING.get(key);

    const p = (async ()=>{
      // cooldown window after 429
      const until = W.__GT_QUOTE_COOLDOWN_UNTIL || 0;
      if (now() < until) { await delay(until - now()); }

      // rate limit: spacing calls
      const wait = Math.max(0, (W.__GT_QUOTE_LAST_CALL + MIN_INTERVAL_MS) - now());
      if (wait>0) await delay(wait);

      try{
        const url = `https://finnhub.io/api/v1/quote?symbol=${encodeURIComponent(key)}&token=${encodeURIComponent(token)}`;
        const res = await fetch(url);
        if (res.status === 429){
          // backoff; keep old value if any
          W.__GT_QUOTE_COOLDOWN_UNTIL = now() + BACKOFF_429_MS;
          const cached = W.__GT_QUOTE_CACHE.get(key);
          return cached ? cached.q : null;
        }
        const js = await res.json();
        const q = { c:Number(js.c)||null, pc:Number(js.pc)||null, d:Number(js.d)||null, dp:Number(js.dp)||null, t: js.t||now() };
        W.__GT_QUOTE_CACHE.set(key, {q, at: now()});
        return q;
      }finally{
        W.__GT_QUOTE_LAST_CALL = now();
      }
    })();

    W.__GT_QUOTE_PENDING.set(key, p);
    try{ return await p; }
    finally{ W.__GT_QUOTE_PENDING.delete(key); }
  }

  // === Module-local code ===
  const KEY = "portfele_firmy_v1";
  const $ = (s, r=document)=> r.querySelector(s);
  const fmtMoney = (n, cur='PLN') => {
    const x = Number(n); if(!isFinite(x)) return "—";
    try{ return new Intl.NumberFormat('pl-PL',{style:'currency', currency:cur, maximumFractionDigits:2, minimumFractionDigits:2}).format(x); }
    catch(e){ return x.toFixed(2)+' '+cur; }
  };
  const fmtNum = (n,d=2)=> isFinite(Number(n)) ? Number(n).toFixed(d) : '—';

  const ST = {
    DB:null, base:'PLN', token:'', poll:45, FX:{PLN:{PLN:1, fxUsdplnAt:0}}, timer:null, noApi:false, ttlMs:60*1000
  };

  function loadPrefs(){
  try{
    ST.periodKey = getPeriodKey();
    const sel = document.getElementById('go-period');
    if(sel){ sel.value = ST.periodKey; }
    ST.periodRange = getPeriodRange(ST.periodKey);
  }catch(_){ ST.periodKey = 'all'; ST.periodRange = getPeriodRange('all'); }

    try{ ST.DB = JSON.parse(localStorage.getItem(KEY) || '{}'); } catch(_){ ST.DB = {}; }
    if(!ST.DB || !ST.DB.settings) ST.DB = ST.DB || {settings:{}};
    ST.base  = localStorage.getItem('global_overview_base') || 'PLN';
    ST.poll  = Number(localStorage.getItem('global_overview_poll')|| (ST.DB.settings?.pricePollSeconds || 45)) || 45;
    const displayToken = (localStorage.getItem('global_overview_tok')
      || ST.DB.settings?.finnhubTokenWishlist
      || ST.DB.settings?.finnhubToken
      || ""
    ).trim();
    ST.token = displayToken || FINNHUB_DEMO_TOKEN;
    ST.noApi = localStorage.getItem('global_overview_noapi') === '1';
    $('#go-base').value = ST.base;
    $('#go-poll').value = ST.poll;
    $('#go-token').value = displayToken;

    $('#go-no-api').checked = ST.noApi;
    $('#go-ttl').textContent = Math.round(ST.ttlMs/1000)+'s';
  }

  
async function ensureFx(from, to){
  try{
    if(!ST.FX[from]) ST.FX[from] = {};
    const pairKey = from + '->' + to;
    const nowTs = Date.now();

    // same-currency shortcut
    if(from===to){
      ST.FX[from][to] = 1;
      try{ paintFx(); }catch(_){}
      return 1;
    }

    // Manual override for USD->PLN/PLN->USD (set via "Ustaw")
    try{
      if ((from==='USD' && to==='PLN') || (from==='PLN' && to==='USD')){
        const m = Number(localStorage.getItem('global_overview_fx_usdpln') || '');
        if (Number.isFinite(m) && m>0){
          // respect manual override
          ST.FX['USD'] = ST.FX['USD'] || {};
          ST.FX['PLN'] = ST.FX['PLN'] || {};
          ST.FX['USD']['PLN'] = m;
          ST.FX['PLN']['USD'] = 1/m;
          try{ paintFx(); }catch(_){}
          return (from==='USD') ? m : (1/m);
        }
      }
    }catch(_){}

    // For USD<->PLN refresh using TTL (defaults to ST.ttlMs)
    const isUsdPln = (from==='USD' && to==='PLN') || (from==='PLN' && to==='USD');
    const ttlMs = Math.max(10_000, Number(ST.ttlMs)||60_000);
    const cached = ST.FX[from] && ST.FX[from][to];
    const freshEnough = isUsdPln ? (nowTs - (ST.fxUsdplnAt||0) < ttlMs) : Number.isFinite(cached);

    if (Number.isFinite(cached) && freshEnough){
      return ST.FX[from][to];
    }

    // Decide fetch direction (normalize to USD->PLN if pair is PLN->USD)
    let a = from, b = to, invert = false;
    if (from==='PLN' && to==='USD'){ a='USD'; b='PLN'; invert = true; }

    let rate = null;

    // Try Frankfurter (ECB) first — CORS-friendly, no API key
    try{
      if (a==='USD' && b==='PLN'){
        const r = await fetch('https://api.frankfurter.app/latest?from=USD&to=PLN');
        if (r.ok){
          const j = await r.json();
          rate = Number(j && j.rates && j.rates.PLN);
        }
      }
    }catch(_){}

    // Fallback: exchangerate.host (also CORS-friendly)
    if(!Number.isFinite(rate) || rate<=0){
      try{
        const url = `https://api.exchangerate.host/latest?base=${encodeURIComponent(a)}&symbols=${encodeURIComponent(b)}`;
        const j = await (await fetch(url)).json().catch(()=>null);
        rate = Number(j && j.rates && j.rates[b]);
      }catch(_){}
    }

    // Finalize
    if (Number.isFinite(rate) && rate>0){
      const final = invert ? (1/rate) : rate;
      if(!ST.FX[from]) ST.FX[from] = {};
      if(!ST.FX[to]) ST.FX[to] = {};
      ST.FX[from][to] = final;
      ST.FX[to][from] = 1/final;

      // If specifically USD->PLN pair, update input and remember timestamp
      try{
        if ((from==='USD' && to==='PLN') || (from==='PLN' && to==='USD')){
          ST.fxUsdplnAt = nowTs;
          const v = (from==='USD') ? final : (1/final);
          // show in the input (without tripping manual override)
          const inp = document.getElementById('go-fx-usdpln');
          if (inp) inp.value = (Number(v)||0).toFixed(4);
          // store for convenience in the UI input helper
          try{ localStorage.setItem('gt_fx_usd_pln', String(v)); }catch(_){}
        }
      }catch(_){}

      try{ paintFx(); }catch(_){}
      return ST.FX[from][to];
    }

    // Fallback to previous or 1 if all failed
    if (Number.isFinite(cached)) return cached;
    ST.FX[from][to] = 1;
    try{ paintFx(); }catch(_){}
    return 1;
  }catch(e){
    console.warn('FX error', e);
    return 1;
  }
}
function paintFx(){
    try{
      const parts = [];
      for(const f in ST.FX){ for(const t in ST.FX[f]){ parts.push(`${f}->${t}:${fmtNum(ST.FX[f][t])}`); } }
      $('#go-fx').textContent = parts.join('  |  ') || '—';
    }catch(_){}
  }

  async function fetchAllQuotesCoop(){
    const set = new Set();
    const pfs = Array.isArray(ST.DB.portfolios) ? ST.DB.portfolios : [];
    for(const pf of pfs){ for(const t of Object.keys(pf.holdings||{})){ set.add(String(t).trim().toUpperCase()); } }
    const tickers = Array.from(set);
    const token = ($('#go-token').value || ST.token || '').trim();
    const noApi = $('#go-no-api').checked || !token;

    // fetch only stale/missing; respect queue, dedup with app
    const promises = tickers.map(sym => fetchQuoteCoop(sym, token, { noApi, ttlMs: ST.ttlMs }));
    const quotes = await Promise.all(promises);
    // map to object for later reads
    const obj = {};
    tickers.forEach((t,i)=>{ const q = quotes[i]||null; if(q) obj[t]=q; });
    return obj;
  }

  function realizedSums(pf, range){
    let g=0,t=0,n=0;
    for(const tx of (pf.transactions||[])){
      if(tx.type==='sell'){
        try{ const ms = toMs(tx && tx.date); if(range && !inRangeMs(ms, range)) continue; }catch(_){}
        const gross = Number(tx.grossPL)||0;
        const tax   = Number(tx.tax)|| (gross>0 ? gross*(ST.DB.settings?.taxRate||0.19) : 0);
        const net   = Number(tx.netPL)|| (gross - tax);
        g+=gross; t+=tax; n+=net;
      }
    }
    return {gross:g, tax:t, net:n};
  }

  async function computePortfolio(pf, Q, range){
    const base = $('#go-base').value || ST.base || 'PLN';
    const fx = await ensureFx(pf.currency||'PLN', base);
    let holdings=0, cost=0, day=0;
    const positions=[];
    for(const [ticker,book] of Object.entries(pf.holdings||{})){
      let qty=0,cst=0,avg=0;
      for(const lot of (book.lots||[])){ const q=Number(lot.qty)||0; const uc=Number(lot.unitCost)||0; qty+=q; cst+=q*uc; }
      avg = qty>0?cst/qty:0;
      const qd = (Q && Q[ticker]) ? Q[ticker] : null;
      const price = qd && isFinite(qd.c) ? Number(qd.c) : avg;
      const val = qty*price; holdings+=val; cost+=cst;
      if(qd && isFinite(qd.d)) day += qty*Number(qd.d);
      positions.push({ticker, qty, avg, cost:cst, price, value:val, d:qd?.d??null, dp:qd?.dp??null});
    }
    const cash = Number(pf.cash)||0;
    const {gross, tax, net} = realizedSums(pf, range);
    return {
      pf, fx,
      cashNat: cash, cashBase: cash*fx,
      holdingsNat: holdings, holdingsBase: holdings*fx,
      equityNat: cash+holdings, equityBase:(cash+holdings)*fx,
      costNat: cost, costBase: cost*fx,
      unrealNat: holdings-cost, unrealBase:(holdings-cost)*fx,
      unrealPct: cost>0? (holdings-cost)/cost : null,
      dayMoveNat: day, dayMoveBase: day*fx,
      realizedGrossNat:gross, realizedTaxNat:tax, realizedNetNat:net,
      realizedGrossBase:gross*fx, realizedTaxBase:tax*fx, realizedNetBase:net*fx,
      positions
    };
  }

  async function computeAll(Q, range){
    const base = $('#go-base').value || 'PLN';
    const pfs = Array.isArray(ST.DB.portfolios) ? ST.DB.portfolios : [];
    const results=[];
    let tot = {holdingsBase:0,cashBase:0,equityBase:0,costBase:0,unrealBase:0,dayMoveBase:0,realizedGrossBase:0,realizedTaxBase:0,realizedNetBase:0};
    for(const pf of pfs){
      const r = await computePortfolio(pf, Q, range);
      results.push(r);
      tot.holdingsBase+=r.holdingsBase; tot.cashBase+=r.cashBase; tot.equityBase+=r.equityBase;
      tot.costBase+=r.costBase; tot.unrealBase+=r.unrealBase; tot.dayMoveBase+=r.dayMoveBase;
      tot.realizedGrossBase+=r.realizedGrossBase; tot.realizedTaxBase+=r.realizedTaxBase; tot.realizedNetBase+=r.realizedNetBase;
    }
    const unrealPct = tot.costBase>0 ? (tot.unrealBase/tot.costBase) : null;
    return {base, results, tot, unrealPct};
  }

  function paintTotals({base, tot, unrealPct}){
    $('#go-tot-hold').textContent = fmtMoney(tot.holdingsBase, base);
    $('#go-tot-cash').textContent = fmtMoney(tot.cashBase, base);
    $('#go-tot-eq').textContent = fmtMoney(tot.equityBase, base);
    $('#go-tot-unr').textContent = fmtMoney(tot.unrealBase, base);
    const pct = $('#go-tot-unr-pct'); pct.textContent = unrealPct===null?'—':(unrealPct*100).toFixed(2)+'%';
    pct.className = 'go-badge ' + (unrealPct>0?'go-pos':(unrealPct<0?'go-neg':''));
    $('#go-day').textContent = 'Δ dzienny: ' + fmtMoney(tot.dayMoveBase, base);
    $('#go-real-g').textContent = fmtMoney(tot.realizedGrossBase, base);
    $('#go-real-tax').textContent = fmtMoney(tot.realizedTaxBase, base);
    $('#go-real-n').textContent = fmtMoney(tot.realizedNetBase, base);
  }

  function renderPositionsTable(positions, cur){
    if(!positions || !positions.length) return `<div class="go-muted go-mini">Brak pozycji.</div>`;
    const rows = positions.map(p=>{
      const pl = (p.value - p.cost);
      const dp = isFinite(p.dp) ? `<span class="go-badge ${p.dp>=0?'go-pos':'go-neg'}">${Number(p.dp).toFixed(2)}%</span>` : '—';
      const plCls = pl>0?'go-pos':(pl<0?'go-neg':'');
      return `<tr>
        <td class="go-ticker">${escapeHtml(p.ticker)}</td>
        <td>${Number(p.qty).toFixed(2)}</td>
        <td>${fmtMoney(p.avg, cur)}</td>
        <td>${fmtMoney(p.cost, cur)}</td>
        <td>${isFinite(p.price)?Number(p.price).toFixed(2):'—'}</td>
        <td>${fmtMoney(p.value, cur)}</td>
        <td class="${plCls}">${fmtMoney(pl, cur)}</td>
        <td>${isFinite(p.cost)&&p.cost>0?(((p.value-p.cost)/p.cost)*100).toFixed(2)+'%':'—'}</td>
        <td>${dp}</td>
      </tr>`;
    }).join('');
    return `<div class="table-wrap" style="margin-top:8px">
      <table>
        <thead><tr><th>Ticker</th><th>Ilość</th><th>Śr. koszt</th><th>Koszt własny</th><th>Kurs</th><th>Wartość</th><th>P/L</th><th>%</th><th>Δ dzienny</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    </div>`;
  }
  function escapeHtml(s){ const t=document.createElement('textarea'); t.textContent=String(s||''); return t.innerHTML; }

  function buildAllPositions(resList){
    const rows = [];
    for (let i=0;i<resList.length;i++){ const r = resList[i];
      for(const p of r.positions){
        rows.push({ ticker: p.ticker, pf: r.pf.name||'—', qty: p.qty, avg: p.avg, cost: p.cost,
          price: isFinite(p.price)?p.price:null, value: p.value, pl: p.value-p.cost,
          pct: p.cost>0? (p.value-p.cost)/p.cost : null, dp: isFinite(p.dp)?p.dp:null, currency: r.pf.currency||'PLN', pfIdx: i
        });
      }
    }
    return rows;
  }

  function paintPortfolios(resList, base){
    const tbody = $('#go-pf-body'); tbody.innerHTML='';
    if(!resList.length){ tbody.innerHTML = '<tr><td colspan="10" class="go-muted">Brak danych…</td></tr>'; return; }
    for(const r of resList){
      const unrealCls = r.unrealBase>0 ? 'go-pos' : (r.unrealBase<0 ? 'go-neg' : '');
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><details><summary>${escapeHtml(r.pf.name||'—')}</summary>${renderPositionsTable(r.positions, r.pf.currency)}</details></td>
        <td>${r.pf.currency||'PLN'}</td>
        <td>${fmtMoney(r.cashNat, r.pf.currency)}</td>
        <td>${fmtMoney(r.holdingsNat, r.pf.currency)}</td>
        <td><b>${fmtMoney(r.equityNat, r.pf.currency)}</b></td>
        <td>${fmtMoney(r.equityBase, base)}</td>
        <td>${fmtMoney(r.costNat, r.pf.currency)}</td>
        <td class="${unrealCls}">${fmtMoney(r.unrealNat, r.pf.currency)}</td>
        <td>${r.unrealPct===null?'—':(r.unrealPct*100).toFixed(2)+'%'}</td>
        <td>${fmtMoney(r.realizedNetNat, r.pf.currency)}</td>
      `;
      tbody.appendChild(tr);
    }
  }

  
  // === Expandable details for aggregated positions ===
  function renderTickerDetails(pf, ticker){
    try{
      function readLastPrice(t){
        try{
          const key = String(t||'').toUpperCase();
          const fromCache = (window.__GT_QUOTE_CACHE && window.__GT_QUOTE_CACHE.get) ? window.__GT_QUOTE_CACHE.get(key) : null;
          const q = fromCache && fromCache.q ? fromCache.q : null;
          if(q && isFinite(q.c)) return Number(q.c);
        }catch(_){}
        try{
          const K = String(t||'').toUpperCase();
          const q2 = (window.QUOTES && window.QUOTES[K]) ? window.QUOTES[K] : null;
          if(q2 && isFinite(q2.price)) return Number(q2.price);
        }catch(_){}
        return null;
      }
      const book = (pf && pf.holdings && pf.holdings[ticker]) ? pf.holdings[ticker] : null;
      const lots = Array.isArray(book && book.lots) ? book.lots : [];
      const cur = pf.currency || 'PLN';
      const last = readLastPrice(ticker);
    const rows = lots.map(l=>{
        const qty = Number(l.qty)||0;
        const uc  = Number(l.unitCost)||0;
        const cost = qty*uc;
        const price = (last!=null && isFinite(last)) ? Number(last) : uc;
        const val = qty*price;
        const pl = val - cost;
        const pct = cost>0 ? (pl/cost)*100 : null;
        const date = l.date || '';
        const note = l.note ? String(l.note) : '';
        return `<tr>
          <td>${escapeHtml(date)}</td>
          <td>${qty.toFixed(2)}</td>
          <td>${fmtMoney(uc, cur)}</td>
          <td>${fmtMoney(cost, cur)}</td>
          <td>${isFinite(price)?price.toFixed(2):'—'}</td>
          <td>${fmtMoney(val, cur)}</td>
          <td class="${pl>0?'go-pos':(pl<0?'go-neg':'')}">${fmtMoney(pl, cur)}</td>
          <td>${pct===null?'—':pct.toFixed(2)+'%'}</td>
          <td class="go-mini">${escapeHtml(note)}</td>
        </tr>`;
      }).join('') || `<tr><td colspan="9" class="go-mini go-muted center">Brak transakcji/partii dla ${escapeHtml(ticker)}</td></tr>`;

      return `
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>Data</th><th>Ilość</th><th>Cena zakupu</th><th>Koszt</th><th>Kurs</th><th>Wartość</th><th>Unreal. P/L</th><th>%</th><th>Notatka</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
    }catch(e){
      console.warn('renderTickerDetails error', e);
      return `<div class="go-mini go-muted">Błąd generowania szczegółów.</div>`;
    }
  }
function paintPositions(resList){
    const tbody = $('#go-pos-body');
    const filter = ($('#go-filter').value||'').trim().toUpperCase();
    const rows = buildAllPositions(resList).filter(r=>{
      if(!filter) return true;
      const wantGain = filter.includes('ZYSK>0');
      const wantLoss = filter.includes('STRATA>0');
      const pfQuery = /PF:([^ ,]+)/.exec(filter);
      const hasTicker = r.ticker.toUpperCase().includes(filter) || r.pf.toUpperCase().includes(filter);
      const pfMatch = pfQuery ? r.pf.toUpperCase().includes(pfQuery[1].toUpperCase()) : true;
      const byGain = wantGain ? (r.pl>0) : true;
      const byLoss = wantLoss ? (r.pl<0) : true;
      return (hasTicker || pfMatch) && byGain && byLoss;
    });

    tbody.innerHTML='';
    if(!rows.length){ tbody.innerHTML='<tr><td colspan="10" class="go-muted">Brak pozycji…</td></tr>'; return; }
    for(const r of rows){
      const plCls = r.pl>0?'go-pos':(r.pl<0?'go-neg':'');
      const dp = r.dp===null ? '—' : `<span class="go-badge ${r.dp>=0?'go-pos':'go-neg'}">${Number(r.dp).toFixed(2)}%</span>`;
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="go-ticker">${escapeHtml(r.ticker)}</td>
        <td>${escapeHtml(r.pf)}</td>
        <td>${Number(r.qty).toFixed(2)}</td>
        <td>${fmtMoney(r.avg, r.currency)}</td>
        <td>${fmtMoney(r.cost, r.currency)}</td>
        <td>${r.price===null?'—':Number(r.price).toFixed(2)}</td>
        <td>${fmtMoney(r.value, r.currency)}</td>
        <td class="${plCls}">${fmtMoney(r.pl, r.currency)}</td>
        <td>${r.pct===null?'—':(r.pct*100).toFixed(2)+'%'}</td>
        <td>${dp}</td>
      `;
      tbody.appendChild(tr);
    
      // attach expand-on-click for details
      tr.dataset.ticker = r.ticker;
      tr.dataset.pfIdx = String(r.pfIdx ?? -1);
      tr.style.cursor = 'pointer';
      tr.addEventListener('click', function(ev){
        if(ev.target && (ev.target.closest('button') || ev.target.closest('a'))) return;
        const existing = tr.nextElementSibling;
        if(existing && existing.classList.contains('go-detail-row')){
          existing.remove();
          return;
        }
        const idx = Number(tr.dataset.pfIdx);
        const ticker = tr.dataset.ticker;
        const pf = (resList && idx>=0 && resList[idx]) ? resList[idx].pf : null;
        const detail = document.createElement('tr');
        detail.className = 'go-detail-row';
        const colSpan = tr.children.length;
        detail.innerHTML = `<td colspan="${colSpan}" style="background:rgba(148,163,184,.08);padding:8px 12px;border-top:1px dashed #334155">
          ${renderTickerDetails(pf, ticker)}
        </td>`;
        tr.after(detail);
      });
    }
    
  }


  
  /* === [GO Extra Stats] avg holding time & avg % profit per position (closed trades) — ROBUST (replay) === */
  function computeClosedTradeStats(range){
  try{ ST.tpCount = 0; }catch(_){}
    try{
      // Prefer app context ST.DB (used w Global Overview), fallback to DB/window.DB
      const DBctx = (typeof ST!=='undefined' && ST && ST.DB) ? ST.DB
                  : ((typeof DB!=='undefined' && DB) ? DB : (window.DB||{}));
      const portfolios = Array.isArray(DBctx.portfolios) ? DBctx.portfolios : [];
      let samples = 0, sumDays = 0, sumPct = 0; let tpCountTx = 0;// Helper to parse date safely
      const toMs = (d)=>{
        try{
          if(!d) return NaN;
          // Accept ISO string or Date object or Firestore timestamp-like {seconds}
          if (d instanceof Date) return d.getTime();
          if (typeof d === 'object' && d !== null && Number.isFinite(d.seconds)) return d.seconds*1000;
          const ms = Date.parse(d);
          return Number.isFinite(ms) ? ms : NaN;
        }catch(_){ return NaN; }
      };

      // Iterate each portfolio independently
      for(const pf of portfolios){
        if(!pf) continue;
        const txs = Array.isArray(pf.transactions) ? pf.transactions.slice() : [];
        // CHRONOLOGICAL (oldest -> newest)
        const chrono = txs.reverse();

        // Minimal in-memory holdings book per ticker: FIFO queue of lots {lotId, dateMs, unitCost, qty}
        const book = Object.create(null);

        // Pre-index buy info by lotId for fast lookup when lotLinks exist
        const buyIdx = new Map();

        const pushLot = (ticker, lotId, dateVal, unitCost, qty)=>{
          const dateMs = toMs(dateVal);
          if(!Number.isFinite(dateMs) || !Number.isFinite(unitCost) || unitCost<=0 || !Number.isFinite(qty) || qty<=0) return;
          const t = (ticker||'').trim().toUpperCase(); if(!t) return;
          (book[t] ||= []).push({lotId, dateMs, unitCost, qty});
          buyIdx.set(lotId, {dateMs, unitCost}); // also index
        };

        for(const tx of chrono){
          if(!tx || !tx.type) continue;
          const t = tx.type;
          if(t==='buy'){
            const qty  = Number(tx.qty)||0;
            const price= Number(tx.price)||0;
            const fees = Number(tx.fees)||0;
            const lotId= tx.lotId || (tx.id ? `lot_${tx.id}` : null);
            const unitCost = qty>0 ? (price + fees/Math.max(qty,1)) : price;
            pushLot(tx.ticker, lotId, tx.date, unitCost, qty);
          }else if(t==='transfer_company_in'){
            const qty  = Number(tx.qty)||0;
            const lotId= tx.newLotId || tx.lotId || (tx.id ? `lot_${tx.id}` : null);
            const unitCost = Number(tx.unitCost ?? tx.price ?? 0);
            pushLot(tx.ticker, lotId, tx.date, unitCost, qty);
          }else if(t==='sell'){
            // Count TP as 1 per SELL transaction (within selected period)
            try{ if(inRangeMs(toMs(tx.date), range)) tpCountTx++; }catch(_){/*noop*/}

            // Count TP as 1 per SELL transaction (within selected period)
            try{ if(inRangeMs(toMs(tx.date), range)) tpCountTx++; }catch(_){/*noop*/}

            const ticker = (tx.ticker||'').trim().toUpperCase();
            const sellDateMs = toMs(tx.date);
            const sellPrice  = Number(tx.price ?? tx.sellPrice ?? 0);
            let remainingQty = Number(tx.qty)||0;
            if(!ticker || !Number.isFinite(sellDateMs) || !Number.isFinite(sellPrice) || sellPrice<=0) continue;

            // 1) Prefer precise allocations if they exist
            const links = Array.isArray(tx.lotLinks) ? tx.lotLinks : [];
            if(links.length>0){
              for(const link of links){
                const info = link ? buyIdx.get(link.lotId) : null;
                if(!info || !Number.isFinite(info.dateMs) || !Number.isFinite(info.unitCost) || info.unitCost<=0) continue;
                const days = Math.max(0, (sellDateMs - info.dateMs)/86400000);
                const pct  = ((sellPrice - info.unitCost)/info.unitCost)*100;
                if(!inRangeMs(sellDateMs ?? toMs(tx.date), range)) { /* skip out-of-range */ } else { sumDays += days; sumPct += pct; samples += 1;  }
              }
              continue; // done with this sell
            }

            // 2) Fallback: reconstruct FIFO from current book
            const qlots = book[ticker] || [];
            let need = Math.max(0, remainingQty);
            let i = 0;
            while(need>0 && i<qlots.length){
              const lot = qlots[i];
              const take = Math.min(need, lot.qty);
              if(take>0 && Number.isFinite(lot.dateMs) && Number.isFinite(lot.unitCost) && lot.unitCost>0){
                const days = Math.max(0, (sellDateMs - lot.dateMs)/86400000);
                const pct  = ((sellPrice - lot.unitCost)/lot.unitCost)*100;
                if(!inRangeMs(sellDateMs ?? toMs(tx.date), range)) { /* skip out-of-range */ } else { sumDays += days; sumPct += pct; samples += 1;  }
                lot.qty -= take;
                need -= take;
                if(lot.qty<=0){ i++; }
              }else{
                i++; // skip broken lot
              }
            }
            // Remove depleted lots
            if(i>0) book[ticker] = qlots.slice(i).filter(L=>L.qty>0);
          }
        }
      }

      return { avgDays: samples ? (sumDays/samples) : null, avgPct: samples ? (sumPct/samples) : null, samples, tpCountTx };
    }catch(e){
      console.warn('[GO] computeClosedTradeStats (robust) failed', e);
      return { avgDays: null, avgPct: null, samples: 0, tpCountTx: 0 };
    }
  }
  function paintExtraStats(stats){
    try{
      const elH = document.getElementById('go-avg-hold');
      const elP = document.getElementById('go-avg-pct');
      if(elH){ elH.textContent = (stats && Number.isFinite(stats.avgDays)) ? (Number(stats.avgDays).toFixed(1)+' d') : '—'; }
      if(elP){ elP.textContent = (stats && Number.isFinite(stats.avgPct))  ? (Number(stats.avgPct).toFixed(2)+'%') : '—'; }
      if(stats && stats.samples===0){
        if(elH) elH.title = 'Brak zamkniętych transakcji do wyliczenia lub brak dopasowań';
        if(elP) elP.title = 'Brak zamkniętych transakcji do wyliczenia lub brak dopasowań';
      }
    }catch(_){}
  }
  // Fallback/robust TP counter: counts SELL transactions within range directly from DB
  function countSellTxInRange(DBctx, range){
    try{
      const db = DBctx || (window.ST && ST.DB) || window.DB || {};
      const pfs = Array.isArray(db.portfolios) ? db.portfolios : [];
      let n = 0;
      for(const pf of pfs){
        const txs = Array.isArray(pf.transactions) ? pf.transactions : [];
        for(const tx of txs){
          if(tx && tx.type === 'sell'){
            const d = Date.parse(tx.date || '');
            if(Number.isFinite(d) && (!range || (d >= (range.start ?? -Infinity) && d <= (range.end ?? Infinity)))){
              n++;
            }
          }
        }
      }
      return n;
    }catch(_){ return 0; }
  }
// === [GO] LINIOWY WYKRES: Wkład (blue) vs Wartość (green) =====================
let __GO_CHART_CACHE = null;
function __go_toMs(d){ try{ if(typeof d === 'number') return d; return Date.parse(d || '1970-01-01'); }catch(_){ return 0; } }
function __go_floorDay(ms){ const dt = new Date(ms); dt.setHours(0,0,0,0); return dt.getTime(); }
function __go_fmt(d){ try{ return new Date(d).toLocaleDateString(); }catch(_){ return String(d); } }
function __go_sum(a){ return (a||[]).reduce((x,y)=>x+(+y||0),0); }

function __go_wap(lots){
  try{
    if(!Array.isArray(lots) || !lots.length) return 0;
    let sQty=0, sVal=0;
    for(const l of lots){ const q=Number(l.qty)||0, p=Number(l.price)||0; sQty+=q; sVal+=q*p; }
    return sQty>0 ? (sVal/sQty) : 0;
  }catch(_){ return 0; }
}


async function computeGlobalLineSeries(Q, periodRange, base){
  const startMs = __go_floorDay(periodRange.start);
  const endMs   = __go_floorDay(periodRange.end);
  const seriesBlue = []; // wkład
  const seriesGreen = []; // equity
  const pfStates = new Map();  // pf.id -> { cash, holdings: { TKR: {qty} } }
  const pfFx = new Map();      // pf.id -> fx to base
  const allTx = [];

  // Collect & prepare
  for(const pf of (ST.DB?.portfolios||[])){
    pfStates.set(pf.id||pf.name||pf.ticker||Math.random().toString(36).slice(2), { cash: 0, holdings: {} });
    const fx = await ensureFx(pf.currency||'PLN', base);
    pfFx.set(pf.id||pf.name||pf.ticker, fx);
    const txs = (pf.transactions||[]).map(t=>({...t, __pf: pf}));
    allTx.push(...txs);
  }
  // Sort ascending by date
  allTx.sort((a,b)=> __go_toMs(a.date) - __go_toMs(b.date));

  // Helpers that reuse existing engine
  function equityNow(){
    let total = 0;
    for(const pf of (ST.DB?.portfolios||[])){
      const st = pfStates.get(pf.id||pf.name||pf.ticker);
      const fx = pfFx.get(pf.id||pf.name||pf.ticker) || 1;
      total += (st.cash||0) * fx;
      for(const [tk, book] of Object.entries(st.holdings||{})){
        let price = (Q[tk]?.price ?? 0);
        if(!(price>0)){
          const lots = (book && Array.isArray(book.lots)) ? book.lots : [];
          const wap = __go_wap(lots);
          price = wap>0 ? wap : 0;
        }
        const qty = (book && Array.isArray(book.lots) && book.lots.length)
          ? __go_sum(book.lots.map(l=> +l.qty||0))
          : Number((book&&book.qty)||0);
        total += qty * price * fx;
      }
    }
    return total;
  }
  function applyTxToState(tx){
    const pf = tx.__pf;
    const st = pfStates.get(pf.id||pf.name||pf.ticker);
    if(!st) return;
    // cash-only flows
    if(tx.type==="deposit" || tx.type==="withdraw" || tx.type==="transfer_in" || tx.type==="transfer_out"){
      (typeof applyCash==='function' ? applyCash : __go_applyCashShim)(st, tx.type, tx.amount||0);
      return;
    }
    if(tx.type==="buy"){ try{ if(typeof ensureBuyLotIdInTx==='function') ensureBuyLotIdInTx(tx);}catch(_){}; (typeof applyBuy==='function' ? applyBuy : __go_applyBuy)(st, pf, tx); return; }
    if(tx.type==="sell"){ (typeof applySell==='function' ? applySell : __go_applySell)(st, pf, tx); return; }
    if(tx.type==="transfer_company_in"){ (typeof applyTransferCompanyIn==='function' ? applyTransferCompanyIn : __go_applyTransferCompanyIn)(st, pf, tx); return; }
    if(tx.type==="transfer_company_out"){ (typeof applyTransferCompanyOut==='function' ? applyTransferCompanyOut : __go_applyTransferCompanyOut)(st, pf, tx); return; }
    // ignore unknowns
  }

  // Build baseline up to start
  let wkładBase = 0;
  for(const tx of allTx){
    const tms = __go_toMs(tx.date);
    if(tms < startMs){
      // contributions
      if(tx.type==="deposit" || tx.type==="transfer_in"){
        wkładBase += (Number(tx.amount)||0) * (pfFx.get(tx.__pf.id)||1);
      }else if(tx.type==="withdraw" || tx.type==="transfer_out"){
        wkładBase -= (Number(tx.amount)||0) * (pfFx.get(tx.__pf.id)||1);
      }
      applyTxToState(tx);
    }else{
      break;
    }
  }
  // Snapshot at start
  seriesBlue.push({ x:startMs, y: wkładBase });
  seriesGreen.push({ x:startMs, y: equityNow() });

  // Apply in-range
  for(const tx of allTx){
    const tms = __go_toMs(tx.date);
    if(tms < startMs || tms > endMs) continue;
    if(tx.type==="deposit" || tx.type==="transfer_in"){
      wkładBase += (Number(tx.amount)||0) * (pfFx.get(tx.__pf.id)||1);
    }else if(tx.type==="withdraw" || tx.type==="transfer_out"){
      wkładBase -= (Number(tx.amount)||0) * (pfFx.get(tx.__pf.id)||1);
    }
    applyTxToState(tx);
    const day = __go_floorDay(tms);
    seriesBlue.push({ x: day, y: wkładBase });
    seriesGreen.push({ x: day, y: equityNow() });
  }

  // Force final point at end
  seriesBlue.push({ x:endMs, y: wkładBase });
  seriesGreen.push({ x:endMs, y: equityNow() });

  // Bounds
  const ys = [...seriesBlue, ...seriesGreen].map(p=>p.y);
  let minY = Math.min(...ys, 0);
  let maxY = Math.max(...ys, 0);
  if(!ys.length || !Number.isFinite(minY) || !Number.isFinite(maxY)){
      minY = 0; maxY = 1;
  }
  if(maxY - minY < 1e-6){ maxY = minY + 1; } // avoid 0 height

  return { seriesBlue, seriesGreen, bounds:{ minX:startMs, maxX:endMs, minY, maxY } };
}

function __go_fmtCurrency(v, code){ try{ if(typeof fmtCurrency==='function') return fmtCurrency(v, code); }catch(_){ } try{ return new Intl.NumberFormat(undefined,{style:'currency',currency:(code||'PLN')}).format(v||0);}catch(_){ return String(Math.round((v||0)*100)/100)+' '+(code||''); } }

function drawGlobalLineChart(cache){
    try{
      const base = document.getElementById('go-base')?.value || 'PLN';
      const b = cache?.seriesBlue || [];
      const g = cache?.seriesGreen || [];
      const lastB = b.length ? b[b.length-1].y : 0;
      const lastG = g.length ? g[g.length-1].y : 0;
      const ib = document.getElementById('go-info-blue'); if(ib) ib.textContent = 'Wkład: ' + __go_fmtCurrency(lastB, base);
      const ig = document.getElementById('go-info-green'); if(ig) ig.textContent = 'Wartość: ' + __go_fmtCurrency(lastG, base);
    }catch(_){}

    const wrap = document.querySelector('#go-line-chart-card .go-chart-wrap') || document.querySelector('.go-chart-wrap');
    const canvas = document.getElementById('go-line-chart');
    const empty = document.getElementById('go-chart-empty');
    const tip = document.getElementById('go-chart-tooltip-imp');
    if(!wrap || !canvas || !empty) return;

    if(!cache || !cache.seriesBlue?.length || !cache.seriesGreen?.length){
      empty.style.display = 'block'; canvas.style.display = 'none'; if(tip) tip.classList.remove('visible'); return;
    }
    empty.style.display = 'none'; canvas.style.display = 'block';

    const dpr = (window.devicePixelRatio||1);
    const desiredH = 820; try{ wrap.style.height = desiredH+'px'; wrap.style.minHeight = '820px'; wrap.style.maxHeight = desiredH+'px'; }catch(_){}
const w = Math.max(10, wrap.clientWidth);
const h = desiredH;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    const overlay = document.getElementById('go-line-chart-overlay');
    let octx = null;
    if(overlay){
      overlay.width = Math.floor(w * dpr);
      overlay.height = Math.floor(h * dpr);
      overlay.style.width = w + 'px';
      overlay.style.height = h + 'px';
      octx = overlay.getContext('2d');
      octx.setTransform(1,0,0,1,0,0);
      octx.scale(dpr, dpr);
    }


    const pad = { left: 110, right: 60, top: 56, bottom: 84 };

    const {minX, maxX} = cache.bounds || {};
const xs = (cache.seriesBlue||[]).map(p=>p.x).concat((cache.seriesGreen||[]).map(p=>p.x));
const _minX = Number.isFinite(minX) ? minX : (xs.length? Math.min(...xs):0);
const _maxX = Number.isFinite(maxX) ? maxX : (xs.length? Math.max(...xs):(_minX+1));
const allY = (cache.seriesBlue||[]).map(p=>p.y).concat((cache.seriesGreen||[]).map(p=>p.y)).filter(v=>Number.isFinite(v));
let _minY = allY.length? Math.min(...allY) : 0;
let _maxY = allY.length? Math.max(...allY) : (_minY+1);
let _rangeY = Math.max(1e-6, _maxY - _minY);
_minY = Math.max(0, _minY - _rangeY*0.20);
_maxY = _maxY + _rangeY*0.20;
_rangeY = Math.max(1e-6, _maxY - _minY);
    const X = x => pad.left + ( (x - _minX) / Math.max(1, (_maxX - _minX)) ) * (w - pad.left - pad.right);
    const Y = y => (h - pad.bottom) - ( (y - _minY) / Math.max(1e-6,(_maxY - _minY)) ) * (h - pad.top - pad.bottom);

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(0,0,w,h);

    const cw = w - pad.left - pad.right;
    const ch = h - pad.top - pad.bottom;

    // Grid
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
    ctx.lineWidth = 1;
    for(let i=0;i<=6;i++){
      const yy = pad.top + (ch/6)*i;
      ctx.beginPath(); ctx.moveTo(pad.left, yy); ctx.lineTo(w - pad.right, yy); ctx.stroke();
      const val = _maxY - (_maxY - _minY) * (i/6);
      ctx.fillStyle = '#94a3b8'; ctx.font = 'bold 13px system-ui, -apple-system, Segoe UI, Roboto';
      ctx.textAlign = 'right';
      try{
        const base = document.getElementById('go-base')?.value || 'PLN';
        ctx.fillText(__go_fmtCurrency(val, base), pad.left - 12, yy + 4);
      }catch(_){}
    }
    // Border
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 2;
    ctx.strokeRect(pad.left, pad.top, cw, ch);

    function strokeSeries(series, color, width){
      if(!series || !series.length) return;
      ctx.beginPath();
      let first = true;
      for(const p of series){
        const xx = X(p.x), yy = Y(p.y);
        if(first){ ctx.moveTo(xx,yy); first=false; } else { ctx.lineTo(xx,yy); }
      }
      ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.stroke();
    }

    strokeSeries(cache.seriesBlue, '#3b82f6', 4.6);
    strokeSeries(cache.seriesGreen, '#22c55e', 4.6);

    function drawPoints(series, fill){
      if(!series || !series.length) return;
      const r = 3.6;
      ctx.fillStyle = fill;
      for(const p of series){
        const xx = X(p.x), yy = Y(p.y);
        ctx.beginPath(); ctx.arc(xx,yy,r,0,Math.PI*2); ctx.fill();
      }
    }
    drawPoints(cache.seriesBlue, 'rgba(59,130,246,0.85)');
    drawPoints(cache.seriesGreen,'rgba(34,197,94,0.85)');

    // X labels
    const xStart = new Date(_minX), xMid = new Date((_minX+_maxX)/2), xEnd = new Date(_maxX);
    ctx.fillStyle = '#94a3b8'; ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign = 'left';
    ctx.fillText(xStart.toLocaleDateString(), pad.left, h-12);
    const midLabel = xMid.toLocaleDateString(); const midW = ctx.measureText(midLabel).width;
    ctx.fillText(midLabel, (w - midW)/2, h-12);
    const endLabel = xEnd.toLocaleDateString(); const endW = ctx.measureText(endLabel).width;
    
    // Snapshot base layer to prevent crosshair trails
    try{
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.restore();
    }catch(_){}

    // Tooltip events (attach once)

    (function attachTipHandlers(){
      if(!canvas) return;
      const b = cache.seriesBlue || [];
      const g = cache.seriesGreen || [];
      const tip = document.getElementById('go-chart-tooltip-imp');
      function showTip(ptIdx, clientX, clientY){
        if(!tip) return;
        const i = Math.max(0, Math.min(ptIdx, Math.min(b.length, g.length)-1));
        const vb = (b[i] && b[i].y) || 0;
        const vg = (g[i] && g[i].y) || 0;
        const dt = new Date((b[i] && b[i].x) || (g[i] && g[i].x) || _minX);
        const base = document.getElementById('go-base')?.value || 'PLN';
        tip.classList.add('visible');
        const d = document; 
        d.getElementById('tt-date-imp').textContent     = dt.toLocaleDateString('pl-PL');
        d.getElementById('tt-invested-imp').textContent = __go_fmtCurrency(vb, base);
        d.getElementById('tt-value-imp').textContent    = __go_fmtCurrency(vg, base);
        const profit = vg - vb;
        d.getElementById('tt-profit-imp').textContent   = __go_fmtCurrency(profit, base);
        const roi = (vb>0) ? (profit / vb * 100) : 0;
        d.getElementById('tt-roi-imp').textContent      = (roi.toFixed(2) + '%');

        const rect = canvas.getBoundingClientRect();
        let left = clientX - rect.left;
        let top  = clientY - rect.top - 140;
        if (left + 340 > rect.width) left = rect.width - 350;
        if (left < 10) left = 10;
        tip.style.left = left + 'px';
        tip.style.top  = top + 'px';
      }
      function hideTip(){ if(tip) tip.classList.remove('visible'); }

      if(!canvas.__tipBound){
        canvas.addEventListener('mousemove', (e)=>{
          // Restore base snapshot to clear previous crosshairs

          const rect = canvas.getBoundingClientRect();
          const rx = (e.clientX - rect.left) / rect.width;
          const domainX = _minX + Math.max(0, Math.min(1, rx)) * (_maxX - _minX);

          function nearestIdx(series){
            if(!series || !series.length) return -1;
            let lo = 0, hi = series.length-1;
            while(lo < hi){
              const mid = (lo + hi) >> 1;
              if(series[mid].x < domainX) lo = mid + 1; else hi = mid;
            }
            let cand = lo;
            if(lo > 0 && (Math.abs(series[lo-1].x - domainX) < Math.abs(series[lo].x - domainX))) cand = lo-1;
            return cand;
          }

          const bi = nearestIdx(b);
          const gi = nearestIdx(g);
          if(bi < 0 && gi < 0){ return hideTip(); }

          const vb = bi>=0 ? (b[bi].y||0) : 0;
          const vg = gi>=0 ? (g[gi].y||0) : 0;

          // Draw crosshair
          const cx = X(domainX);
          if(octx){ octx.clearRect(0,0,w,h); octx.strokeStyle='rgba(148,163,184,0.35)'; octx.lineWidth=1; octx.beginPath(); octx.moveTo(cx, pad.top); octx.lineTo(cx, h - pad.bottom); octx.stroke(); }

          showTip(Math.max(bi, gi), e.clientX, e.clientY, vb, vg, domainX);
        });
        canvas.addEventListener('mouseleave', ()=>{ hideTip(); if(octx){ octx.clearRect(0,0,w,h); } });
        window.addEventListener('scroll', hideTip, {passive:true});
        canvas.__tipBound = true;
      }
    })();
    }

async function paintGlobalLineChart(Q, periodRange, base){
  try{
    __GO_CHART_CACHE = await computeGlobalLineSeries(Q, periodRange, base);
    drawGlobalLineChart(__GO_CHART_CACHE);
  }catch(err){
    console.warn('[GO] Line chart error:', err);
    const empty = document.getElementById('go-chart-empty');
    const canvas = document.getElementById('go-line-chart');
    if(empty && canvas){ empty.style.display='block'; canvas.style.display='none'; }
  }
}
window.addEventListener('resize', ()=>{ try{ drawGlobalLineChart(__GO_CHART_CACHE); }catch(_){ } });

async function __go_maybeSaveDailySnapshot(comp){
  try{
    if(!comp || !comp.tot) return;
    const now = new Date();
    // Zapisujemy max raz dziennie – po godzinie 22:00
    if(now.getHours() < 22) return;

    const pad = n => (n < 10 ? '0' + n : String(n));
    const dayKey = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}`;
    const SNAP_LS_KEY = 'GO_DAILY_SNAPSHOT_LAST_DAY_V1';
    const SNAP_LOCAL_KEY = 'GO_DAILY_SNAPSHOTS_LOCAL_V1';

    try{
      const last = localStorage.getItem(SNAP_LS_KEY);
      if(last === dayKey) return;
    }catch(_){}

    const base = comp.base || (window.ST && ST.base) || 'PLN';
    const tot = comp.tot || {};
    const payload = {
      uid: null,
      base,
      dayKey,
      holdingsBase: Number(tot.holdingsBase || 0),
      cashBase: Number(tot.cashBase || 0),
      equityBase: Number(tot.equityBase || 0),
      costBase: Number(tot.costBase || 0),
      unrealBase: Number(tot.unrealBase || 0),
      unrealPct: (comp.unrealPct === null || comp.unrealPct === undefined) ? null : Number(comp.unrealPct),
      dayMoveBase: Number(tot.dayMoveBase || 0),
      realizedGrossBase: Number(tot.realizedGrossBase || 0),
      realizedTaxBase: Number(tot.realizedTaxBase || 0),
      realizedNetBase: Number(tot.realizedNetBase || 0),
      createdAtClient: now.toISOString(),
      _device: (typeof getDeviceId === 'function' ? getDeviceId() : 'unknown')
    };

    try{
      const d = new Date(now);
      d.setHours(0,0,0,0);
      payload.dateMs = d.getTime();
      payload.date = d;
    }catch(_){}

    // Próba zapisu do Firestore (jeśli dostępny)
    try{
      const ctx = await (typeof fbInit === 'function' ? fbInit() : null);
      const auth = ctx && ctx.auth;
      const db = ctx && ctx.db;
      if(auth && auth.currentUser && db){
        const uid = auth.currentUser.uid;
        payload.uid = uid;
        payload.createdAt = (firebase?.firestore?.FieldValue?.serverTimestamp && firebase.firestore.FieldValue.serverTimestamp()) || new Date();
        const docId = `${uid}_${dayKey}_${base}`;
        await db.collection('globalSnapshots').doc(docId).set(payload, { merge: true });
      }
    }catch(e){
      console.warn('[GO] daily snapshot remote failed', e);
    }

    // Zawsze trzymamy lokalny log (max 365 wpisów)
    try{
      const raw = localStorage.getItem(SNAP_LOCAL_KEY);
      let arr = [];
      if(raw){
        try{
          arr = JSON.parse(raw);
          if(!Array.isArray(arr)) arr = [];
        }catch(_){ arr = []; }
      }
      arr.push(payload);
      if(arr.length > 365) arr = arr.slice(arr.length - 365);
      localStorage.setItem(SNAP_LOCAL_KEY, JSON.stringify(arr));
      localStorage.setItem(SNAP_LS_KEY, dayKey);
    }catch(e){
      console.warn('[GO] daily snapshot local failed', e);
    }
  }catch(e){
    console.warn('[GO] daily snapshot error', e);
  }
}

// === [/GO] =====================================================================
async function refresh(){loadPrefs();
    try{ const ps = document.getElementById('go-period'); if(ps){ ST.periodKey = ps.value||ST.periodKey||'all'; ST.periodRange = getPeriodRange(ST.periodKey); } }catch(_){}
    try{ await ensureFx('USD','PLN'); }catch(_){}
    const pfs = Array.isArray(ST.DB.portfolios) ? ST.DB.portfolios : [];
    const base = $('#go-base').value || ST.base || 'PLN';
    for(const pf of pfs){ await ensureFx(pf.currency||'PLN', base); }
    const Q = await fetchAllQuotesCoop();
    const comp = await computeAll(Q, ST.periodRange);
    paintTotals(comp); paintPortfolios(comp.results, comp.base); paintPositions(comp.results);
    const extra = computeClosedTradeStats(ST.periodRange);
    try{ ST.tpCount = countSellTxInRange(ST.DB, ST.periodRange); var __tp=document.getElementById('go-tp-count'); if(__tp){ __tp.textContent = String(ST.tpCount); } }catch(_){ }     paintExtraStats(extra);
    try{ if(typeof __go_maybeSaveDailySnapshot==='function') await __go_maybeSaveDailySnapshot(comp); }catch(_){ }
    await paintGlobalLineChart(Q, ST.periodRange, base);
    return comp;
  }
  function schedule(){
    if(ST.timer) clearInterval(ST.timer);
    const sec = Math.max(5, Number($('#go-poll').value)||45);
    ST.timer = setInterval(refresh, sec*1000);
  }

  // UI events
  $('#go-fab').addEventListener('click', ()=>{ $('#go-tab-overlay').hidden=false; refresh(); schedule(); });
  $('#go-close').addEventListener('click', ()=>{ $('#go-tab-overlay').hidden=true; if(ST.timer) clearInterval(ST.timer); });
  $('#go-refresh').addEventListener('click', refresh);
  $('#go-save').addEventListener('click', ()=>{
    localStorage.setItem('global_overview_base', $('#go-base').value||'PLN');
    localStorage.setItem('global_overview_poll', String($('#go-poll').value||'45'));
    localStorage.setItem('global_overview_tok', ($('#go-token').value||'').trim());
    localStorage.setItem('global_overview_noapi', ($('#go-no-api').checked ? '1' : '0'));
    alert('Zapisano.');
    schedule();
  });
  $('#go-filter').addEventListener('input', refresh);
  const periodSel = document.getElementById('go-period');
  if(periodSel){
    periodSel.addEventListener('change', ()=>{
      try{
        ST.periodKey = periodSel.value || 'all';
        ST.periodRange = getPeriodRange(ST.periodKey);
        setPeriodKey(ST.periodKey);
      }catch(_){}
      refresh();
    });
  }

  $('#go-no-api').addEventListener('change', ()=>{
    localStorage.setItem('global_overview_noapi', ($('#go-no-api').checked ? '1' : '0'));
    refresh();
  });

  const fxInput = document.getElementById('go-fx-usdpln');
  const fxApply = document.getElementById('go-fx-apply');
  const fxClear = document.getElementById('go-fx-clear');
  if (fxApply){
    fxApply.addEventListener('click', ()=>{
      const v = parseFloat(fxInput && fxInput.value ? fxInput.value : '0');
      if (isFinite(v) && v > 0){
        if(!ST.FX['USD']) ST.FX['USD'] = {};
        if(!ST.FX['PLN']) ST.FX['PLN'] = {};
        ST.FX['USD']['PLN'] = v;
        ST.FX['PLN']['USD'] = 1/v;
        localStorage.setItem('global_overview_fx_usdpln', String(v));
        paintFx();
        // przelicz natychmiast totals
        refresh();
      }else{
        alert('Podaj dodatni kurs, np. 4.1234');
      }
    });
  }
  if (fxClear){
    fxClear.addEventListener('click', ()=>{
      localStorage.removeItem('global_overview_fx_usdpln');
      // usuwamy jedynie nadpisanie; pozostawiamy inne kursy
      try{
        if (ST.FX['USD']) delete ST.FX['USD']['PLN'];
        if (ST.FX['PLN']) delete ST.FX['PLN']['USD'];
      }catch(_){}
      paintFx();
      refresh();
    });
  }


  // === [GO Export: CSV / JSON] ===
  (function(){
    function downloadFile(name, mime, data){
      const blob = new Blob([data], {type: mime});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 1000);
    }
    function toCsvCell(v){
      if(v===null || v===undefined) return '';
      const s = String(v).replace(/"/g, '""');
      return /[;"\n,]/.test(s) ? `"${s}"` : s;
    }
    async function exportOverviewJSON(){
      try{
        const comp = await refresh(); // get fresh snapshot
        const now = new Date().toISOString();
        const positionsAgg = buildAllPositions(comp.results);
        const payload = {
          generatedAt: now,
          base: comp.base,
          totals: comp.tot,
          portfolios: comp.results.map(r => ({
            name: r.pf?.name || '—',
            currency: r.pf?.currency || 'PLN',
            equityBase: r.equityBase,
            cashBase: r.cashBase,
            holdingsBase: r.holdingsBase,
            costBase: r.costBase,
            unrealBase: r.unrealBase,
            dayMoveBase: r.dayMoveBase,
            realizedGrossBase: r.realizedGrossBase,
            realizedTaxBase: r.realizedTaxBase,
            realizedNetBase: r.realizedNetBase,
            positions: r.positions
          })),
          positionsAggregated: positionsAgg
        };
        const data = JSON.stringify(payload, null, 2);
        downloadFile(`global_overview_${now.slice(0,10)}.json`, "application/json", data);
      }catch(e){
        console.warn('[GO export json] failed', e);
        alert('Eksport JSON nie powiódł się: '+(e&&e.message?e.message:e));
      }
    }
    async function exportOverviewCSV(){
      try{
        const comp = await refresh(); // fresh snapshot
        const rows = buildAllPositions(comp.results);
        const header = ['Ticker','Portfel','Ilość','Śr. koszt','Koszt własny','Kurs','Wartość','P/L','%','Δ dzienny','Waluta'];
        const lines = [];
        lines.push(header.join(';'));
        for(const r of rows){
          const pct = (r.pct!=null && isFinite(r.pct)) ? (r.pct*100).toFixed(2) : '';
          const dp  = (r.dp!=null && isFinite(r.dp))  ? r.dp.toFixed(2) : '';
          const line = [
            toCsvCell(r.ticker),
            toCsvCell(r.pf),
            toCsvCell(Number(r.qty).toFixed(4)),
            toCsvCell(Number(r.avg).toFixed(4)),
            toCsvCell(Number(r.cost).toFixed(2)),
            toCsvCell(r.price!=null && isFinite(r.price) ? Number(r.price).toFixed(2) : ''),
            toCsvCell(Number(r.value).toFixed(2)),
            toCsvCell(Number(r.pl).toFixed(2)),
            toCsvCell(pct),
            toCsvCell(dp),
            toCsvCell(r.currency||'')
          ].join(';');
          lines.push(line);
        }
        const csv = '\ufeff' + lines.join('\n');
        const now = new Date().toISOString().slice(0,10);
        downloadFile(`global_overview_positions_${now}.csv`, "text/csv;charset=utf-8", csv);
      }catch(e){
        console.warn('[GO export csv] failed', e);
        alert('Eksport CSV nie powiódł się: '+(e&&e.message?e.message:e));
      }
    }
    const btnCsv  = document.getElementById('go-export-csv');
    const btnJson = document.getElementById('go-export-json');
    if(btnCsv)  btnCsv.addEventListener('click', exportOverviewCSV);
    if(btnJson) btnJson.addEventListener('click', exportOverviewJSON);
  })();
})();</script>
<!-- === [/GT ADDON] Global Overview Tab === -->

<script>
// === Helper: ignore inconsistent sell transactions (non-destructive) ===
window.__ignoreInconsistentSells = function(){
  try{
    const pf = getPf(currentPfId); if(!pf) return;
    const ids = new Set();
    const errs = Array.isArray(pf.__errors) ? pf.__errors : [];
    // Pick sells only
    for(const e of errs){
      if(e && /Sprzedaż bez pozycji|Brak partii/.test(e.message||'')){
        // find matching tx by ticker and date (best effort)
        const candidates = (pf.transactions||[]).filter(t => t.type==='sell' && (t.ticker||'').toUpperCase()===(e.ticker||'').toUpperCase());
        // mark all sells for this ticker that would error
        for(const t of candidates){ ids.add(t.id); }
      }
    }
    if(!ids.size){ alert('Brak sprzedaży do zignorowania.'); return; }
    const ok = confirm('Zignorować '+ids.size+' transakcji sprzedaży, które są niespójne? (można cofnąć ↩️ Cofnij)');
    if(!ok) return;
    try{ pushUndo({label:"Ignoruj niespójne sprzedaże", kind:'tx'}); }catch(_){}
    pf.transactions = pf.transactions.map(t => ids.has(t.id) ? Object.assign({}, t, {ignore:true, note: (t.note? t.note+' ' : '')+'[IGNORED: niespójność]'}) : t);
    pf.updatedAt = new Date().toISOString();
    rebuildPortfolio(pf); save(); render();
  }catch(e){
    alert('Operacja nie powiodła się: '+(e && e.message || e));
  }
};
</script>
<script>
(function(){
    // Interwał odświeżania: 10 sekund (10000 ms)
    const AUTO_REFRESH_INTERVAL_MS = 10000;
    let __autoRefreshTimer = null;

    function startConditionalAutoRefresh(){
        if (__autoRefreshTimer) clearInterval(__autoRefreshTimer);

        __autoRefreshTimer = setInterval(async ()=>{
            try {
                // Sprawdzenie: Czy JAKIKOLWIEK szczegół (<details>) jest otwarty?
                // Zmienna __openDetailsTickers przechowuje set otwartych tickerów.
                const detailsAreOpen = (window.__openDetailsTickers && window.__openDetailsTickers.size > 0);

                if (!detailsAreOpen) {
                    // Jeśli nie ma otwartych szczegółów, wykonaj odświeżanie
                    // Używamy 'refresh()' ponieważ pobiera ona nowe dane i maluje UI.
                    if (typeof window.refresh === 'function') {
                        await window.refresh();
                    } else if (typeof window.render === 'function') {
                        // W ostateczności użyj render(), jeśli refresh() nie jest dostępne
                        window.render();
                    }
                } else {
                    // Jeśli szczegóły są otwarte, pomiń pełne odświeżanie/re-renderowanie
                    // (zapobiega to migotaniu)
                    console.log('Automatyczne odświeżanie wstrzymane: otwarte szczegóły pozycji.');
                }
            } catch(e) {
                console.error('Błąd w automatycznym odświeżaniu warunkowym:', e);
            }
        }, AUTO_REFRESH_INTERVAL_MS);
    }

    // Uruchom interwał przy starcie aplikacji
    startConditionalAutoRefresh();

})();
</script>

</body>
</html>

<script>
// Sound ticker to honour repeat interval independently of quote polling
if(!window.__soundTicker){
  window.__soundTicker = setInterval(()=>{
    try{ if(window.checkAndPlayPortfolioAlerts) checkAndPlayPortfolioAlerts(); }catch(_){}
    try{ if(window.checkAndPlayWishlistAlert) checkAndPlayWishlistAlert(); }catch(_){}
  }, 1000);
}

/* === Company Notes (localStorage + Firestore sync) === */
(function(){
  const NOTES_KEY = 'companyNotes_v1';
  function loadCompanyNotes(){ try{ return JSON.parse(localStorage.getItem(NOTES_KEY)||'{}')||{}; }catch(_){ return {}; } }
  function saveCompanyNotes(map){ try{ localStorage.setItem(NOTES_KEY, JSON.stringify(map||{})); }catch(_){ } }
  window.getCompanyNote = (ticker)=> (loadCompanyNotes()[(ticker||'').toUpperCase()]||'');
  window.setCompanyNote = (ticker, text)=>{ const m=loadCompanyNotes(); m[(ticker||'').toUpperCase()]=String(text||''); saveCompanyNotes(m); };

  async function saveNoteRemote(ticker, text){
    try{
      const ctx = await (typeof fbInit === 'function' ? fbInit() : null);
      const auth = ctx && ctx.auth, db = ctx && ctx.db;
      if(!auth || !auth.currentUser || !db) return false;
      const uid = auth.currentUser.uid;
      const id = `${uid}_${String(ticker||'').toUpperCase()}`;
      const fv = (window.firebase && window.firebase.firestore && window.firebase.firestore.FieldValue) || null;
      const ts = fv && fv.serverTimestamp ? fv.serverTimestamp() : new Date();
      await db.collection('companyNotes').doc(id).set({ uid, ticker: String(ticker||'').toUpperCase(), note: String(text||''), updatedAt: ts }, { merge: true });
      return true;
    }catch(e){ console.warn('[notes] save remote failed', e); return false; }
  }
  async function loadNoteRemote(ticker){
    try{
      const ctx = await (typeof fbInit === 'function' ? fbInit() : null);
      const auth = ctx && ctx.auth, db = ctx && ctx.db;
      if(!auth || !auth.currentUser || !db) return null;
      const uid = auth.currentUser.uid;
      const id = `${uid}_${String(ticker||'').toUpperCase()}`;
      const snap = await db.collection('companyNotes').doc(id).get();
      return snap.exists ? (snap.data() && (snap.data().note||'')) : null;
    }catch(e){ return null; }
  }

  window.openCompanyInfoModal = async function(ticker){
    let cur = await loadNoteRemote(ticker);
    if (cur == null) cur = getCompanyNote(ticker);

    const data = await openModal({
      title: `Notatka o spółce: ${ticker}`,
      innerHTML: `<form>
        <label>Twoje notatki o spółce</label>
        <textarea name="note" rows="8" style="width:100%">${__esc(cur||'')}</textarea>
        <p class="small muted">Zapisywane lokalnie i synchronizowane z Firestore (jeśli zalogowany).</p>
      </form>`,
      okText: 'Zapisz'
    });
    if(!data) return;

    setCompanyNote(ticker, data.note||'');
    const ok = await saveNoteRemote(ticker, data.note||'');
    try{ showToast && showToast({ title: ok ? 'Zapisano notatkę (Firestore + lokalnie)' : 'Zapisano notatkę (lokalnie)', message: ticker }); }catch(_){}
  };

  const __origExport = window.exportJSON;
  if (typeof __origExport === 'function'){
    window.exportJSON = function(){
      try{ DB.companyNotes = JSON.parse(JSON.stringify(loadCompanyNotes())); }catch(_){}
      return __origExport.apply(this, arguments);
    };
  }
  try{
    document.getElementById('importFile')?.addEventListener('change', ()=>{
      setTimeout(()=>{ try{ if(DB && DB.companyNotes){ localStorage.setItem(NOTES_KEY, JSON.stringify(DB.companyNotes)); } }catch(_){ } }, 0);
    }, {capture:false});
  }catch(_){}
})();
</script>
<!-- ALLOW_RULES_ALERTS_SNIPPET
Suggested Firestore rules for alerts collection (replace with your setup):
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /alerts/{alertId} {
      allow read: if request.auth != null && resource.data.uid == request.auth.uid;
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.uid == request.auth.uid;
    }
  }
}
-->


<script>
(function(){
  if (typeof window.openModal !== 'function'){
    window.openModal = function({title='Informacja', innerHTML='', okText='OK', cancelText='Anuluj'}={}){
      return new Promise((resolve)=>{
        const overlay = document.createElement('div');
        Object.assign(overlay.style, {position:'fixed', inset:'0', background:'rgba(2,6,23,0.66)', backdropFilter:'blur(6px)', zIndex:'99999', display:'flex', alignItems:'center', justifyContent:'center', padding:'16px'});
        const box = document.createElement('div');
        Object.assign(box.style, {background:'linear-gradient(180deg, rgba(17,24,39,.98), rgba(15,23,42,.98))',color:'var(--text)',border:'1px solid #334155',maxWidth:'720px', width:'100%', borderRadius:'16px', padding:'16px',boxShadow:'0 10px 25px rgba(0,0,0,.35)'});
        box.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px;">
            <h3 style="margin:0;font-size:18px;">${title}</h3>
            <button type="button" class="modal-x" aria-label="Zamknij" style="border:none;background:transparent;font-size:18px;cursor:pointer;color:#94a3b8">×</button>
          </div>
          <div class="modal-body">${innerHTML}</div>
          <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
            <button type="button" class="btn ghost modal-cancel">${cancelText||'Anuluj'}</button>
            <button type="button" class="btn modal-ok">${okText||'OK'}</button>
          </div>`;
        overlay.appendChild(box);
        document.body.appendChild(overlay);
        function cleanup(){ try{ overlay.remove(); }catch(_){} }
        function collectForm(){
          const form = box.querySelector('form');
          if(!form) return undefined;
          const fd = new FormData(form);
          const obj = {}; for (const [k,v] of fd.entries()) obj[k]=v; return obj;
        }
        const cancel = ()=>{ cleanup(); resolve(null); };
        box.querySelector('.modal-ok').addEventListener('click', ()=>{ const data=collectForm(); cleanup(); resolve(data||{}); });
        box.querySelector('.modal-cancel').addEventListener('click', cancel);
        box.querySelector('.modal-x').addEventListener('click', cancel);
        overlay.addEventListener('click', (e)=>{ if(e.target===overlay) cancel(); });
        setTimeout(()=>{ const el = box.querySelector('textarea, input, select, button'); el && el.focus && el.focus(); },0);
      });
    };
  }
})();
document.addEventListener('click', (e)=>{
  const b = e.target.closest('.wl-info'); if(!b) return;
  const t = b.getAttribute('data-ticker'); if(!t) return;
  if (typeof window.openCompanyInfoModal === 'function'){ e.preventDefault(); window.openCompanyInfoModal(t); }
}, true);
</script>


<script>
// === TradingView helpers & global opener ===
(function(){
  function __tvParseSymbol(t){
    var s = String(t||'').toUpperCase().trim();
    if(!s) return '';
    if(s.includes(':')) return s;           // already EXCHANGE:SYMBOL
    if(s.includes('.')){
      var parts = s.split('.');
      var base = parts[0], suf = parts[1];
      if(suf === 'WA') return 'GPW:' + base; // Warsaw GPW
      if(suf === 'L')  return 'LSE:' + base; // London
      if(suf === 'DE') return 'XETR:' + base; // Xetra (best-effort)
      if(suf === 'F')  return 'FWB:' + base;  // Frankfurt best-effort
      return s; // keep suffix (e.g., BRK.B, BF.B) // fallback: strip suffix
    }
    return s; // no exchange
  }
  function makeTradingViewURL(t){
    var sym = __tvParseSymbol(t);
    var q = encodeURIComponent(sym || String(t||'').toUpperCase());
    return 'https://pl.tradingview.com/chart/?symbol=' + q;
  }
  // global delegation (works for holdings + wishlist)
  document.addEventListener('click', function(e){
    var btn = e.target.closest('.tv-link');
    if(!btn) return;
    var t = btn.getAttribute('data-ticker');
    if(!t) return;
    e.preventDefault();
    try{ window.open(makeTradingViewURL(t), '_blank', 'noopener'); }catch(_){ location.href = makeTradingViewURL(t); }
  }, true);
  // expose for potential reuse
  window.makeTradingViewURL = makeTradingViewURL;
})();
</script>
<script id="plus-icon-relabel">
(function(){
  function swapAll(){
    try {
      document.querySelectorAll('#holdingsTable button').forEach((btn)=>{
        if (!btn) return;
        const txt = (btn.textContent || "").trim();
        if (txt === "+" || txt === "＋") {
          btn.textContent = "➕";
          if (!btn.getAttribute("aria-label")) {
            btn.setAttribute("aria-label","Dodaj partię");
          }
        }
      });
    } catch(_e){}
  }
  // Uruchom po załadowaniu oraz przy kliknięciach w tabeli
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    swapAll();
  } else {
    document.addEventListener('DOMContentLoaded', swapAll);
  }
  document.addEventListener('click', function(e){
    if (e && e.target && e.target.closest && e.target.closest('#holdingsTable')) {
      setTimeout(swapAll, 0);
    }
  });
})();
</script>
</template>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
    import {getAuth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, sendPasswordResetEmail, signOut, setPersistence, browserSessionPersistence, sendEmailVerification, deleteUser, updatePassword} from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
    import {getFirestore, doc, getDoc, setDoc, serverTimestamp, collection, getDocs, deleteDoc} from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCfhxDgCqOaCfRKxtMECpRSjQU0TTgtGrM",
      authDomain: "mywallets-b55d9.firebaseapp.com",
      projectId: "mywallets-b55d9",
      storageBucket: "mywallets-b55d9.firebasestorage.app",
      messagingSenderId: "724728432741",
      appId: "1:724728432741:web:2a0a6302a68c78fc0ade8c"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);

    // WYMUSZENIE SESJI TYLKO NA CZAS OTWARCIA KARTY
    // await jest tu ważny, aby Firebase nie zdążył załadować starej sesji Local
    await setPersistence(auth, browserSessionPersistence);

    const db = getFirestore(app);

    const loginView = document.getElementById('loginView');
    const appContainer = document.getElementById('appContainer');
    const appFrame = document.getElementById('appFrame');
    const bgSvg = document.querySelector('.bg-svg');
    const emailEl = document.getElementById('email');
    const passwordEl = document.getElementById('password');
    const err = document.getElementById('err');
    const loginBtn = document.getElementById('loginBtn');
    const signupBtn = document.getElementById('signupBtn'); const logoutBtn = document.getElementById('logoutBtn');
    const verifyView = document.getElementById('verifyView');
    const verifyEmail = document.getElementById('verifyEmail');
    const resendVerifyBtn = document.getElementById('resendVerifyBtn');
    const refreshVerifyBtn = document.getElementById('refreshVerifyBtn');
    const verifyErr = document.getElementById('verifyErr');
    const resetBtn = document.getElementById('resetBtn');
    const acceptTerms = document.getElementById('acceptTerms');
    const termsLink = document.getElementById('termsLink');
    const termsOverlay = document.getElementById('termsOverlay');
    const closeTermsBtn = document.getElementById('closeTermsBtn');
    
    // Wspólna funkcja: czyści lokalny stan aplikacji GT z przeglądarki
    function clearGtLocalStorage() {
      try {
        const prefix = "GT_MultiUser_v1__";
        for (let i = localStorage.length - 1; i >= 0; i--) {
          const key = localStorage.key(i);
          if (key && key.startsWith(prefix)) {
            localStorage.removeItem(key);
          }
        }
      } catch (e) {
        // ignorujemy błędy dostępu do localStorage
      }
    }


    // Wymuszenie świeżego logowania po każdym odświeżeniu strony.
    // Czyścimy lokalny storage GT i ustawiamy flagę, żeby pierwsze wykryte konto
    // zostało natychmiast wylogowane (zanim coś zsynchronizuje się z Firestore).
    clearGtLocalStorage();
    let forceLogoutOnFirstAuth = true;

    
    // ENTER = Zaloguj
    function handleEnter(e){ if(e.key === 'Enter'){ e.preventDefault(); loginBtn.click(); } }
    emailEl.addEventListener('keydown', handleEnter);
    passwordEl.addEventListener('keydown', handleEnter);
    if (termsLink && termsOverlay) {
      termsLink.addEventListener('click', (e) => {
        e.preventDefault();
        termsOverlay.classList.remove('hide');
      });
    }
    if (closeTermsBtn && termsOverlay) {
      closeTermsBtn.addEventListener('click', () => {
        termsOverlay.classList.add('hide');
      });
    }
    if (termsOverlay) {
      termsOverlay.addEventListener('click', (e) => {
        if (e.target === termsOverlay) {
          termsOverlay.classList.add('hide');
        }
      });
    }

function showError(e) {
      console.error(e);
      let msg = (e && e.message) ? e.message : String(e);
      if (e && e.code) {
        const map = {
          "auth/invalid-email": "Nieprawidłowy email",
          "auth/missing-password": "Podaj hasło (min. 6 znaków)",
          "auth/weak-password": "Hasło zbyt krótkie (min. 6 znaków)",
          "auth/email-already-in-use": "Email już istnieje",
          "auth/user-not-found": "Błędny email lub hasło",
          "auth/wrong-password": "Błędny email lub hasło",
          "auth/too-many-requests": "Za dużo prób, spróbuj później",
          "auth/unauthorized-domain": "Dodaj domenę do Authorized domains (Firebase Auth)",
          "auth/invalid-credential": "Błędny email lub hasło",
          "auth/invalid-login-credentials": "Błędny email lub hasło",
};
        msg = map[e.code] || msg;
      }
      err.textContent = msg;
      setTimeout(() => { if (err.textContent === msg) err.textContent = ""; }, 7000);
    }

    const disable = (flag) => [loginBtn, signupBtn, resetBtn].forEach(b => { if (b) b.disabled = !!flag; });
    function validEmail(s) { return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s); }
    function validPass(s) { return typeof s === 'string' && s.length >= 6; }
    function creds(){ return { email: emailEl.value.trim().toLowerCase(), password: passwordEl.value }; }

    // Ignore reserved keys like "__name__"
    const isReservedKey = (k) => /^__.*__$/.test(k);
    const sanitizeSnapshot = (obj) => { const out = {}; for (const k in obj) { if (!isReservedKey(k)) out[k] = obj[k]; } return out; };

    loginBtn.onclick = async () => {
      const {email,password} = creds();
      if (!validEmail(email)) return showError({ code: "auth/invalid-email" });
      if (!validPass(password)) return showError({ code: "auth/weak-password" });
      try { disable(true); await signInWithEmailAndPassword(auth, email, password); }
      catch(e){ showError(e); } finally { disable(false); }
    };
    signupBtn.onclick = async () => {
      const {email,password} = creds();
      if (!validEmail(email)) return showError({ code: "auth/invalid-email" });
      if (!validPass(password)) return showError({ code: "auth/weak-password" });
      if (!acceptTerms || !acceptTerms.checked) {
        return showError("Aby utworzyć konto, musisz zaakceptować regulamin i zasady prywatności.");
      }
      try {
        disable(true);
        const cred = await createUserWithEmailAndPassword(auth, email, password);
        try {
          await sendEmailVerification(cred.user);
        } catch(e) {
          console.warn('[Email verification] Nie udało się wysłać maila weryfikacyjnego', e);
        }
        const ref = doc(db, 'users', cred.user.uid, 'gt', 'state');
        await setDoc(ref, { localStorage: {}, updatedAt: serverTimestamp(), version: 1 }, { merge: true });
      } catch(e) { showError(e); } finally { disable(false); }
    };
    if (resetBtn) {
      resetBtn.onclick = async () => {
        const email = (emailEl.value || '').trim().toLowerCase();
        if (!validEmail(email)) return showError({ code: 'auth/invalid-email' });
        try {
          disable(true);
          await sendPasswordResetEmail(auth, email);
          err.textContent = 'Jeśli konto istnieje, wysłaliśmy link do resetu hasła na podany email.';
          setTimeout(() => { if (err.textContent) err.textContent = ''; }, 8000);
        } catch(e) {
          console.error(e);
          err.textContent = 'Jeśli konto istnieje, wysłaliśmy link do resetu hasła na podany email.';
          setTimeout(() => { if (err.textContent) err.textContent = ''; }, 8000);
        } finally {
          disable(false);
        }
      };
    }

    logoutBtn.onclick = async () => {
      // 1. ZATRZYMAJ OCZEKUJĄCY ZAPIS (KRYTYCZNE)
      if (timer) clearTimeout(timer);
      timer = null;

      // 2. WYCZYŚĆ ZMIENNE W PAMIĘCI (KRYTYCZNE)
      // Dzięki temu dane starego usera nie zostaną użyte dla nowego
      lastSnapshot = {};
      lastSentSnapshot = {};
      remoteStateUnknown = false;

      // 3. Wyczyść i zresetuj iframe
      appFrame.removeAttribute('srcdoc');
      
      // 4. Wyczyść lokalny storage aplikacji (prefiks GT_MultiUser_v1__)
      clearGtLocalStorage();

      // 5. Standardowe wylogowanie z Firebase
      await signOut(auth);
    };
    if (resendVerifyBtn) {
      resendVerifyBtn.onclick = async () => {
        const user = auth.currentUser;
        if (!user) {
          if (verifyErr) verifyErr.textContent = 'Brak zalogowanego użytkownika.';
          return;
        }
        // Proste lokalne ograniczenie: max 1 żądanie na 60 sekund z tego urządzenia
        const now = Date.now();
        const lastTsStr = window.localStorage.getItem('gt_verify_last_resend_ts') || '0';
        const lastTs = Number(lastTsStr) || 0;
        if (now - lastTs < 60_000) {
          const left = Math.ceil((60_000 - (now - lastTs)) / 1000);
          if (verifyErr) verifyErr.textContent = 'Prośba o ponowny mail była już wysłana. Odczekaj około ' + left + ' s przed kolejną próbą.';
          return;
        }

        try {
          resendVerifyBtn.disabled = true;
          if (verifyErr) verifyErr.textContent = '';
          await sendEmailVerification(user);
          window.localStorage.setItem('gt_verify_last_resend_ts', String(Date.now()));
          if (verifyErr) verifyErr.textContent = 'Link weryfikacyjny został wysłany ponownie. Sprawdź również folder SPAM.';
        } catch(e) {
          console.error(e);
          if (e && e.code === 'auth/too-many-requests') {
            if (verifyErr) verifyErr.textContent = 'Za dużo próśb o mail weryfikacyjny z tego konta lub urządzenia. Spróbuj ponownie za kilka–kilkanaście minut. Jeśli problem wraca, zaloguj się ponownie lub użyj innej przeglądarki.';
          } else {
            if (verifyErr) verifyErr.textContent = 'Nie udało się wysłać maila weryfikacyjnego: ' + (e && e.message ? e.message : e);
          }
        } finally {
          // Trzymamy przycisk zablokowany kilka sekund, żeby nie dało się klikać „na spam”
          setTimeout(() => { resendVerifyBtn.disabled = false; }, 10_000);
        }
      };
    }
    if (refreshVerifyBtn) {
      refreshVerifyBtn.onclick = () => {
        window.location.reload();
      };
    }



    let lastSnapshot = {};
    let lastSentSnapshot = {};
    let timer = null;
    let remoteStateUnknown = false;
    window.__GT_GET_SYNC_OK__ = function(){ return !remoteStateUnknown; };

    let lastRemoteMeta = { updatedAt: 0, localUpdatedAt: 0 };

    const snapshotsEqual = (a, b) => {
      try {
        return JSON.stringify(a || {}) === JSON.stringify(b || {});
      } catch (_e) {
        return false;
      }
    };

    
    // Nowa, bezpieczna funkcja porównująca, która wersja jest naprawdę nowsza
    function getNewerSnapshot(local, remote) {
      // Jeśli jedna z wersji jest pusta – zwróć drugą
      if (!local || Object.keys(local).length === 0) return remote;
      if (!remote || Object.keys(remote).length === 0) return local;

      // Znajdź najnowszy timestamp w danych lokalnych (z portfele_firmy_v1)
      let localTs = 0;
      try {
        const raw = local["portfele_firmy_v1"];
        if (raw) {
          const parsed = JSON.parse(raw);
          localTs = Number(parsed._ts) || 0;
        }
      } catch (e) {}

      // Znajdź najnowszy timestamp w danych zdalnych
      let remoteTs = 0;
      try {
        const raw = remote["portfele_firmy_v1"];
        if (raw) {
          const parsed = JSON.parse(raw);
          remoteTs = Number(parsed._ts) || 0;
        }
      } catch (e) {}

      // Zwróć nowszą wersję według prawdziwego timestampu aplikacji
      if (remoteTs > localTs) return remote;
      return local;
    }


const debounce = (uid) => {
      clearTimeout(timer);
      timer = setTimeout(async () => {
        try {
          // 1. Przygotuj dane lokalne
          const localPayload = sanitizeSnapshot(lastSnapshot || {});
          
          // Sprawdź, czy w ogóle są dane do zapisu
          if (!localPayload || Object.keys(localPayload).length === 0) return;

          // Wyciągnij czas modyfikacji danych lokalnych (z klucza portfele_firmy_v1)
          let localTs = 0;
          try {
            const raw = localPayload["portfele_firmy_v1"];
            if (raw) {
              const parsed = JSON.parse(raw);
              localTs = Number(parsed._ts) || 0;
            }
          } catch (e) { console.warn("Błąd parsowania lokalnego TS", e); }

          const ref = doc(db, 'users', uid, 'gt', 'state');

          // 2. POBIERZ stan serwera przed zapisem (Safety Check)
          const serverSnap = await getDoc(ref);
          let serverData = null;
          
          if (serverSnap.exists()) {
            serverData = serverSnap.data() || {};
          }

          // 3. NOWE PORÓWNANIE: wybierz naprawdę nowszą wersję na podstawie _ts z portfele_firmy_v1
          if (serverData && serverData.localStorage) {
            const remoteStorage = serverData.localStorage;
            const localRaw = lastSnapshot || {};
            const newer = getNewerSnapshot(localRaw, remoteStorage);

            if (newer === remoteStorage) {
              // Serwer ma nowszą wersję według _ts z danych
              const accept = window.confirm("Wykryto nowszą wersję danych z innego urządzenia.\nPobrać ją?");
              if (accept) {
                lastSnapshot = remoteStorage;
                try {
                  lastSentSnapshot = JSON.parse(JSON.stringify(lastSnapshot || {}));
                } catch (_e) {
                  lastSentSnapshot = lastSnapshot || {};
                }
                // Przeładuj iframe z nowymi danymi
                mount();
                // Nie zapisujemy – mamy już najnowsze dane
                return;
              }
              // Jeśli użytkownik odrzuci zdalne dane, to kontynuujemy zapis lokalnych danych na serwer
            }
          }

          // 4. Jeśli lokalne są nowsze (lub te same), zapisz bezpiecznie
          if (snapshotsEqual(localPayload, lastSentSnapshot)) {
            return;
          }

          const clientTs = Date.now();
          await setDoc(
            ref,
            { localStorage: localPayload, updatedAt: serverTimestamp(), localUpdatedAt: clientTs, version: 1 },
            { merge: true }
          );
          
          console.log("Zapisano zmiany w Firebase (Local był nowszy).");
          lastSentSnapshot = localPayload;
          lastRemoteMeta.localUpdatedAt = clientTs;

        } catch (e) {
          console.error("Błąd synchronizacji:", e);
        }
      }, 1500); // Zwiększamy lekko opóźnienie do 1.5s dla bezpieczeństwa
    };
    // Global helper for password change (used from iframe Settings)
    window.__requestPasswordChange = async (newPassword) => {
      const user = auth.currentUser;
      if (!user) {
        alert('Brak zalogowanego użytkownika.');
        return;
      }
      try {
        await updatePassword(user, newPassword);
        alert('Hasło zostało zmienione.');
      } catch (e) {
        console.error('Błąd przy zmianie hasła:', e);
        if (e && e.code === 'auth/requires-recent-login') {
          alert('Aby zmienić hasło, wyloguj się i zaloguj ponownie, a następnie spróbuj ponownie.');
        } else if (e && e.code === 'auth/weak-password') {
          alert('Hasło jest zbyt słabe. Użyj co najmniej 6 znaków, najlepiej z cyframi i liczbami.');
        } else {
          alert('Nie udało się zmienić hasła. Spróbuj ponownie później.');
        }
      }
    };

    // Global helper for account deactivation (used from iframe Settings)
    window.__requestAccountDeletion = async () => {
      const user = auth.currentUser;
      if (!user) {
        alert('Brak zalogowanego użytkownika.');
        return;
      }

      const ok = window.confirm('Czy na pewno chcesz dezaktywować konto i usunąć wszystkie dane?\nTej operacji nie można cofnąć.');
      if (!ok) return;

      try {
        // 1. Usuń dane użytkownika z Firestore (kolekcja users/{uid}/gt/*)
        try {
          const colRef = collection(db, 'users', user.uid, 'gt');
          const snap = await getDocs(colRef);
          const deletions = [];
          snap.forEach((docSnap) => {
            deletions.push(deleteDoc(docSnap.ref));
          });
          await Promise.all(deletions);
        } catch (e) {
          console.error('Błąd przy usuwaniu danych Firestore:', e);
        }

        // 2. Usuń konto użytkownika z Firebase Auth
        try {
          await deleteUser(user);
        } catch (e) {
          console.error('Błąd przy usuwaniu konta:', e);
          if (e && e.code === 'auth/requires-recent-login') {
            alert('Aby dezaktywować konto, zaloguj się ponownie i spróbuj jeszcze raz.');
            return;
          } else {
            alert('Nie udało się usunąć konta. Spróbuj ponownie później.');
            return;
          }
        }

        // 3. Wyloguj (na wszelki wypadek) i wyczyść stan lokalny
        try {
          lastSnapshot = {};
        } catch(_){}
        try {
          await signOut(auth);
        } catch(_){}

        alert('Konto zostało dezaktywowane i dane zostały usunięte.');
      } catch (e) {
        console.error('Błąd przy dezaktywacji konta:', e);
        alert('Wystąpił błąd podczas dezaktywacji konta. Spróbuj ponownie później.');
      }
    };


    
    
    
    
    function computeBaseHref(){ try{ const u=new URL(window.location.href); return u.origin + u.pathname.replace(/[^\/]*$/,''); }catch(_e){ return document.baseURI || '/'; } }
    function mount(){
      const tpl = document.getElementById('appTemplate');
      if (!tpl) {
        console.error('Brak szablonu appTemplate');
        return;
      }
      const html = tpl.innerHTML.replace("__BASE__", computeBaseHref());
      appFrame.srcdoc = html;
    }

    window.addEventListener('message', (ev) => {
      if (ev.source !== appFrame.contentWindow) return;
      const msg = ev.data || {};
      if (msg.type === 'request_init') {
        appFrame.contentWindow.postMessage({ type: 'storage_apply', payload: lastSnapshot }, '*');
        appFrame.contentWindow.postMessage({ type: 'set_clear_on_exit', value: false }, '*');
        // Trigger programmatic auto-sync inside the iframe
        setTimeout(()=>{ try{ appFrame.contentWindow.postMessage({ type:'auto_sync' }, '*'); }catch(_e){} }, 150);
        setTimeout(()=>{ try{ appFrame.contentWindow.postMessage({ type:'auto_sync' }, '*'); }catch(_e){} }, 600);
        setTimeout(()=>{ try{ appFrame.contentWindow.postMessage({ type:'auto_sync' }, '*'); }catch(_e){} }, 1500);
      } else if (msg.type === 'storage_event') {
        const { key, value } = msg;
        if (!key || isReservedKey(key)) return;
        let changed = false;
        if (value === null || typeof value === 'undefined') {
          if (key in lastSnapshot) {
            delete lastSnapshot[key];
            changed = true;
          }
        } else {
          if (lastSnapshot[key] !== value) {
            lastSnapshot[key] = value;
            changed = true;
          }
        }
        if (!changed) return;
        const u = auth.currentUser;
        if (u) debounce(u.uid);
      } else if (msg.type === 'storage_clear') {
        lastSnapshot = {};
        const u = auth.currentUser; if (u) debounce(u.uid);
      }
    });

    onAuthStateChanged(auth, async (user) => {
      // Wymuszone wylogowanie przy pierwszym odświeżeniu strony:
      // jeśli jest zapamiętany użytkownik, natychmiast go wyloguj,
      // zanim uruchomi się jakakolwiek logika synchronizacji.
      if (typeof forceLogoutOnFirstAuth !== 'undefined' && forceLogoutOnFirstAuth) {
        forceLogoutOnFirstAuth = false;
        if (user) {
          clearGtLocalStorage();
          try { await signOut(auth); } catch (_e) {}
          return;
        }
      }

      if (!user) {
        // --- DODANE CZYSZCZENIE STANU RAM PRZY WYLOGOWANIU ---
        if (timer) clearTimeout(timer); // Stop zapisu starego konta
        timer = null;
        lastSnapshot = {};              // Wymaż dane z pamięci RAM
        lastSentSnapshot = {};
        remoteStateUnknown = false;
        // Dodatkowo wyczyść lokalny storage aplikacji (na wszelki wypadek)
        clearGtLocalStorage();
        // --- KONIEC DODANEGO BLOKU ---

        loginView.classList.remove('hide');
        appContainer.classList.add('hide');
        if (verifyView) verifyView.classList.add('hide');
        if (bgSvg) bgSvg.style.display = '';
        who.textContent = '—';
        appFrame.removeAttribute('srcdoc');
        return;
      }

      // Wejście w tryb zalogowany: zawsze czyścimy lokalny storage,
      // żeby uniknąć mieszania kont po zamknięciu karty.
      clearGtLocalStorage();
      // Odśwież dane użytkownika, żeby mieć aktualny status emailVerified
      try { if (typeof user.reload == 'function') await user.reload(); } catch(_){}

      if (!user.emailVerified) {
        loginView.classList.add('hide');
        appContainer.classList.add('hide');
        if (verifyView) {
          verifyView.classList.remove('hide');
          if (verifyEmail) verifyEmail.textContent = user.email || user.uid;
        }
        who.textContent = user.email || user.uid;
        if (bgSvg) bgSvg.style.display = '';
        appFrame.removeAttribute('srcdoc');
        return;
      }

      if (verifyView) verifyView.classList.add('hide');
      who.textContent = user.email || user.uid;
      loginView.classList.add('hide');
      appContainer.classList.remove('hide');
      if (bgSvg) bgSvg.style.display = 'none';

      // Zresetuj stan meta przed wczytaniem stanu z Firestore
      remoteStateUnknown = false;
      lastRemoteMeta = { updatedAt: 0, localUpdatedAt: 0 };

      try {
        const snapRef = doc(db, 'users', user.uid, 'gt', 'state');
        const snap = await getDoc(snapRef);
        if (snap.exists()) {
          const data = snap.data() || {};
          lastSnapshot = data.localStorage || {};
          const updatedAt = data.updatedAt;
          let updatedAtMs = 0;
          if (updatedAt && typeof updatedAt.toMillis === 'function') {
            updatedAtMs = updatedAt.toMillis();
          } else if (updatedAt && typeof updatedAt === 'object' && typeof updatedAt.at === 'string') {
            updatedAtMs = Date.parse(updatedAt.at) || 0;
          } else if (typeof updatedAt === 'string') {
            updatedAtMs = Date.parse(updatedAt) || 0;
          }
          lastRemoteMeta = {
            updatedAt: updatedAtMs,
            localUpdatedAt: data.localUpdatedAt || 0
          };
        } else {
          lastSnapshot = {};
        }
      } catch (e) {
        console.error(e);
        lastSnapshot = {};
        remoteStateUnknown = true;
      }
      try {
        lastSentSnapshot = JSON.parse(JSON.stringify(lastSnapshot || {}));
      } catch (_e) {
        lastSentSnapshot = {};
      }
      mount();
    });
  </script>

<script>
  let hasUnsaved = false;
  window.addEventListener('message', e => {
    try {
      if (e.source === appFrame?.contentWindow &&
          (e.data?.type === 'storage_event' || e.data?.type === 'storage_clear')) {
        hasUnsaved = true;
      }
    } catch (_) {}
  });
  window.addEventListener('beforeunload', e => {
    if (hasUnsaved) {
      e.preventDefault();
      e.returnValue = 'Masz niezapisane zmiany. Na pewno chcesz wyjść?';
    }
  });
</script>



</body>
</html>
