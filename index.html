<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portfele — v2</title>
  <style>
    :root{
      --bg:#0f172a;        /* slate-900 */
      --panel:#111827;     /* gray-900 */
      --panel-2:#1f2937;   /* gray-800 */
      --muted:#94a3b8;     /* slate-400 */
      --text:#e5e7eb;      /* gray-200 */
      --accent:#22d3ee;    /* cyan-400 */
      --accent-2:#06b6d4;  /* cyan-500 */
      --danger:#ef4444;    /* red-500 */
      --ok:#10b981;        /* emerald-500 */
      --warn:#f59e0b;      /* amber-500 */
      --shadow: 0 10px 25px rgba(0,0,0,.35);
      --radius: 14px;
    }
    *{ box-sizing: border-box; }
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Noto Sans, Ubuntu, Cantarell, Arial, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;
      background: linear-gradient(120deg,#0b1222 0%,#0f172a 40%, #101525 100%);
      color: var(--text);
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 18px; position:sticky; top:0; z-index:5;
      background: linear-gradient(0deg, rgba(15,23,42,.6), rgba(15,23,42,.6));
      backdrop-filter: blur(8px);
      border-bottom: 1px solid #111827;
      box-shadow: var(--shadow);
    }
    header h1{ margin:0; font-weight:700; font-size: clamp(18px, 2vw, 22px); letter-spacing:.3px; }
    header .actions{ display:flex; gap:8px; flex-wrap:wrap;}
    .btn{
      border:none; border-radius:10px;
      padding:10px 14px; color:#0b1222; font-weight:600;
      background: var(--accent); cursor:pointer;
      transition:.2s transform ease, .2s box-shadow ease, .2s filter ease;
      box-shadow: 0 8px 20px rgba(34,211,238,.25);
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.05); }
    .btn:active{ transform: translateY(0px) scale(.98); }
    .btn.secondary{ background:#334155; color: var(--text); box-shadow:none; }
    .btn.ghost{ background: transparent; color: var(--text); border:1px solid #334155; }
    .btn.warn{ background: var(--warn); color:#0b1222; }
    .btn.danger{ background: var(--danger); color:#fff; }
    .btn.ok{ background: var(--ok); color:#0b1222; }
    .layout{ display:grid; grid-template-columns: 330px 1fr; gap:14px; padding:14px; }
    @media (max-width: 980px){ .layout{ grid-template-columns: 1fr; } }
    .card{
      background: linear-gradient(180deg, rgba(17,24,39,.85), rgba(16,23,42,.92));
      border:1px solid #1f2937;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .sidebar{ padding:14px; min-height: calc(100svh - 80px); }
    .sidebar .head{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    .portfolios{ display:flex; flex-direction:column; gap:8px; }
    .portfolio-item{
      padding:10px; border-radius:12px; border:1px solid #1f2937;
      background: linear-gradient(180deg, #0f172a, #0b1222);
      cursor:pointer; transition:.15s ease;
    }
    .portfolio-item:hover{ border-color:#334155; }
    .portfolio-item.active{ border-color: var(--accent); box-shadow: 0 0 0 1px inset var(--accent); }
    .portfolio-item .name{ font-weight:700; font-size:15px; }
    .portfolio-item .row{ display:flex; justify-content:space-between; gap:8px; color: var(--muted); font-size:13px; margin-top:4px; }
    .main{ padding:14px; display:flex; flex-direction:column; gap:14px; }
    .panel{ padding:14px; }
    .panel h2{ margin:0 0 10px 0; font-size:18px; }
    .grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:14px; }
    .col-4{ grid-column: span 4; } .col-6{ grid-column: span 6; } .col-8{ grid-column: span 8; } .col-12{ grid-column: span 12; }
    @media (max-width: 980px){ .col-4,.col-6,.col-8{ grid-column: span 12; } }
    .stat{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px; border-radius:12px; background:#0b1222; border:1px solid #1f2937;
    }
    .muted{ color: var(--muted); }
    .row{ display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .spacer{ flex: 1 1 auto; }
    textarea, input, select{
      width:100%; padding:10px 12px; border-radius:10px; border:1px solid #334155; background:#0b1222;
      color:var(--text); outline:none; font-size:14px;
    }
    label{ display:block; font-size:13px; color: var(--muted); margin-bottom:6px; }
    table{ width:100%; border-collapse: collapse; }
    th, td{ text-align:left; padding:10px; border-bottom:1px solid #1f2937; vertical-align: top; }
    th{ color: #cbd5e1; font-weight:700; background:#0b1222; position:sticky; top:0; }
    tr:hover td{ background: rgba(3, 7, 18, .4); }
    .ticker{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; letter-spacing:.3px; font-weight:700; }
    details summary{ cursor:pointer; user-select:none; }
    .tag{ padding:4px 8px; border-radius:999px; background:#111827; border:1px solid #1f2937; font-size:12px; color:#cbd5e1; }
    footer{ color:var(--muted); text-align:center; padding:18px 8px; }
    dialog{ border:none; border-radius:16px; padding:0; background:transparent; 
      color: var(--text);
}
    .modal{
      color: var(--text);
 background: linear-gradient(180deg, rgba(17,24,39,.98), rgba(15,23,42,.98)); border:1px solid #334155; border-radius:16px; width:min(720px, 96vw); box-shadow: var(--shadow); }
    .modal header{ position:sticky; top:0; background:transparent; box-shadow:none; border:none; padding:14px; }
    .modal .content{ padding:14px; }
    .modal footer{ display:flex; gap:8px; justify-content:flex-end; padding:14px; }
    .small{ font-size:12px; color:var(--muted); }
    .note{ font-size:13px; color:#e5e7eb; opacity:.9; }
    .danger-text{ color: var(--danger); }
    .ok-text{ color: var(--ok); }
    
.warn-text{ color: var(--warn, #ffb020); }
.warn-strong-text{ color:#ff6a00; font-weight:600; }
/* Percentage badge helper */
.pct-badge{ font-weight:700; padding:2px 6px; border-radius:8px; background: rgba(255,255,255,.04); display:inline-block; min-width:62px; text-align:right; }
.pct-pos{ color: var(--ok); }
.pct-neg{ color: var(--danger); }
.center{ text-align:center; }
    .link{ color: var(--accent); cursor:pointer; text-decoration: underline; }
  
    .near-target{ animation: pulse 1.2s infinite; }
    .hit-target{ animation: pulse-strong 0.8s infinite; }
    @keyframes pulse{
      0%{ box-shadow: 0 0 0 0 rgba(16,185,129,.35); }
      50%{ box-shadow: 0 0 0 6px rgba(16,185,129,.05); background: rgba(16,185,129,.06); }
      100%{ box-shadow: 0 0 0 0 rgba(16,185,129,.0); }
    }
    @keyframes pulse-strong{
      0%{ box-shadow: 0 0 0 0 rgba(34,197,94,.6); }
      50%{ box-shadow: 0 0 0 10px rgba(34,197,94,.12); background: rgba(34,197,94,.12); }
      100%{ box-shadow: 0 0 0 0 rgba(34,197,94,.0); }
    }

  
  /* === Collapsible History === */
  #historyPanel #txTableWrap { transition: max-height 0.25s ease; }
  #historyPanel.collapsed #txTableWrap { max-height: 0; overflow: hidden; padding: 0; margin: 0; border: 0; }
  #historyPanel.collapsed #filterQuery, 
  #historyPanel.collapsed label[for="filterQuery"] { display: none; }
  #historyPanel .clickable { cursor: pointer; }
  #historyPanel .chev { display:inline-block; transition: transform .2s ease; }
  #historyPanel.collapsed .chev { transform: rotate(-90deg); }


/* === Colored blinking for BUY (green) and SELL (red) === */
@keyframes blinkRed { 0%{outline-color: transparent;} 50%{outline-color: rgba(220,38,38,0.9);} 100%{outline-color: transparent;} }
@keyframes blinkGreen { 0%{outline-color: transparent;} 50%{outline-color: rgba(16,185,129,0.9);} 100%{outline-color: transparent;} }

.hit-target-sell   { outline: 3px solid; animation: blinkRed 1s infinite;    }
.near-target-sell  { outline: 2px dashed; animation: blinkRed 1.6s infinite; }
.hit-target-buy    { outline: 3px solid; animation: blinkGreen 1s infinite;  }
.near-target-buy   { outline: 2px dashed; animation: blinkGreen 1.6s infinite; }

/* compatibility (old generic classes) */
.hit-target { outline: 3px solid; animation: blinkRed 1.2s infinite; }
.near-target{ outline: 2px dashed; animation: blinkRed 2s infinite; }

/* === Mobile tweaks === */
@media (max-width: 980px){
  .layout{ grid-template-columns: 1fr; padding:10px; gap:10px; }
  .sidebar{ min-height: auto; }
  main{ padding:10px; gap:10px; }
  header{ padding:10px; }
  header .actions{ gap:6px; }
  header .actions > *{ flex: 1 1 48%; } /* 2 per row */
  .panel{ padding:10px; }
  .grid{ gap:10px; }
  th, td{ padding:8px; }
  .btn{ padding:10px 12px; font-size:14px; }
}

@media (max-width: 640px){
  header h1{ display:flex; flex-direction:column; gap:8px; }
  header h1 .btn{ align-self:flex-start; }
  header .actions > *{ flex: 1 1 100%; } /* full width */
  .table-wrap{ overflow-x:auto; -webkit-overflow-scrolling: touch; }
  table{ min-width: 640px; } /* enable horizontal scroll for wide tables */
  .ticker{ font-size:13px; }
  th, td{ font-size:13px; }
}
/* === Daily change arrows === */
.change-arrow{ font-weight: 700; margin-right: 4px; }
.change-arrow.up{ color: var(--ok); }
.change-arrow.down{ color: var(--danger); }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<!-- Firebase SDKs (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-app-compat.js">
</script>
<script>
/* === Early TX helpers shim (ensureBuyLotIdInTx / applyCash) [GO] === */
(function(){
  try{
    if (typeof window.ensureBuyLotIdInTx !== 'function') {
      window.ensureBuyLotIdInTx = function(tx){
        try{
          if(tx && tx.type==='buy' && !tx.lotId){
            tx.lotId = tx.id || ('lot_'+Date.now().toString(36)+'_'+Math.random().toString(36).slice(2));
          }
        }catch(_){}
      };
    }
    if (typeof window.__go_applyCashShim !== 'function') {
      window.__go_applyCashShim = function(state, type, amount){
        const a = Number(amount)||0;
        if(!state || !type) return;
        if(type==='deposit' || type==='transfer_in'){ state.cash = (Number(state.cash)||0) + a; return; }
        if(type==='withdraw' || type==='transfer_out'){ state.cash = (Number(state.cash)||0) - a; return; }
        // else ignore
      };
    }
  }catch(_){}
})();
/* === end early TX shims === */

</script>
<script>
/* === Lightweight apply* fallbacks for GO chart (used only if app versions not yet loaded) === */
(function(){
  function __go_book(state, tkr){
    state.holdings = state.holdings || {};
    if(!state.holdings[tkr]) state.holdings[tkr] = { qty: 0, lots: [] };
    const b = state.holdings[tkr];
    b.lots = Array.isArray(b.lots) ? b.lots : [];
    b.qty = Number(b.qty)||0;
    return b;
  }
  function __go_consumeLots(book, qty, links){
    let left = Number(qty)||0;
    if(!book || !Array.isArray(book.lots)) return 0;
    // If explicit lotLinks provided, consume those first
    if(Array.isArray(links) && links.length){
      for(const ln of links){
        if(left<=0) break;
        const id = ln.lotId; let rq = Number(ln.qty)||0;
        for(const lot of book.lots){
          if(left<=0) break;
          if(id && lot.lotId===id){
            const take = Math.min(lot.qty||0, rq, left);
            lot.qty = (lot.qty||0) - take;
            book.qty = (book.qty||0) - take;
            left -= take; rq -= take;
          }
        }
      }
    }
    // FIFO for the rest
    for(const lot of book.lots){
      if(left<=0) break;
      const take = Math.min(lot.qty||0, left);
      lot.qty = (lot.qty||0) - take;
      book.qty = (book.qty||0) - take;
      left -= take;
    }
    // cleanup empty lots
    book.lots = book.lots.filter(l => (l.qty||0) > 0);
    return left; // remaining (if >0, not enough qty)
  }
  if(typeof window.__go_applyBuy !== 'function'){
    window.__go_applyBuy = function(state, pf, tx){
      const tkr = String(tx.ticker||'').trim().toUpperCase();
      const q = Number(tx.qty)||0, p = Number(tx.price)||0, f = Number(tx.fees)||0;
      state.cash = (Number(state.cash)||0) - (q*p + f);
      try{ if(typeof ensureBuyLotIdInTx==='function') ensureBuyLotIdInTx(tx); }catch(_){}
      const book = __go_book(state, tkr);
      const lot = { lotId: tx.lotId || ('lot_'+Math.random().toString(36).slice(2)), qty: q, price: p };
      book.lots.push(lot);
      book.qty = (book.qty||0) + q;
    };
  }
  if(typeof window.__go_applySell !== 'function'){
    window.__go_applySell = function(state, pf, tx){
      const tkr = String(tx.ticker||'').trim().toUpperCase();
      const q = Number(tx.qty)||0, p = Number(tx.price||tx.sellPrice||0), f = Number(tx.fees)||0;
      state.cash = (Number(state.cash)||0) + (q*p - f);
      const book = __go_book(state, tkr);
      __go_consumeLots(book, q, Array.isArray(tx.lotLinks)?tx.lotLinks:[]);
    };
  }
  if(typeof window.__go_applyTransferCompanyIn !== 'function'){
    window.__go_applyTransferCompanyIn = function(state, pf, tx){
      const tkr = String(tx.ticker||'').trim().toUpperCase();
      const q = Number(tx.qty)||0, p = Number(tx.price)||0;
      const book = __go_book(state, tkr);
      book.lots.push({ lotId: tx.lotId || ('lot_'+Math.random().toString(36).slice(2)), qty: q, price: p });
      book.qty = (book.qty||0) + q;
    };
  }
  if(typeof window.__go_applyTransferCompanyOut !== 'function'){
    window.__go_applyTransferCompanyOut = function(state, pf, tx){
      const tkr = String(tx.ticker||'').trim().toUpperCase();
      const q = Number(tx.qty)||0;
      const book = __go_book(state, tkr);
      __go_consumeLots(book, q, Array.isArray(tx.lotLinks)?tx.lotLinks:[]);
    };
  }
})();
/* === end lightweight apply* fallbacks === */
</script>
<script>
/* === Early currency formatter shim (before app boot) [GO] === */
(function(){
  try{
    if (typeof window.__go_fmtCurrency !== 'function') {
      window.__go_fmtCurrency = function(v, code){
        try { if (typeof fmtCurrency === 'function') return fmtCurrency(v, code); } catch(_) {}
        try { return new Intl.NumberFormat(undefined, { style:'currency', currency:(code||'PLN') }).format(v||0); }
        catch(_) { return String(Math.round((v||0)*100)/100) + ' ' + (code||''); }
      };
    }
  }catch(_){}
})();
/* === end shim === */
</script>

  <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore-compat.js"></script>


<script>
// Global shims to avoid ReferenceError when __fmtNum / __esc are used before module loads
window.__esc = window.__esc || function(s){
  try{ if(typeof window.escapeHtml==='function') return window.escapeHtml(String(s||'')); }catch(_){}
  const t = document.createElement('textarea'); t.textContent = String(s||''); return t.innerHTML;
};
window.__fmtNum = window.__fmtNum || function(v){
  try{ if(typeof window.fmtNum==='function') return window.fmtNum(v); }catch(_){}
  const n = Number(v); if(!isFinite(n)) return '—';
  return n.toLocaleString(undefined, {maximumFractionDigits: 2});
};
</script>
<script>
// === Global date helpers shim (added by fix) ===
window.toMs = window.toMs || function(d){
  try{
    if (d == null) return NaN;
    if (typeof d === 'number') return d;
    if (d instanceof Date) return d.getTime();
    if (d && typeof d.toDate === 'function') return d.toDate().getTime();
    if (d && typeof d.seconds !== 'undefined') return Number(d.seconds) * 1000;
    const ms = Date.parse(String(d));
    return Number.isFinite(ms) ? ms : NaN;
  }catch(_){ return NaN; }
};

window.inRangeMs = window.inRangeMs || function(ms, range){
  if (!range) return true;
  if (!Number.isFinite(ms)) return false;
  const s = Number(((range && range.start) ?? -Infinity));
  const e = Number(((range && range.end) ?? Infinity));
  return ms >= s && ms <= e;
};
</script>


<style>
#toastsWrap{position:fixed;right:10px;bottom:10px;z-index:9999;display:flex;flex-direction:column;gap:8px;max-width:92vw}
.toast{padding:10px 12px;border-radius:10px;box-shadow:0 4px 14px rgba(0,0,0,.2);background:var(--table-bg, #f8f9fa);color:var(--text-color,#111);font-size:.9rem;opacity:.98;display:flex;align-items:center;gap:8px}
.toast.hit{border-left:4px solid #16a34a}
.toast.near{border-left:4px solid #d97706}
.toast .time{opacity:.6;font-size:.8rem;margin-left:auto}
#alertsTabBtn .badge{margin-left:6px;padding:0 6px;border-radius:10px;background:#ef4444;color:#fff;font-size:.75rem;display:inline-block}

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<style>
/* Disable blinking inside Alerts panel */
#alertsPanel .hit-target-sell, 
#alertsPanel .hit-target-buy, 
#alertsPanel .near-target-sell, 
#alertsPanel .near-target-buy { animation: none !important; }
/* Use non-blinking styles for rows */
#alertsPanel tr.state-hit  { border-left: 4px solid rgba(34,197,94,.9); }   /* green */
#alertsPanel tr.state-near { border-left: 4px solid rgba(245,158,11,.9); }  /* amber */
#alertsPanel tr.state-hit, #alertsPanel tr.state-near { background: inherit; }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style>
/* === Global Dark Theme for ALL modals/popups === */
:root{
  --__modal-bg: var(--surface, #0f172a);
  --__modal-bg2: var(--surface-2, #0b1220);
  --__modal-text: var(--text, #e5e7eb);
  --__modal-muted: var(--muted, #94a3b8);
  --__modal-border: var(--border-color, #334155);
  --__modal-ring: var(--accent, #60a5fa);
  --__backdrop: rgba(2,6,23,0.66);
}

/* Native <dialog> */
dialog, [role="dialog"], .modal, .popup, .dialog, .app-modal, .app-popup {
  background:
    linear-gradient(180deg, color-mix(in oklab, var(--__modal-bg) 98%, transparent),
                           color-mix(in oklab, var(--__modal-bg2) 98%, transparent));
  color: var(--__modal-text);
  border: 1px solid var(--__modal-border);
  border-radius: 16px;
  box-shadow: 0 12px 28px rgba(0,0,0,.35);
}

/* Ensure common inner wrappers inherit */
dialog .modal-content,
.modal .modal-content,
.popup .modal-content,
[role="dialog"] .modal-content { background: transparent; color: inherit; border: 0; }

/* Backdrop for native <dialog> */
dialog::backdrop { 
  background: var(--__backdrop);
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
}

/* Generic overlay/backdrop classes used by custom modals */
.backdrop, .overlay, .modal-backdrop, .popup-backdrop {
  background: var(--__backdrop) !important;
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
}

/* Head/foot areas */
.modal-header, .popup-header {
  border-bottom: 1px solid var(--__modal-border);
  padding: 12px 16px;
}
.modal-footer, .popup-footer {
  border-top: 1px solid var(--__modal-border);
  padding: 12px 16px;
  display: flex; gap: 12px; justify-content: flex-end; align-items: center;
}

/* Controls */
.modal input, .modal textarea, .modal select,
dialog input, dialog textarea, dialog select,
.popup input, .popup textarea, .popup select,
[role="dialog"] input, [role="dialog"] textarea, [role="dialog"] select {
  background: var(--surface-2, #111827);
  color: var(--__modal-text);
  border: 1px solid var(--__modal-border);
  border-radius: 12px;
  padding: 10px 12px;
  outline: none;
}
.modal input::placeholder, .modal textarea::placeholder,
dialog input::placeholder, dialog textarea::placeholder,
.popup input::placeholder, .popup textarea::placeholder,
[role="dialog"] input::placeholder, [role="dialog"] textarea::placeholder {
  color: color-mix(in oklab, var(--__modal-muted) 80%, transparent);
}
.modal input:focus, .modal textarea:focus, .modal select:focus,
dialog input:focus, dialog textarea:focus, dialog select:focus,
.popup input:focus, .popup textarea:focus, .popup select:focus,
[role="dialog"] input:focus, [role="dialog"] textarea:focus, [role="dialog"] select:focus {
  box-shadow: 0 0 0 3px color-mix(in oklab, var(--__modal-ring) 30%, transparent);
  border-color: var(--__modal-ring);
}

/* Checkbox/Radio accent */
.modal input[type="checkbox"], .modal input[type="radio"],
dialog input[type="checkbox"], dialog input[type="radio"],
.popup input[type="checkbox"], .popup input[type="radio"],
[role="dialog"] input[type="checkbox"], [role="dialog"] input[type="radio"]{
  accent-color: var(--__modal-ring);
}

/* Close icon */
.modal .modal-x, dialog .modal-x, .popup .modal-x {
  color: var(--__modal-muted);
}
.modal .modal-x:hover, dialog .modal-x:hover, .popup .modal-x:hover {
  opacity: .9;
}

/* Buttons (use existing .btn styling if present) */
.modal .btn, dialog .btn, .popup .btn {
  border-radius: 12px;
  padding: 10px 14px;
  font-weight: 600;
}
.modal .btn.ghost, dialog .btn.ghost, .popup .btn.ghost {
  background: transparent;
  border: 1px solid var(--__modal-border);
  color: var(--__modal-muted);
}

/* Subtle enter animation; respects reduced motion */
@media (prefers-reduced-motion: no-preference){
  dialog[open], .modal, .popup, [role="dialog"] {
    animation: modalFadeIn .16s ease-out;
  }
  @keyframes modalFadeIn { from { opacity: .0; transform: scale(.98);} to { opacity: 1; transform: scale(1);} }
}


  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style>
/* === GO period chip polish === */
.go-chip-label{display:inline-block; margin-right:8px; opacity:.9; font-weight:600;}
#go-period{
  padding:4px 10px;
  border-radius:10px;
  border:1px solid var(--muted, rgba(128,128,128,.4));
  background: var(--bg-2, rgba(255,255,255,.05));
  outline:none;
}
#go-period:focus{ box-shadow:0 0 0 2px rgba(100,150,255,.25); }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style>
.company-name-display {
  display: block;
  font-size: 11px;
  color: var(--muted);
  font-weight: 400;
  margin-top: 2px;
  opacity: 0.85;
}



  

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style id="holdings-actions-align">
/* Align '+' and transfer buttons in holdings summary to the far right */
#holdingsTableWrap details > summary{
  display: flex;
  align-items: center;
  gap: 8px;
}
/* push the first small button to the right; the rest will follow */
#holdingsTableWrap details > summary .btn.small:first-of-type{
  margin-left: auto;
}

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style id="alerts-history-controls-fix">
/* Common class for the alerts history controls container */
.alerts-history-controls{
  display: flex !important;
  align-items: center;
  gap: 8px;
  white-space: nowrap;
  flex-wrap: nowrap;
}
/* Ensure button text color follows theme (same for both) */
.alerts-history-controls button,
.alerts-history-controls .btn,
.alerts-history-controls a[role="button"]{
  color: var(--foreground, inherit) !important;
}

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<style id="alerts-history-inline-fix2">
/* Force 'Odśwież' and 'Wyczyść' to sit inline and share text color */
#alertsPanel .filters .col-3,
#alertsPanel .filters .col,
#alertsPanel .filters .controls,
#alertsPanel .filters{
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
}
#alertsRefreshBtn, #alertsClearBtn{
  display: inline-flex !important;
  width: auto !important;
  min-width: 0 !important;
  flex: 0 0 auto !important;
  white-space: nowrap !important;
  vertical-align: middle !important;
}
/* unifying text color - match normal .btn dark text used on accent buttons */
#alertsClearBtn, #alertsRefreshBtn{
  color: #0b1222 !important;
}
/* subtle spacing if layout engine ignores gap */
#alertsRefreshBtn{ margin-right: 8px !important; }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style id="alerts-inline-controls-css">
.alerts-inline-controls{
  display: flex !important;
  align-items: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
}
/* keep buttons compact */
.alerts-inline-controls #alertsRefreshBtn,
.alerts-inline-controls #alertsClearBtn{
  display: inline-flex !important;
  flex: 0 0 auto !important;
  width: auto !important;
  min-width: 0 !important;
  white-space: nowrap !important;
}

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<style id="go-improved-chart-css-v3">
  .go-chart-wrap { position:relative; height: 640px; background: rgba(0,0,0,0.2); border-radius: 12px; border: 1px solid #1f2937; overflow: hidden; }
@media (max-width: 768px){ .go-chart-wrap{ height: 480px; } }
@media (min-width: 1400px){ .go-chart-wrap{ height: 740px; } }
  #go-line-chart { width:100%; height:100%; display:block; cursor: crosshair; }
  .chart-tooltip-improved {
    position: absolute;
    background: rgba(0,0,0,0.95);
    border: 2px solid #22d3ee;
    border-radius: 10px;
    padding: 14px 16px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    max-width: 340px;
    box-shadow: 0 8px 24px rgba(34,211,238,0.3);
    display: none;
    backdrop-filter: blur(6px);
    min-width: 280px;
  }
  .chart-tooltip-improved.visible { display: block; }
  .tooltip-row-improved{
    display:flex; justify-content:space-between; gap:12px;
    margin:6px 0; padding:4px 0; border-bottom:1px solid rgba(148,163,184,0.2);
  }
  .tooltip-row-improved:last-child{ border-bottom:none; }
  .tooltip-label-improved{ color:#94a3b8; font-weight:500; }
  .tooltip-value-improved{ font-weight:700; color:#22d3ee; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; text-align:right; }
</style>

<style>#go-line-chart-overlay{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;}</style>

<style id="auth-gate-css">
/* Hide the main UI until user authenticates */
.require-auth header,
.require-auth .layout,
.require-auth footer { display: none !important; }
/* Optional: You can show a blurred backdrop instead; keeping hidden for performance */
</style>
</head>
<body class="require-auth"><div id="authGate" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:99999;background:linear-gradient(120deg,#0b1222 0%,#0f172a 40%, #101525 100%);padding:18px;">
  <div style="width:min(520px,96vw);background:linear-gradient(180deg, rgba(17,24,39,.98), rgba(15,23,42,.98));border:1px solid #334155;border-radius:16px;box-shadow:0 12px 28px rgba(0,0,0,.35);padding:16px 16px 12px 16px;">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px;">
      <h2 style="margin:0;font-size:20px;">🔐 Logowanie • Twoje konto</h2>
      <button id="authCloseBtn" style="display:none;border:1px solid #334155;background:transparent;color:#94a3b8;border-radius:10px;padding:8px 12px;cursor:pointer;">Zamknij</button>
    </div>
    <div class="banner warn" style="display:none" id="authBanner"></div>
    <form id="authForm" style="display:grid;grid-template-columns:1fr;gap:10px;">
      <div>
        <label for="authEmail" style="display:block;font-size:13px;color:#94a3b8;margin-bottom:6px;">E‑mail</label>
        <input id="authEmail" type="email" placeholder="np. jan.kowalski@example.com" style="width:100%;padding:10px 12px;border-radius:10px;border:1px solid #334155;background:#0b1222;color:#e5e7eb;outline:none;">
      </div>
      <div>
        <label for="authPassword" style="display:block;font-size:13px;color:#94a3b8;margin-bottom:6px;">Hasło</label>
        <input id="authPassword" type="password" placeholder="••••••••" style="width:100%;padding:10px 12px;border-radius:10px;border:1px solid #334155;background:#0b1222;color:#e5e7eb;outline:none;">
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;">
        <button type="button" id="authLoginBtn" class="btn" style="border:none;border-radius:10px;padding:10px 14px;background:#22d3ee;color:#0b1222;font-weight:700;cursor:pointer;">Zaloguj</button>
        <button type="button" id="authRegisterBtn" class="btn" style="border:none;border-radius:10px;padding:10px 14px;background:#06b6d4;color:#0b1222;font-weight:700;cursor:pointer;">Utwórz konto</button>
        <button type="button" id="authResetBtn" class="btn" style="border:none;border-radius:10px;padding:10px 14px;background:#334155;color:#e5e7eb;font-weight:700;cursor:pointer;">Reset hasła</button>
      </div>
      <div class="small" style="font-size:12px;color:#94a3b8;opacity:.95;">Po zalogowaniu Twoje dane portfela będą trzymane per‑konto w Firestore i synchronizowane między urządzeniami. Lokalna pamięć zostanie powiązana z aktualnie zalogowanym kontem.</div>
    </form>
  </div>
</div>
<div id="toastsWrap"></div>

<header>
  <h1>📊 Portfele  <button class="btn ghost" id="portfoliosTabBtn" title="Widok portfeli">📂 Portfele</button> <button class="btn ghost" id="wishlistTabBtn" title="Lista życzeń (ceny kupna)">⭐ Lista życzeń</button> <button class="btn ghost" id="alertsTabBtn" title="Historia alarmów">🔔 Alarmy</button></h1>
<div class="actions"><button class="btn" id="addPortfolioBtn">➕ Nowy portfel</button>
    <button class="btn secondary" id="transferBtn">🔁 Przelew między portfelami</button>
    <button class="btn ghost" id="exportBtn">⬇️ Eksportuj JSON</button>
    <label for="importFile" class="btn ghost" style="cursor:pointer">⬆️ Importuj JSON</label>
    <input type="file" id="importFile" accept=".json,application/json" style="display:none" />
    <button class="btn warn" id="settingsBtn">⚙️ Ustawienia</button>
  
    <button class="btn ghost" id="firebaseUploadBtn" title="Wyślij do Firebase">☁️ Wyślij</button>
    <button class="btn ghost" id="firebaseDownloadBtn" title="Pobierz z Firebase">☁️ Pobierz</button>
    <button class="btn ghost" id="firebaseDiagBtn" title="Sprawdź połączenie z Firestore">🧪 Test</button>
    
    </div>
</header>
<div class="layout">
  <aside class="sidebar card">
    <div class="head">
      <div>
        <div style="font-weight:700">Twoje portfele</div>
        <div class="small">Każdy portfel to osobna „firma” ze swoją strategią</div>
      </div>
      <button class="btn ok" id="depositBtn" title="Szybki przelew gotówki do wybranego portfela">💰</button>
    </div>
    <div class="portfolios" id="portfolioList"></div>
  </aside>
  <main>
<section id="alertsPanel" style="display:none">
  <div class="card">
    <div class="card-header">
      <h2>🔔 Historia alarmów</h2>
    </div>
    <div class="card-body">
      <div class="grid" style="gap: 8px; align-items: end;">
        <div class="col-3">
          <label>Zakres</label>
          <select id="alertsScope">
            <option value="">Wszystko</option>
            <option value="portfolio">Portfele</option>
            <option value="wishlist">Lista życzeń</option>
          </select>
        </div>
        <div class="col-3">
          <label>Stan</label>
          <select id="alertsState">
            <option value="">Wszystko</option>
            <option value="hit">🎯 Cel osiągnięty</option>
            <option value="near">⏳ Blisko celu</option>
          </select>
        </div>
        <div class="col-3">
          <label>Rodzaj</label>
          <select id="alertsKind">
            <option value="">Wszystko</option>
            <option value="sell">SELL</option>
            <option value="buy">BUY</option>
          </select>
        </div>
        <div class="col-3">
          <button class="btn" id="alertsRefreshBtn">🔄 Odśwież</button> <button id="alertsClearBtn" class="btn small" title="Skasuj historię alarmów">🗑 Wyczyść</button>
        </div>
      </div>
      <div id="alertsStats" class="small" style="margin:8px 0;"></div>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Data</th>
              <th>Ticker</th>
              <th>Stan</th>
              <th>Rodzaj</th>
              <th>Cena</th>
              <th>Cel</th>
              <th>Źródło</th>
            </tr>
          </thead>
          <tbody id="alertsTableBody">
            <tr><td colspan="7" class="muted">Brak danych…</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</section>


    <section id="wishlistPanel" class="card panel" style="display:none">
      <div class="row">
        <h2>⭐ Lista życzeń (cele KUPNA)</h2>
        <div class="spacer"></div>
      </div>
      <div class="grid">
        <div class="col-4">
          <label>Ticker</label>
          <div class="row" style="gap:6px">
            <input id="wlTicker" placeholder="np. TSLA / PKN.WA" />
            <button class="btn ghost" id="wlSearch">Szukaj</button>
          </div>
        </div>
        <div class="col-4">
          <label>Cena docelowa (kupno)</label>
          <input id="wlPrice" type="number" step="0.0001" min="0" placeholder="np. 300.00" />
        </div>
        <div class="col-4">
          <label>&nbsp;</label>
          <button class="btn" id="wlAdd">➕ Dodaj do listy</button>
        </div>
        <div class="col-12">
          <label>Wyniki wyszukiwania</label>
          <div id="wlSearchResults" class="card panel" style="padding:8px; max-height:220px; overflow:auto"></div>
        </div>
      </div>
      <div style="margin-top:10px"></div>
      <div id="wlTableWrap"></div>
      <div class="small" style="margin-top:8px">Sortowanie wg. odległości od celu; gdy kurs ≤ cel: wiersz mruga na zielono; gdy blisko (≤ tolerancja z Ustawień): delikatne mruganie.</div>
    </section>

    <section class="card panel">
      <div class="row">
        <h2 id="pfTitle">Wybierz portfel</h2>
        <div class="spacer"></div>
        <button class="btn secondary" id="renameBtn">✏️ Zmień nazwę</button>
        <button class="btn danger" id="deleteBtn">🗑️ Usuń portfel</button>
      </div>
      <div class="grid">
        <div class="col-6">
          <label>Strategia / Notatki</label>
          <textarea id="strategyBox" rows="4" placeholder="Opisz krótko zasady tej 'firmy' (np. dywidendy, momentum, swing itp.)"></textarea>
          <div class="small">Zapisywane automatycznie.</div>
        </div>
        <div class="col-6">
          <div class="grid">
            <div class="col-6">
              <div class="stat">
                <div>
                  <div class="muted">Saldo gotówki</div>
                  <div id="cashBalance" style="font-size:20px; font-weight:800">—</div>
                </div>
                <button class="btn ok" id="cashActionsBtn">💵 Operacje</button>
              </div>
            </div>
            <div class="col-6">
              <div class="stat">
                <div>
                  <div class="muted">Zysk/Strata (zrealizowane)</div>
                  <div style="font-size:20px; font-weight:800">
                    <span id="realizedPL">—</span>
                    <span class="small">(<span id="realizedPLnet">netto</span>)</span>
                  </div>
                </div>
                <div class="tag">liczone tylko po sprzedaży</div>
              </div>
            </div>
            <div class="col-12">
              <div class="row">
                <button class="btn" id="buyBtn">🛒 Zakup</button>
                <button class="btn" id="sellBtn">💸 Sprzedaż (dowolne partie)</button>
                <button class="btn secondary" id="withdrawBtn">🏧 Wypłata</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="card panel">
      <div class="row">
        <h2>Stan posiadania (partie i średni koszt)</h2>
        <div class="spacer"></div>
        <span class="small">Kursy na żywo z Finnhub (bez konwersji walut). Ustaw token w ⚙️ Ustawienia.</span>
      </div>
      <div id="holdingsTableWrap"></div>
    </section>

    <section id="historyPanel" class="card panel">
      <div class="row">
        <h2 id="historyTitle" class="clickable">Historia operacji</h2>
        <div class="spacer"></div>
        <button id="historyCollapseBtn" class="btn small" title="Zwiń/Rozwiń"><span class="chev">▾</span></button>
        <label class="small" for="filterQuery">Filtr</label>
        <input id="filterQuery" placeholder="np. typ:sell TSLA 2025-09" style="max-width:300px" />
        <button class="btn small ghost" id="filterClearBtn">Wyczyść</button>
      </div>
      <div id="txTableWrap"></div>
    </section>

    <footer>
      v2 • Dane zapisywane lokalnie w przeglądarce (localStorage) oraz w chmurze. Zawsze możesz <span class="link" id="exportLink2">eksportować JSON</span> i później go <span class="link" id="importLink2">zaimportować</span>.
    </footer>
  </main>
</div>

<!-- Modale -->
<dialog id="modal">
  <div class="modal">
    <header>
      <h3 id="modalTitle">Modal</h3>
    </header>
    <div class="content" id="modalContent">—</div>
    <footer>
      <button class="btn ghost" id="modalCancel">Anuluj</button>
      <button class="btn" id="modalOk">Zapisz</button>
    </footer>
  </div>
</dialog>

<script>
(()=>{
  const KEY = "portfele_firmy_v1";


// === [UNDO] Migawki bazy z TTL 2 dni ===
const UNDO_KEY = KEY + '__undo';
const UNDO_TTL_MS = 2*24*60*60*1000; // 2 dni
const UNDO_MAX = 60; // ograniczenie wielkości historii (ring buffer)
window.__UNDO_RESTORING = false; // guard przed nasłuchem Firestore w trakcie przywracania

function __undoLoad(){
  try{ return JSON.parse(localStorage.getItem(UNDO_KEY) || '[]'); }catch(_){ return []; }
}
function __undoSave(stack){ try{ localStorage.setItem(UNDO_KEY, JSON.stringify(stack)); }catch(_){} }
function __undoPrune(stack=null){
  const now = Date.now();
  const s = (stack || __undoLoad()).filter(it => (now - (it.ts||0)) < UNDO_TTL_MS);
  if(s.length > UNDO_MAX) s.splice(0, s.length - UNDO_MAX);
  __undoSave(s);
  __undoUpdateBtn();
  return s;
}
function __makeSnapshot(kind='tx'){
  return { ts: Date.now(), kind, label: '', db: JSON.stringify(DB), currentPfId };
}
function pushUndo({label='Zmiana', kind='tx'} = {}){
  try{
    const s = __undoPrune();
    const snap = __makeSnapshot(kind); snap.label = label;
    s.push(snap);
    __undoSave(s);
    __undoUpdateBtn();
  }catch(_){}
}
function canUndo(){ return __undoPrune().length > 0; }

function __findSnapshotToUndo(mode='tx'){
  // mode: 'tx' (domyślnie skaczemy do ostatniej transakcyjnej), 'any' (krokowo)
  const s = __undoPrune();
  if(s.length===0) return {stack:s, target:null, idx:-1};
  if(mode==='any'){
    return {stack:s, target:s[s.length-1], idx:s.length-1};
  }
  for(let i=s.length-1;i>=0;i--){
    if((s[i].kind||'tx')==='tx') return {stack:s, target:s[i], idx:i};
  }
  // jeśli nie ma 'tx', weź ostatnią jakąkolwiek
  return {stack:s, target:s[s.length-1], idx:s.length-1};
}

function undo({mode='tx'}={}){
  const found = __findSnapshotToUndo(mode);
  const s = found.stack;
  const target = found.target;
  const idx = found.idx;
  if(!target){ alert('Brak cofnięć (historia pusta lub po TTL).'); return; }
  try{
    window.__UNDO_RESTORING = true;
    DB = JSON.parse(target.db);
    currentPfId = target.currentPfId || (DB.portfolios && DB.portfolios[0] && DB.portfolios[0].id) || null;
    if (typeof save === 'function') save();
    if (typeof render === 'function') render();
    try{ if(typeof window.hardUpload==='function'){ const r = window.hardUpload(); if(r && typeof r.then==='function'){ r.then(()=>{}).catch(()=>{}); } } }catch(_){}
    alert('Cofnięto: ' + (target.label || 'zmianę'));
  }catch(e){
    alert('Nie udało się cofnąć: ' + (e && e.message || e));
  }finally{
    // usuń wszystkie migawki od końca aż do wybranej (włącznie)
    s.splice(idx, s.length - idx);
    __undoSave(s);
    __undoUpdateBtn();
    setTimeout(()=>{ window.__UNDO_RESTORING = false; }, 1500);
  }
}

function __undoUpdateBtn(){
  try{
    const btn = document.getElementById('undoBtn');
    if(!btn) return;
    const n = (__undoLoad() || []).filter(it => (Date.now() - (it.ts||0)) < UNDO_TTL_MS).length;
    btn.disabled = n===0;
    btn.title = n ? `Cofnij (w historii: ${n}; wygasa po 2 dniach)` : 'Brak rzeczy do cofnięcia';
  }catch(_){}
}

document.addEventListener('DOMContentLoaded', ()=>{
  const btn = document.getElementById('undoBtn');
  if(btn) btn.addEventListener('click', (e)=>{
    // Shift+klik -> tryb 'any' (krokowo), zwykły klik -> 'tx' (skok do ostatniej transakcji)
    undo({mode: e && e.shiftKey ? 'any' : 'tx'});
  });
  __undoUpdateBtn();
});
document.addEventListener('keydown', (e)=>{
  const key = String(e.key||'').toLowerCase();
  if((e.ctrlKey||e.metaKey) && key==='z'){
    e.preventDefault();
    // Ctrl/Cmd+Shift+Z -> 'any', zwykłe Ctrl/Cmd+Z -> 'tx'
    undo({mode: e.shiftKey ? 'any' : 'tx'});
  }
});

  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));

  const fmtCurrency = (n, cur) => {
    if(n === null || n === undefined || isNaN(n)) return "—";
    try{
      return new Intl.NumberFormat('pl-PL', { style:'currency', currency: cur || 'PLN', minimumFractionDigits:2, maximumFractionDigits:2 }).format(n);
    }catch(e){
      return (n.toFixed(2)) + ' ' + (cur||'PLN');
    }
  };
  const fmtNum = (n, d=2) => (n ?? n===0) ? Number(n).toFixed(d) : "—";
  const id = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

  const defaultDB = ()=> ({
    version: 1,
    settings: { taxRate: 0.19, allowNegativeCash: false, currencyDefault: "PLN", finnhubToken: "", pricePollSeconds: 45, approachTolerancePct: 1 },
    portfolios: [],
    watchlist: []
  });
  let DB = null;
  try{
    DB = JSON.parse(localStorage.getItem(KEY)) || defaultDB();
  }catch(e){
    DB = defaultDB();
  }
  const save = ()=> localStorage.setItem(KEY, JSON.stringify(DB));

  let currentPfId = DB.portfolios[0]?.id || null;

  // UI Elements
  const portfolioListEl = $("#portfolioList");
  const pfTitleEl = $("#pfTitle");
  const strategyBox = $("#strategyBox");
  const cashBalanceEl = $("#cashBalance");
  const realizedPLEl = $("#realizedPL");
  const realizedPLnetEl = $("#realizedPLnet");
  const holdingsTableWrap = $("#holdingsTableWrap");
  const txTableWrap = $("#txTableWrap");
  const filterQueryEl = $("#filterQuery");

  // Modal helpers
  const modal = $("#modal");
  const modalTitle = $("#modalTitle");
  const modalContent = $("#modalContent");
  const modalOk = $("#modalOk");
  const modalCancel = $("#modalCancel");
  let modalResolve = null;
  modalCancel.addEventListener('click', ()=> closeModal(null));
  function openModal({title, innerHTML, okText="Zapisz", cancelText="Anuluj"}){
    modalTitle.textContent = title;
    modalContent.innerHTML = innerHTML;
    $("#modalOk").textContent = okText;
    $("#modalCancel").textContent = cancelText;
    modal.showModal();
    return new Promise(res=> modalResolve = res);
  }
  function closeModal(result){
    modal.close();
    if(modalResolve){ const r = modalResolve; modalResolve = null; r(result); }
  }
  modalOk.addEventListener('click', ()=> {
    // By default, collect form values into an object
    const form = modalContent.querySelector("form");
    if(form){
      const data = Object.fromEntries(new FormData(form).entries());
      closeModal(data);
    }else{
      closeModal(true);
    }
  });

  // Core operations

  // === Rebuild from transactions (chronological replay) ===
  
// --- Helper: find lot by lotId across holdings
function getLotById(pf, lotId){
  if(!pf || !lotId) return null;
  for(const [ticker, h] of Object.entries(pf.holdings||{})){
    for(const lot of (h.lots||[])){
      if(lot.lotId === lotId) return lot;
    }
  }
  return null;
}
function ensureBuyLotIdInTx(tx){
    // Assign stable lotId to buy tx if missing (backward compat)
    if(tx.type==="buy" && !tx.lotId){
      tx.lotId = tx.id || id();
    }
  }
  function cloneEmptyState(pf){
    return { cash: 0, holdings: {} };
  }
  function applyBuy(state, pf, tx){
    const tkr = tx.ticker.trim().toUpperCase();
    const q = Number(tx.qty)||0;
    const p = Number(tx.price)||0;
    const f = Number(tx.fees)||0;
    state.cash -= (q*p + f);
    state.holdings[tkr] ||= { lots: [] };
    const lotIdStable = tx.lotId;
    const lot = { lotId: lotIdStable, date: tx.date || today(), qty: q, unitCost: p + (f/q||0), rawPrice: p, fees: f, note: tx.note||"", targetPct: (tx.targetPct??null), targetPrice: (tx.targetPrice??null), buyTargetPct: (tx.buyTargetPct??null), buyTargetPrice: (tx.buyTargetPrice??null) };
    state.holdings[tkr].lots.push(lot);
  }
  function applySell(state, pf, tx){
  const tkr = tx.ticker.trim().toUpperCase();
  const pSell = Number(tx.price||tx.sellPrice||0);
  const f = Number(tx.fees)||0;
  const links = (tx.lotLinks||[]).map(x=>({lotId: x.lotId, qty: Number(x.qty)||0})).filter(x=>x.qty>0);
  // Prepare errors array
  state.__errors = state.__errors || [];
  function softError(msg){
    try{ state.__errors.push({ticker:tkr, id: tx.id||null, date: tx.date||null, message: String(msg)}); }catch(_){}
  }
  let proceeds = 0, grossPL = 0;
  const book = state.holdings[tkr];
  if(!book){
    softError("Sprzedaż bez pozycji ("+tkr+").");
    // Keep tx derived fields consistent but do not mutate state
    tx.qty = links.reduce((a,b)=>a+b.qty,0);
    tx.proceeds = 0; tx.grossPL = 0; tx.tax = 0; tx.netPL = 0;
    return;
  }
  for(const link of links){
    const lot = book.lots.find(l=>l.lotId===link.lotId);
    if(!lot){
      softError("Brak partii "+link.lotId+" przy sprzedaży "+tkr);
      continue;
    }
    if(link.qty > lot.qty + 1e-9){
      softError("Sprzedaż przekracza ilość w partii ("+tkr+").");
      continue;
    }
    proceeds += link.qty * pSell;
    grossPL += link.qty * (pSell - lot.unitCost);
  }
  grossPL -= f;
  const tax = grossPL>0 ? grossPL*(DB.settings.taxRate||0.19) : 0;
  const netPL = grossPL - tax;
  // Update cash & reduce lots only for links that were valid
  state.cash += (proceeds - f);
  for(const link of links){
    const lot = (book.lots||[]).find(l=>l.lotId===link.lotId);
    if(lot && link.qty <= lot.qty + 1e-9){
      lot.qty -= link.qty;
    }
  }
  book.lots = book.lots.filter(l=>l.qty>1e-9);
  // Mutate tx to keep derived fields consistent
  tx.qty = links.reduce((a,b)=>a+b.qty,0);
  tx.price = pSell;
  tx.proceeds = proceeds;
  tx.grossPL = grossPL;
  tx.tax = tax;
  tx.netPL = netPL;
}

function applyTransferCompanyIn(state, pf, tx){
    const tkr = (tx.ticker||'').trim().toUpperCase();
    const q = Number(tx.qty)||0;
    const uc = Number(tx.unitCost ?? tx.price ?? 0) || 0;
    state.holdings[tkr] ||= { lots: [] };
    const lotId = tx.newLotId || tx.lotId || id();
    const lot = { lotId, date: tx.date || today(), qty: q, unitCost: uc, rawPrice: uc, fees: Number(tx.fees)||0, note: tx.note||"" };
    state.holdings[tkr].lots.push(lot);
  }

function applyTransferCompanyOut(state, pf, tx){
    const tkr = (tx.ticker||'').trim().toUpperCase();
    const q = Number(tx.qty)||0;
    const book = state.holdings[tkr];
    if(!book) return; // nothing to remove
    if(tx.lotId){
      const idx = book.lots.findIndex(l=>l.lotId===tx.lotId);
      if(idx>=0){
        const lot = book.lots[idx];
        lot.qty -= q;
        if(lot.qty <= 1e-9){ book.lots.splice(idx,1); }
      }
    }else{
      // Fallback: remove qty from first lots FIFO
      let remaining = q;
      for(const lot of book.lots){
        if(remaining<=1e-9) break;
        const take = Math.min(lot.qty, remaining);
        lot.qty -= take;
        remaining -= take;
      }
      book.lots = book.lots.filter(l=>l.qty>1e-9);
    }
  }

  function applyCash(state, type, amount){
    const a = Number(amount)||0;
    if(type==="deposit" || type==="transfer_in") state.cash += a;
    if(type==="withdraw" || type==="transfer_out") state.cash -= a;
  }
  function rebuildPortfolio(pf){
    // --- Preserve per-lot muted flags BEFORE rebuild (by stable lotId) ---
    const __prevMuted = {};
    try{
      const prevHoldings = pf && pf.holdings ? pf.holdings : {};
      for(const [tk, book] of Object.entries(prevHoldings)){
        for(const lot of (book.lots||[])){
          if(lot && lot.lotId){ __prevMuted[lot.lotId] = !!lot.muted; }
        }
      }
    }catch(_){}

    // Replay from oldest to newest
    const txsChrono = pf.transactions.slice().reverse();
    const state = cloneEmptyState(pf);
    state.__errors = [];
    for(const tx of txsChrono){
      if(tx.type==="deposit" || tx.type==="withdraw" || tx.type==="transfer_in" || tx.type==="transfer_out"){
        applyCash(state, tx.type, tx.amount);
      }else if(tx.type==="buy"){
        ensureBuyLotIdInTx(tx);
        applyBuy(state, pf, tx);
      }else if(tx.type === "sell"){
        const sellDateMs = toMs(tx.date);
        applySell(state, pf, tx);
      }else if(tx.type==="transfer_company_in"){
        applyTransferCompanyIn(state, pf, tx);
      }else if(tx.type==="transfer_company_out"){
        applyTransferCompanyOut(state, pf, tx);
      }
    }

    // --- Re-apply muted flags to rebuilt lots (matching by lotId) ---
    try{
      for(const [tk, book] of Object.entries(state.holdings||{})){
        for(const lot of (book.lots||[])){
          if(lot && lot.lotId && (__prevMuted[lot.lotId] === true || __prevMuted[lot.lotId] === false)){
            lot.muted = __prevMuted[lot.lotId];
          }
        }
      }
    }catch(_){}

    
    // --- Prune empty/zero-qty lots and remove empty tickers (anti-ghost) ---
    try {
      for (const [tk, book] of Object.entries(state.holdings || {})) {
        const lots = Array.isArray(book.lots) ? book.lots : [];
        // drop zero-qty lots
        book.lots = lots.filter(l => Number(l && l.qty || 0) > 1e-9);
        // remove ticker entirely if no lots left
        if (!book.lots.length) {
          delete state.holdings[tk];
        }
      }
    } catch (_) {}
pf.__errors = Array.isArray(state.__errors) ? state.__errors : [];
    pf.cash = state.cash;
    pf.holdings = state.holdings;
    pf.updatedAt = new Date().toISOString();
  }
  function getPf(id){ return DB.portfolios.find(p=>p.id===id) || null; }
  function ensureCurrency(cur){ return cur || DB.settings.currencyDefault || "PLN"; }

  function addPortfolio(){
  try{ pushUndo({label:"Dodanie portfela", kind:'tx'}); }catch(_){}

    const newPf = {
      id: id(),
      name: "Nowy portfel",
      currency: DB.settings.currencyDefault || "PLN",
      strategy: "",
      cash: 0,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      holdings: {}, // ticker -> { lots: [ {lotId, date, qty, unitCost, rawPrice, fees, note} ] }
      transactions: [] // list of tx objects
    };
    DB.portfolios.push(newPf);
    currentPfId = newPf.id;
    save(); render();
  }

  function deletePortfolio(pfId){
  try{ pushUndo({label:"Usuni\u0119cie portfela", kind:'tx'}); }catch(_){}

    const idx = DB.portfolios.findIndex(p=>p.id===pfId);
    if(idx>=0){ DB.portfolios.splice(idx,1); if(currentPfId===pfId) currentPfId = DB.portfolios[0]?.id || null; save(); render(); }
  }

  function renamePortfolio(pfId, name){
  try{ pushUndo({label:"Zmiana nazwy portfela", kind:'meta'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    pf.name = name; pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  function setStrategy(pfId, text){
  try{ pushUndo({label:"Edycja strategii/notatki", kind:'meta'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    pf.strategy = text; pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  function deposit(pfId, amount, note=""){
  try{ pushUndo({label:"Wp\u0142ata got\u00f3wki", kind:'tx'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    const amt = Number(amount)||0;
    pf.cash += amt;
    pf.transactions.unshift({ id:id(), type:"deposit", date:today(), amount:amt, note });
    pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }
  function withdraw(pfId, amount, note=""){
  try{ pushUndo({label:"Wyp\u0142ata got\u00f3wki", kind:'tx'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    const amt = Number(amount)||0;
    if(!DB.settings.allowNegativeCash && pf.cash < amt){ alert("Brak środków. Włącz opcję 'Zezwól na saldo ujemne' w Ustawieniach, jeśli chcesz kontynuować."); return; }
    pf.cash -= amt;
    pf.transactions.unshift({ id:id(), type:"withdraw", date:today(), amount:amt, note });
    pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  function transfer(fromId, toId, amount, note=""){
  try{ pushUndo({label:"Przelew mi\u0119dzy portfelami", kind:'tx'}); }catch(_){}

  if(fromId===toId){ alert("Wybierz różne portfele."); return; }
  const from = getPf(fromId), to = getPf(toId);
  const amt = Number(amount)||0;
  if(!from || !to) return alert("Nieprawidłowe portfele.");
  if(!DB.settings.allowNegativeCash && from.cash < amt){ alert("Brak środków w portfelu źródłowym."); return; }
  from.cash -= amt;
  to.cash += amt;
  const stamp = today();
  const linkId = id();
  from.transactions.unshift({ id:id(), linkId, type:"transfer_out", date:stamp, amount:amt, note, counterpartyPortfolioId: to.id });
  to.transactions.unshift({ id:id(), linkId, type:"transfer_in",  date:stamp, amount:amt, note, counterpartyPortfolioId: from.id });
  from.updatedAt = to.updatedAt = new Date().toISOString();
  save(); render();
}


async function transferCompanyDialog(fromPfId, ticker) {
  const fromPf = getPf(fromPfId);
  if(!fromPf) return alert("Błąd: portfel źródłowy nie istnieje.");
  const book = (fromPf.holdings||{})[ticker];
  if(!book || !book.lots || !book.lots.length) return alert("Brak pakietów do przeniesienia.");
  const targetPortfolios = DB.portfolios.filter(p => p.id !== fromPfId);
  if(!targetPortfolios.length) return alert("Brak innych portfeli do przeniesienia.");
  const opts = targetPortfolios.map(p => `<option value="${p.id}">${__esc(p.name)} (${p.currency})</option>`).join("");
  const totalQty = book.lots.reduce((sum, lot) => sum + Number(lot.qty||0), 0);
  const totalValue = book.lots.reduce((sum, lot) => sum + (Number(lot.qty||0) * Number(lot.unitCost||0)), 0);
  const lotsList = book.lots.map((lot, i) => 
    `<tr>
      <td>${i+1}</td>
      <td>${__esc(lot.date||"")}</td>
      <td>${__fmtNum(lot.qty||0)}</td>
      <td>${__go_fmtCurrency(lot.unitCost||0, fromPf.currency)}</td>
      <td>${__go_fmtCurrency((Number(lot.qty||0) * Number(lot.unitCost||0)), fromPf.currency)}</td>
    </tr>`
  ).join("");

  const data = await openModal({
    title: `Przenieś całą spółkę ${ticker}`,
    innerHTML: `<form class="grid">
      <div class="col-6">
        <label>Portfel docelowy</label>
        <select name="toPortfolioId" required>${opts}</select>
      </div>
      <div class="col-6">
        <label>Data przeniesienia</label>
        <input name="date" type="date" value="${today()}" required />
      </div>
      <div class="col-12">
        <label>Notatka (opcjonalnie)</label>
        <input name="note" placeholder="np. reorganizacja portfeli" />
      </div>
      <div class="col-12">
        <h4>Pakiety do przeniesienia:</h4>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>#</th><th>Data</th><th>Ilość</th><th>Koszt/szt</th><th>Wartość</th></tr>
            </thead>
            <tbody>${lotsList}</tbody>
            <tfoot>
              <tr style="font-weight:bold">
                <td colspan="2">RAZEM:</td>
                <td>${__fmtNum(totalQty)}</td>
                <td>—</td>
                <td>${__go_fmtCurrency(totalValue, fromPf.currency)}</td>
              </tr>
            </tfoot>
          </table>
        </div>
        <div class="small warn-text">
          UWAGA: Operacja przeniesie wszystkie pakiety akcji ${ticker} 
          z portfela "${fromPf.name}" do wybranego portfela docelowego.
        </div>
      </div>
    </form>`,
    okText: "Przenieś spółkę",
    cancelText: "Anuluj"
  });
  if(data) {
    await transferCompany(fromPfId, data.toPortfolioId, ticker, data.date, data.note||"");
  }
}

async function transferCompany(fromPfId, toPfId, ticker, date, note = "") {
  try{ pushUndo({label:"Transfer sp\u00f3\u0142ki", kind:'tx'}); }catch(_){}

  if(fromPfId === toPfId) return alert("Portfel źródłowy i docelowy są identyczne.");
  const fromPf = getPf(fromPfId);
  const toPf = getPf(toPfId);
  if(!fromPf || !toPf) return alert("Błąd: nieprawidłowe portfele.");
  const book = (fromPf.holdings||{})[ticker];
  if(!book || !book.lots || !book.lots.length) return alert("Brak pakietów do przeniesienia.");
  if(fromPf.currency !== toPf.currency) {
    const proceed = confirm(
      `Uwaga: Różne waluty!\n` +
      `Z: ${fromPf.name} (${fromPf.currency})\n` +
      `Do: ${toPf.name} (${toPf.currency})\n\n` +
      `Czy kontynuować przeniesienie?`
    );
    if(!proceed) return;
  }
  try{
    const transferDate = date || today();
    const linkId = id();
    toPf.holdings[ticker] = toPf.holdings[ticker] || { lots: [] };
    for(const lot of book.lots){
      const newLotId = id();
      const newLot = {
        ...lot,
        lotId: newLotId,
        transferredFrom: {
          originalLotId: lot.lotId,
          fromPortfolioId: fromPfId,
          fromPortfolioName: fromPf.name,
          transferDate: transferDate,
          transferLinkId: linkId
        }
      };
      toPf.holdings[ticker].lots.push(newLot);
      toPf.transactions.unshift({
        id: id(),
        linkId: linkId,
        type: "transfer_company_in",
        date: transferDate,
        ticker: ticker,
        qty: Number(lot.qty)||0,
        price: Number(lot.rawPrice ?? lot.unitCost) || 0,
        unitCost: Number(lot.unitCost)||0,
        fees: Number(lot.fees)||0,
        note: `Transfer spółki ${ticker} z portfela "${fromPf.name}". ${note}`.trim(),
        counterpartyPortfolioId: fromPfId,
        originalLotId: lot.lotId,
        newLotId: newLotId
      });
    }
    for(const lot of book.lots){
      fromPf.transactions.unshift({
        id: id(),
        linkId: linkId,
        type: "transfer_company_out",
        date: transferDate,
        ticker: ticker,
        qty: Number(lot.qty)||0,
        price: Number(lot.rawPrice ?? lot.unitCost) || 0,
        unitCost: Number(lot.unitCost)||0,
        fees: Number(lot.fees)||0,
        note: `Transfer spółki ${ticker} do portfela "${toPf.name}". ${note}`.trim(),
        counterpartyPortfolioId: toPfId,
        lotId: lot.lotId
      });
    }
    delete fromPf.holdings[ticker];
    const now = new Date().toISOString();
    fromPf.updatedAt = now;
    toPf.updatedAt = now;
    try { rebuildPortfolio(fromPf); rebuildPortfolio(toPf); } catch(_) {} save(); render();
    alert(
      `Transfer zakończony!\n\n` +
      `Spółka: ${ticker}\n` +
      `Z: ${fromPf.name} → ${toPf.name}\n` +
      `Pakietów: ${book.lots.length}\n` +
      `Data: ${transferDate}`
    );
  }catch(error){
    console.error("Błąd transferu spółki:", error);
    alert(`Błąd podczas transferu: ${error.message}`);
  }
}

async function buy(pfId, {ticker, date, qty, price, fees, note, targetPct, targetPrice, buyTargetPct, buyTargetPrice}){
  try{ pushUndo({label:"Zakup", kind:'tx'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    ticker = (ticker||"").trim().toUpperCase();
    const q = Math.max(0, Number(qty)||0);
    const p = Number(price)||0;
    const f = Number(fees)||0;
    if(!ticker || q<=0 || p<=0){ return alert("Uzupełnij poprawnie: ticker, ilość, cenę."); }
    const cashOut = q*p + f;
    if(!DB.settings.allowNegativeCash && pf.cash < cashOut){ return alert("Brak środków na zakup (sprawdź saldo gotówki)."); }
    pf.cash -= cashOut;
    pf.holdings[ticker] ||= { lots: [] };
    const lot = { lotId: id(), date: date || today(), qty: q, unitCost: p + (f/q||0), rawPrice: p, fees: f, note: note||"", targetPct: (targetPct!==undefined && targetPct!=="" ? Number(targetPct) : null), targetPrice: (targetPrice!==undefined && targetPrice!=="" ? Number(targetPrice) : null), buyTargetPct: (buyTargetPct!==undefined && buyTargetPct!=="" ? Number(buyTargetPct) : null), buyTargetPrice: (buyTargetPrice!==undefined && buyTargetPrice!=="" ? Number(buyTargetPrice) : null) };
    pf.holdings[ticker].lots.push(lot);
    pf.transactions.unshift({ id:id(), type:"buy", date: date || today(), ticker, qty:q, price:p, fees:f, note: note, lotId: lot.lotId, targetPct: lot.targetPct, targetPrice: lot.targetPrice, buyTargetPct: lot.buyTargetPct, buyTargetPrice: lot.buyTargetPrice });
    pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  function sell(pfId, {ticker, date, sellPrice, fees, allocations, note}){
  try{ pushUndo({label:"Sprzeda\u017c", kind:'tx'}); }catch(_){}

    const pf = getPf(pfId); if(!pf) return;
    ticker = (ticker||"").trim().toUpperCase();
    const pSell = Number(sellPrice)||0;
    const f = Number(fees)||0;
    if(!ticker || pSell<=0){ return alert("Uzupełnij poprawnie: ticker i cenę sprzedaży."); }
    const book = pf.holdings[ticker]; if(!book){ return alert("Brak pozycji na ten ticker."); }
    // Validate allocations
    let totalQty = 0;
    allocations = allocations.filter(a=>a.qty>0);
    if(allocations.length===0){ return alert("Wybierz ilość do sprzedaży w co najmniej jednej partii."); }
    for(const a of allocations){ totalQty += a.qty; }
    // Proceeds and P/L
    const proceeds = totalQty * pSell;
    let grossPL = 0;
    for(const a of allocations){
      const lot = book.lots.find(l=>l.lotId===a.lotId);
      if(!lot) return alert("Nie znaleziono partii.");
      if(a.qty > lot.qty){ return alert("Sprzedawana ilość przekracza ilość w partii."); }
      grossPL += a.qty * (pSell - lot.unitCost);
    }
    grossPL -= f;
    const tax = grossPL>0 ? grossPL * (DB.settings.taxRate || 0.19) : 0;
    const netPL = grossPL - tax;
    // Apply inventory changes
    for(const a of allocations){
      const lot = book.lots.find(l=>l.lotId===a.lotId);
      lot.qty -= a.qty;
    }
    book.lots = book.lots.filter(l=>l.qty>0.0000001);
    // Add cash
    pf.cash += (proceeds - f);
    // Record TX
    pf.transactions.unshift({
      id:id(), type:"sell", date: date || today(), ticker,
      qty: totalQty, price: pSell, fees: f,
      proceeds, grossPL, tax, netPL,
      lotLinks: allocations.map(a=>({ lotId:a.lotId, qty:a.qty })),
      note
    });
    // Cleanup empty ticker
    if(book.lots.length===0){ delete pf.holdings[ticker]; }
    pf.updatedAt = new Date().toISOString(); try { rebuildPortfolio(pf); } catch(_) {} save(); render();
  }

  // Rendering

  // Compute holdings (using live quote if available, else unitCost) and totals
  function computeHoldingsAndTotalValues(pf){
    try{
      let holdingsValue = 0;
      for(const [ticker, book] of Object.entries(pf.holdings||{})){
        const lots = (book && Array.isArray(book.lots)) ? book.lots : [];
        const qPrice = getQuote(ticker);
        for(const l of lots){
          const qty = Number(l.qty)||0;
          const unit = (qPrice!=null ? Number(qPrice) : Number(l.unitCost)||0);
          holdingsValue += qty * unit;
        }
      }
      const totalWithCash = holdingsValue + (Number(pf.cash)||0);
      return { holdingsValue, totalWithCash };
    }catch(e){
      return { holdingsValue: 0, totalWithCash: Number(pf.cash)||0 };
    }
  }

function renderPortfolioList(){
  setTimeout(()=>{ try { updateSidebarBlinkStates(); } catch(e) {} }, 0);

    portfolioListEl.innerHTML = "";
    for(const pf of ((typeof ST!=='undefined' && ST.DB && Array.isArray(ST.DB.portfolios)) ? ST.DB.portfolios : ((typeof DB!=='undefined' && Array.isArray(DB.portfolios)) ? DB.portfolios : []))){
      const totalLots = Object.values(pf.holdings).reduce((acc, v)=> acc + v.lots.length, 0);
      const el = document.createElement("div");
      el.className = "portfolio-item" + (pf.id===currentPfId ? " active": "");
      el.dataset.pfId = pf.id;
      try {
        const _state = portfolioTargetState(pf);
        if(_state === "hit") el.classList.add("hit-target");
        else if(_state === "near") el.classList.add("near-target");
      } catch(e) {}

      el.innerHTML = `
        <div class="name">${__esc(pf.name)}</div>
        <div class="row">
          <div class="tag">Gotówka: ${__go_fmtCurrency(pf.cash, pf.currency)}</div>
        <div class="row">
          <div class="tag">Akcje: ${__go_fmtCurrency((computeHoldingsAndTotalValues(pf).holdingsValue), pf.currency)}</div>
          <div class="tag">Razem: ${__go_fmtCurrency((computeHoldingsAndTotalValues(pf).totalWithCash), pf.currency)}</div>
        </div>

          <div class="tag">Partie: ${totalLots}</div>
        </div>
        <div class="row">
          <div class="small">Waluta: ${pf.currency}</div>
          <div class="small">modyf: ${new Date(pf.updatedAt).toLocaleDateString('pl-PL')}</div>
        </div>
      `;
      el.addEventListener('click', ()=> { 
      try{ 
        const main = document.querySelector('.main') || document.querySelector('main');
        if(main){
          main.querySelectorAll(':scope > section').forEach(sec=>{
            if(sec.id==='alertsPanel' || sec.id==='wishlistPanel') sec.style.display='none'; else sec.style.display='';
          });
        }
      }catch(_){}
      currentPfId = pf.id; render(); 
    });
      portfolioListEl.appendChild(el);
    }
    if(!currentPfId && DB.portfolios.length===0){
      const empty = document.createElement('div');
      empty.className="small";
      empty.innerHTML = "Brak portfeli. Kliknij <b>Nowy portfel</b>, aby rozpocząć.";
      portfolioListEl.appendChild(empty);
    }
  }

  function renderMain(){
    const pf = getPf(currentPfId);
    if(!pf){
      pfTitleEl.textContent = "Wybierz portfel";
      cashBalanceEl.textContent = "—";
      realizedPLEl.textContent = "—";
      realizedPLnetEl.textContent = "netto";
      strategyBox.value = "";
      holdingsTableWrap.innerHTML = "";
      txTableWrap.innerHTML = "";
      return;
    }
    ensureTransactionsCoherent(pf);
    maybeWarnTxLoss(pf);
    pfTitleEl.textContent = `${pf.name} (${pf.currency})`;
    strategyBox.value = pf.strategy || "";
    cashBalanceEl.textContent = __go_fmtCurrency(pf.cash, pf.currency);
    const {sumGross, sumTax, sumNet} = realizedSums(pf);
    realizedPLEl.textContent = __go_fmtCurrency(sumGross, pf.currency);
    realizedPLnetEl.textContent = __go_fmtCurrency(sumNet, pf.currency);

    // Holdings table
    holdingsTableWrap.innerHTML = buildHoldingsTableHTML(pf);
// Show integrity warnings (non-blocking)
try{
  const errWrapId = 'pfErrorsBanner';
  let old = document.getElementById(errWrapId);
  if(old) old.remove();
  const errs = Array.isArray(pf.__errors) ? pf.__errors : [];
  if(errs.length){
    const wrap = document.createElement('div');
    wrap.id = errWrapId;
    wrap.className = 'banner warn';
    const details = errs.slice(0,4).map(e => `${e.date||'—'} • ${e.ticker||'—'} • ${e.message||''}`).join('<br>');
    wrap.innerHTML = `<div>⚠️ Niespójne transakcje: ${errs.length}. <span class="small" style="opacity:.85">Edycja nie została zablokowana — sprawdź szczegóły i popraw daty/alokacje.</span><div class="small" style="margin-top:6px">${details}${errs.length>4?'<br>…':''}</div></div><div style="display:flex;gap:8px"><button class="btn ghost" id="pfErrorsDismiss">OK</button><button class="btn warn" id="pfErrorsIgnore">Ignoruj sprzedaże</button></div>`;
    const main = document.querySelector('main') || document.querySelector('.main') || document.body;
    main.prepend(wrap);
    document.getElementById('pfErrorsDismiss')?.addEventListener('click', ()=> wrap.remove());
        document.getElementById('pfErrorsIgnore')?.addEventListener('click', ()=> { try{ __ignoreInconsistentSells(); }catch(_){ alert('Błąd ignorowania.'); } });
  }
}catch(_){}

    
    // Update left sidebar tile blinking for the current portfolio
    (function(){
      const state = portfolioTargetState(pf); // "hit" | "near" | "none"
      // Clear previous blinking classes on all sidebar items
      document.querySelectorAll('.portfolio-item').forEach(el=>{
        el.classList.remove('hit-target','near-target');
      });
      // Apply to the current portfolio's tile
      const curEl = document.querySelector(`.portfolio-item[data-pf-id="${pf.id}"]`);
      if(curEl){
        if(state === "hit") curEl.classList.add('hit-target');
        else if(state === "near") curEl.classList.add('near-target');
      }
    })();

// Transactions table
    txTableWrap.innerHTML = buildTxTableHTML(pf, filterQueryEl.value.trim());
    try { updateSidebarBlinkStates(); } catch(e) {}
}

  function realizedSums(pf, range){
    let sumGross = 0, sumTax = 0, sumNet = 0;
    for(const t of pf.transactions){
      if(t.type==="sell"){
        try{ const ms = toMs(t && t.date); if(range && !inRangeMs(ms, range)) continue; }catch(_){}
        sumGross += Number(t.grossPL)||0;
        sumTax   += Number(t.tax)||0;
        sumNet   += Number(t.netPL || (t.grossPL - (t.grossPL>0 ? (DB.settings.taxRate||0.19)*t.grossPL : 0)));
      }
    }
    return {sumGross, sumTax, sumNet};
  }

  
  
  
  function buildHoldingsTableHTML(pf){
    const sections = [];
    const __rows = [];
    for(const [ticker, book] of Object.entries(pf.holdings)){
      const __cn = getCompanyName(ticker);
      const displayName = __cn ? `${__esc(ticker)} <span class="muted small" style="font-weight:400">${__esc(__cn)}</span>` : __esc(ticker);
      const lots = book.lots || [];
      const totalQty = lots.reduce((a,l)=>a+Number(l.qty||0),0);
      const costBasis = lots.reduce((a,l)=>a + Number(l.qty||0)*Number(l.unitCost||0),0);
      const avgCost = totalQty>0 ? costBasis / totalQty : 0;
      const lastPrice = getQuote(ticker);

      let nearestTarget = null, statusClass = "";
let nearestDist = Infinity;
let statusRank = -1; // 3: hit-sell, 2: hit-buy, 1: near-sell, 0: near-buy
for(const l of lots){
  l._ticker = ticker;
  const sellT = computeTargetPrice(l);
  const buyT  = computeBuyTargetPrice(l);
  const st = targetStatus(l);
  const rank = st.state==="hit" ? (st.kind==="sell"?3:2) : (st.state==="near" ? (st.kind==="sell"?1:0) : -1);
  if(rank > statusRank){
    statusRank = rank;
    if(rank===3) statusClass = "hit-target-sell";
    else if(rank===2) statusClass = "hit-target-buy";
    else if(rank===1) statusClass = "near-target-sell";
    else if(rank===0) statusClass = "near-target-buy";
  }
  // suppress blinking for acknowledged alarms
  (function(){
    const map = {"hit-target-sell":{state:"hit",kind:"sell"},"hit-target-buy":{state:"hit",kind:"buy"},"near-target-sell":{state:"near",kind:"sell"},"near-target-buy":{state:"near",kind:"buy"}};
    const info = map[statusClass];
    if(info && isAlertAcked(ticker, info.kind, info.state)){ statusClass = ""; }
  })();

  const candidates = [];
  if(sellT!=null) candidates.push(sellT);
  if(buyT!=null)  candidates.push(buyT);
  for(const t of candidates){
    if(lastPrice!=null){
      const d = Math.abs((lastPrice - t)/t);
      if(d < nearestDist){ nearestDist = d; nearestTarget = t; }
    } else {
      if(nearestTarget==null) nearestTarget = t; else nearestTarget = Math.min(nearestTarget, t);
    }
  }
      // Log per-ticker alarm to Firestore (deduplicated)
      (function(){
        const map = {
          "hit-target-sell": {state:"hit",  kind:"sell"},
          "hit-target-buy":  {state:"hit",  kind:"buy"},
          "near-target-sell":{state:"near", kind:"sell"},
          "near-target-buy": {state:"near", kind:"buy"}
        };
        const info = map[statusClass];
        if(info && nearestTarget!=null && lastPrice!=null){
          const key = ['pf', (pf&&pf.id)||'default', ticker, info.kind].join('|');
          if(__shouldLogAlarm(key, info.state)){ try{ window.showToast && showToast({ticker:r.t, state:info.state, kind:info.kind}); }catch(_){} try{ window.showToast && showToast({ticker, state:info.state, kind:info.kind}); }catch(_){}
            try{ logAlarmEvent({scope:'portfolio', pfId:(pf&&pf.id)||null, ticker, state:info.state, kind:info.kind, price:lastPrice, target:nearestTarget}); }catch(_){}
          }
        }
      })();
    
}

      const lotRowsArr = lots.map((l,i)=>{
        const t = computeTargetPrice(l);
        const st = targetStatus(l);
        const cls = st.state==="hit" ? (st.kind==="sell"?"hit-target-sell":"hit-target-buy") : (st.state==="near" ? (st.kind==="sell"?"near-target-sell":"near-target-buy") : "");
        return (
          `<tr data-lotid="${l.lotId}" class="${cls}">`+
            `<td>${i+1}</td>`+
            `<td>${__esc(l.date||"")}</td>`+
            `<td>${__fmtNum(l.qty)}</td>`+
            `<td>${__go_fmtCurrency(l.unitCost, pf.currency)}</td>`+
            `<td>${__go_fmtCurrency(l.qty*l.unitCost, pf.currency)}</td>`+
            `<td>`+
            ( (t!=null?`<span class="sell-target" style="color:#dc2626">${__go_fmtCurrency(t, pf.currency)}</span>`:``) +
              ( (computeBuyTargetPrice(l)!=null)?`<div class="buy-target" style="color:#16a34a">${__go_fmtCurrency(computeBuyTargetPrice(l), pf.currency)}</div>`:``) +
              (t==null && computeBuyTargetPrice(l)==null? '—': '')
            )+
            `</td>`+
            `<td>${lastPrice!=null?__fmtNum(lastPrice):"—"}</td><td>${(()=>{ const __p = (lastPrice!=null? Number(lastPrice) : null); const __uc = Number(l.unitCost)||0; const __q = Number(l.qty)||0; const __pl = (__p!=null && isFinite(__p)) ? (__q*(__p-__uc)) : null; return (__pl==null) ? "—" : ("<span class='"+(__pl>=0?"ok-text":"danger-text")+"'>"+__go_fmtCurrency(__pl, pf.currency)+"</span>"); })()}</td><td>${(()=>{ const __p = (lastPrice!=null? Number(lastPrice) : null); const __uc = Number(l.unitCost)||0; const __pct = (__p!=null && __uc>0) ? (((__p-__uc)/__uc)*100) : null; return (__pct==null) ? "—" : fmtPct(__pct); })()}</td>`+
            `<td>${(()=>{ 
  const __ch = getQuoteChangePct(ticker); 
  const __tr = getQuoteTrend(ticker); 
  const __arrow = (__tr===1)?'<span class="change-arrow up">▲</span>':(__tr===-1)?'<span class="change-arrow down">▼</span>':'';
  return (__ch!=null) ? (__arrow + "<span class='pct-badge "+(__ch>=0?"pct-pos ok-text":"pct-neg danger-text")+"'>"+fmtPct(__ch)+"</span>") : "—"; 
})()}</td>`+
            `<td>${st.state==="hit"?"🎯":(st.state==="near"?"⏳":"—")}</td>`+
          `<td><button class="btn ghost lot-edit" data-ticker="${ticker}" data-lot="${l.lotId}">📝</button> <button class="btn ok lot-sell" data-ticker="${ticker}" data-lot="${l.lotId}" data-maxqty="${l.qty}">💸</button> <button class="btn ghost lot-mute" data-action="lot-mute" data-ticker="${ticker}" data-lot="${l.lotId}" title="${l.muted?'Włącz alert':'Wycisz alert'}">${l.muted?'🔕':'🔔'}</button></td></tr>`
        );
      });
      const lotRowsHTML = lotRowsArr.join("") || '<tr data-lotid=\"${lot.lotId}\"><td colspan="8" class="center muted">Brak partii</td></tr>';

      const detailsHTML = (
        `<details><summary>${displayName} <button class="btn small ghost add-lot" data-ticker="${__esc(ticker)}" title="Dodaj nową partię">➕</button> <button class="btn small ghost transfer-company" data-ticker="${__esc(ticker)}" title="Przenieś całą spółkę do innego portfela">🔄</button></summary>`+
        `<div style="padding:8px 0">`+
          `<div class="table-wrap">`+
            `<table>`+
              `<thead>`+
                `<tr><th>#</th><th>Data</th><th>Ilość</th><th>Koszt / szt.</th><th>Wartość księgowa</th><th>Sugerowana cena</th><th>Kurs</th><th>P/L</th><th>P/L %</th><th>Δ dzienny</th><th>Status</th><th>Akcje</th></tr>`+
              `</thead>`+
              `<tbody>${lotRowsHTML}</tbody>`+
            `</table>`+
          `</div>`+
        `</div>`+
        `</details>`
      );

      __rows.push({ dist: nearestDist, html: `<tbody>`+
          `<tr class="${statusClass}">`+
            `<td class="ticker">${detailsHTML} </td>`+
            `<td>${__fmtNum(totalQty)}</td>`+
            `<td>${__go_fmtCurrency(avgCost, pf.currency)}</td>`+
            `<td>${__go_fmtCurrency(costBasis, pf.currency)}</td>`+
            `<td>${lastPrice!=null?__fmtNum(lastPrice):"—"}</td>`+
            `<td>${(()=>{ 
  const __ch = getQuoteChangePct(ticker); 
  const __tr = getQuoteTrend(ticker); 
  const __arrow = (__tr===1)?'<span class="change-arrow up">▲</span>':(__tr===-1)?'<span class="change-arrow down">▼</span>':'';
  return (__ch!=null) ? (__arrow + "<span class='pct-badge "+(__ch>=0?"pct-pos ok-text":"pct-neg danger-text")+"'>"+fmtPct(__ch)+"</span>") : "—"; 
})()}</td>`+
            `<td>${(()=>{ if(nearestTarget==null) return "—";  let kind=null, best=Infinity;  for(const l of lots){    const s=computeTargetPrice(l); if(s!=null){ const d=Math.abs((nearestTarget-s)/nearestTarget); if(d<best){ best=d; kind='sell'; } }    const b=computeBuyTargetPrice(l); if(b!=null){ const d=Math.abs((nearestTarget-b)/nearestTarget); if(d<best){ best=d; kind='buy'; } }  }  const lbl = kind==='sell'?'cel sprzedaży':(kind==='buy'?'cel zakupu':'');  return __go_fmtCurrency(nearestTarget, pf.currency) + (lbl?`<div class="small" style="opacity:.75; ${kind==='sell'?'color:#16a34a':(kind==='buy'?'color:#dc2626':'')}">${lbl}</div>`:""); })()}</td>`+
            `<td>${(()=>{ const p=lastPrice; const t=nearestTarget; if(p==null||t==null||t<=0) return "—"; const dist = Math.abs(p - t) / t; const pctStr = (dist*100).toFixed(2) + "%"; const localTol = (Number(DB.settings.approachTolerancePct)||1)/100; const cls = (dist<=1e-6) ? "ok-text" : (dist <= (localTol/2) ? "warn-strong-text" : "warn-text"); return `<span class="${cls}">${pctStr}</span>`; })()}</td>`+
            `<td><span class="small">${statusClass? (statusClass==="hit-target"?"🎯 cel osiągnięty":"⏳ blisko celu"):"—"}</span></td>`+
            `<td class="row" style="gap:6px"><button class="btn danger del-company" data-ticker="${__esc(ticker)}">🗑</button> <button class="btn ghost tv-link" data-ticker="${__esc(ticker)}" title="TradingView">📈</button> <button class="btn ghost info-company" data-ticker="${__esc(ticker)}">ℹ️</button></td>`+
          `</tr>`+
        `</tbody>`
      });
    }
    /* sort by nearest target distance */
    if(__rows.length){
      __rows.sort((a,b)=>{
        const ad = (a.dist==null||!isFinite(a.dist))?Infinity:a.dist;
        const bd = (b.dist==null||!isFinite(b.dist))?Infinity:b.dist;
        return ad - bd;
      });
      for(const r of __rows){ sections.push(r.html); }
    }
    const sectionsHTML = sections.join("") || '<tbody><tr><td colspan="8" class="center muted">Brak pozycji</td></tr></tbody>';
    const h = (
      `<div class="table-wrap">`+
        `<table>`+
          `<thead>`+
            `<tr>`+
              `<th>Ticker</th>`+
              `<th>Ilość</th>`+
              `<th>Śr. koszt / szt.</th>`+
              `<th>Wartość księgowa</th>`+
              `<th>Kurs</th><th>Δ dzienny</th>`+
              `<th>Najbliższy cel</th><th>Pozostało do celu</th>`+
              `<th>Status</th>`+
              `<th>Akcje</th>`+
            `</tr>`+
          `</thead>`+
          sectionsHTML+
        `</table>`+
      `</div>`
    );
    return h;
  }

  function parseFilter(q){
    // Simple filter parser: "typ:sell TSLA 2025-09"
    q = (q||"").trim();
    const parts = q.split(/\s+/).filter(Boolean);
    const f = { text: [] };
    for(const p of parts){
      const m = p.match(/^typ:(\w+)/i);
      if(m){ f.type = m[1].toLowerCase(); continue; }
      f.text.push(p.toLowerCase());
    }
    return f;
  }

  
  function buildTxTableHTML(pf, filterQ){
    const f = parseFilter(filterQ);
    const rowsArr = [];
    const txs = pf.transactions;
    for(const t of txs){
      if(f.type && t.type!==f.type) continue;
      const textBlob = JSON.stringify(t).toLowerCase();
      if(f.text?.length){
        let ok = true;
        for(const word of f.text){
          if(!textBlob.includes(word)){ ok=false; break; }
        }
        if(!ok) continue;
      }
      rowsArr.push(txRowHTML(pf, t));
    }
    const rowsHTML = rowsArr.join("") || '<tr><td colspan="11" class="center muted">Brak operacji</td></tr>';
    const h = (
      `<div class="table-wrap">`+
        `<table>`+
          `<thead>`+
            `<tr>`+
              `<th>Data</th>`+
              `<th>Typ</th>`+
              `<th>Ticker</th>`+
              `<th>Ilość</th>`+
              `<th>Cena</th>`+
              `<th>Opłaty</th>`+
              `<th>Gotówka ±</th>`+
              `<th>Zysk brutto</th>`+
              `<th>Podatek</th>`+
              `<th>Zysk netto</th>`+
              `<th>Uwagi</th><th>Akcje</th>`+
            `</tr>`+
          `</thead>`+
          `<tbody>`+ rowsHTML + `</tbody>`+
        `</table>`+
      `</div>`
    );
    return h;
  }

  function txRowHTML(pf, t){
    const cur = pf.currency;
    let cashDelta = 0;
    if(t.type==="deposit") cashDelta = t.amount;
    if(t.type==="withdraw") cashDelta = -t.amount;
    if(t.type==="buy") cashDelta = -(t.qty*t.price + (t.fees||0));
    if(t.type==="sell") cashDelta = (t.proceeds || t.qty*t.price) - (t.fees||0);
    if(t.type==="transfer_in") cashDelta = t.amount;
    if(t.type==="transfer_out") cashDelta = -t.amount;

    return `<tr data-tx="${t.id}" class="tx-row" style="cursor:pointer">
      <td>${__esc(t.date||"")}</td>
      <td>${mapType(t.type)}</td>
      <td class="ticker">${__esc(t.ticker||"")}</td>
      <td>${t.qty?__fmtNum(t.qty):"—"}</td>
      <td>${t.price?__go_fmtCurrency(t.price, cur): (t.amount?__go_fmtCurrency(t.amount, cur):"—")}</td>
      <td>${t.fees?__go_fmtCurrency(t.fees, cur):"—"}</td>
      <td>${__go_fmtCurrency(cashDelta, cur)}</td>
      <td class="${(t.grossPL??0)>=0 ? 'ok-text':'danger-text'}">${t.grossPL!==undefined?__go_fmtCurrency(t.grossPL, cur):"—"}</td>
      <td>${t.tax!==undefined?__go_fmtCurrency(t.tax, cur):"—"}</td>
      <td class="${(t.netPL??0)>=0 ? 'ok-text':'danger-text'}">${t.netPL!==undefined?__go_fmtCurrency(t.netPL, cur):"—"}</td>
      <td class="note">${__esc(t.note||"")}</td>
      <td>
        <button class="btn ghost tx-edit" data-tx="${t.id}">📝</button>
        ${t.type==='buy'?`<button class="btn ok tx-sell-from-buy" data-tx="${t.id}">💸</button>`:''}
        <button class="btn danger tx-del" data-tx="${t.id}">❌</button>
      </td>
    </tr>`;
  }
  // -- Integrity: keep transactions array valid & sorted (desc by date) --
  function ensureTransactionsCoherent(pf){
    try{
      if(!pf || !Array.isArray(pf.transactions)) { pf.transactions = []; return; }
      // drop null/undefined
      pf.transactions = pf.transactions.filter(t => t && typeof t === 'object');
      // normalize date strings and sort newest-first
      pf.transactions.sort((a,b)=>{
        const ad = Date.parse(a.date || '1970-01-01');
        const bd = Date.parse(b.date || '1970-01-01');
        return bd - ad;
      });
    }catch(_){}
  }

  // -- UI helper: show warning banner once per page load
  let __txWarnShown = false;
  function maybeWarnTxLoss(pf){
    try{
      if(!pf) return;
      const KEY = '__txCount_'+pf.id;
      const prev = Number(localStorage.getItem(KEY) || '0');
      const cur = Array.isArray(pf.transactions) ? pf.transactions.length : 0;
      // If it looks like we lost transactions, nudge to use Undo
      if(prev && cur < prev && !__txWarnShown){
        __txWarnShown = true;
        const w = document.createElement('div');
        w.className = 'banner warn';
        w.innerHTML = '⚠️ Wykryto spadek liczby transakcji ('+cur+' z '+prev+'). <button class="btn small" id="txUndoNow">Cofnij</button>';
        const hist = document.getElementById('historyPanel');
        (hist?.parentElement || document.body).insertBefore(w, hist);
        const btn = w.querySelector('#txUndoNow');
        if(btn){ btn.addEventListener('click', ()=>{ try{ undo({mode:'tx'}); }catch(_){ alert("Spróbuj ręcznie kliknąć Cofnij (Ctrl+Z)"); } }); }
        setTimeout(()=>{ w.remove(); }, 12000);
      }
      localStorage.setItem(KEY, String(cur));
    }catch(_){}
  }


  function mapType(t){
    return {
      deposit:"wpłata",
      withdraw:"wypłata",
      transfer_in:"przelew — przychód",
      transfer_out:"przelew — rozchód",
      transfer_company_in:"transfer spółki — przychód",
    transfer_company_out:"transfer spółki — rozchód",
    buy:"zakup",
      sell:"sprzedaż",
    }[t] || t;
  }

  function today(){
    return new Date().toISOString().slice(0,10);
  }

  function __esc(s){
    return (s||"").replace(/[&<>"']/g, m=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  const QUOTES = {};
const COMPANY_NAMES = {}; // ticker -> {name, ts}
 // ticker -> {price, ts}
  let quoteTimer = null;
  let isPollingQuotes = false;
let __pollerStarted = false;

  function setQuote(ticker, price, extras){
  try{
    const prev = QUOTES[ticker] || {
};
    const newPrice = Number(price) || null;
    const prevPrice = (prev && typeof prev.price !== 'undefined') ? prev.price : null;
    let trend = null;
    if(newPrice != null && prevPrice != null){
      trend = (newPrice > prevPrice) ? 1 : (newPrice < prevPrice ? -1 : 0);
    }
    QUOTES[ticker] = {
      price: newPrice,
      prevPrice: prevPrice ?? null,
      trend: trend,
      ts: Date.now(),
      pc: (extras && extras.pc != null) ? Number(extras.pc) : (prev.pc ?? null),
      dp: (extras && extras.dp != null) ? Number(extras.dp) : (prev.dp ?? null),
      d:  (extras && extras.d  != null) ? Number(extras.d)  : (prev.d  ?? null),
    };
  }catch(_){
    QUOTES[ticker] = { price: Number(price)||null, prevPrice: null, trend: null, ts: Date.now() };
  }
  try{ if(typeof maybeScanAlarmsGlobal==='function') maybeScanAlarmsGlobal(); }catch(_){ }
}
  function getQuote(ticker){
  return QUOTES[ticker]?.price ?? null;
}

function setCompanyName(ticker, name){
  try{
    if(!ticker || !name) return;
    const t = String(ticker).toUpperCase();
    COMPANY_NAMES[t] = {name: String(name), ts: Date.now()};
  }catch(_){}
}
function getCompanyName(ticker){
  try{
    const t = String(ticker).toUpperCase();
    return (COMPANY_NAMES[t] && COMPANY_NAMES[t].name) || null;
  }catch(_){ return null; }
}


function getQuotePrevClose(ticker){
  return QUOTES[ticker]?.pc ?? null;
}
function getQuoteChangePct(ticker){
  const q = QUOTES[ticker];
  if(!q) return null;
  if(Number.isFinite(q.dp)) return q.dp;
  const c = q.price, pc = q.pc;
  if(c!=null && pc>0) return ((c - pc) / pc) * 100;
  return null;
}
function getQuoteTrend(ticker){
  return QUOTES[ticker]?.trend ?? null;
}

const fmtPct = (x, d=2)=> (x===null || x===undefined || isNaN(Number(x))) ? "—" : ((Number(x)>=0?"+":"") + Number(x).toFixed(d) + "%");
  async function fetchQuoteFinnhub(ticker){
  const token = DB.settings.finnhubToken || "";
  if(!token){ return {price:null, error:'Brak tokenu (⚙️ Ustawienia)'}; }
  try{
    const url = `https://finnhub.io/api/v1/quote?symbol=${encodeURIComponent(ticker)}&token=${encodeURIComponent(token)}`;
    const res = await fetch(url);
    const j = await res.json().catch(()=>({}));
    const err = j && j.error ? j.error : (!res.ok ? ('HTTP '+res.status) : null);
    const p = (j && (j.c ?? j.pc)) ?? null;
    if(p!=null) setQuote(ticker, p, { pc: j?.pc, dp: j?.dp, d: j?.d });
    return {price: p, error: err};
  }catch(e){ return {price:null, error: e.message||'Fetch error'}; }
}

async function fetchCompanyProfile(ticker){
  const token = (DB && DB.settings && DB.settings.finnhubToken) || "";
  if(!token){ return {name:null, error:'Brak tokenu'}; }
  try{
    const url = `https://finnhub.io/api/v1/stock/profile2?symbol=${encodeURIComponent(ticker)}&token=${encodeURIComponent(token)}`;
    const res = await fetch(url);
    const j = await res.json().catch(()=>({}));
    const err = j && j.error ? j.error : (!res.ok ? ('HTTP '+res.status) : null);
    const name = (j && j.name) || null;
    return {name, error: err};
  }catch(e){ return {name:null, error: e && e.message || 'Fetch error'}; }
}



  async function searchSymbolFinnhub(query){
  const token = (DB && DB.settings && DB.settings.finnhubToken) || '';
  if(!token){ return {result:[], error:'Brak tokenu (⚙️ Ustawienia)'}; }
  try{
    const url = `https://finnhub.io/api/v1/search?q=${encodeURIComponent(query)}&token=${encodeURIComponent(token)}`;
    const res = await fetch(url);
    const j = await res.json().catch(()=>({}));
    const err = j && j.error ? j.error : (!res.ok ? ('HTTP '+res.status) : null);
    const arr = Array.isArray(j.result) ? j.result : [];
    arr.forEach(item => {
      if(item && item.symbol && item.description){
        setCompanyName(String(item.symbol).toUpperCase(), item.description);
      }
    });
    return {result: arr, error: err};
  }catch(e){ return {result:[], error: e && e.message || 'Search error'}; }
}

  function startPollingQuotes(){
  if(__pollerStarted){ return; } __pollerStarted = true;
  let secs = Number(DB.settings.pricePollSeconds)||30;
  if(secs < 10) secs = 10;
  if(quoteTimer) clearInterval(quoteTimer);
  const doPoll = async ()=>{
    if(isPollingQuotes) return;
    isPollingQuotes = true;
    try{
      const tickers = Array.from(new Set([
      ...DB.portfolios.flatMap(pf=> Object.keys(pf.holdings || {})),
      ...(DB.watchlist||[]).map(w=> (w.ticker||"").toUpperCase())
    ]));
      if(!tickers.length){ try { updateSidebarBlinkStates(); } catch(e) {} ; return; }
      /*
       * Throttle API calls to Finnhub.
       * Previously, quotes were fetched concurrently using Promise.all(). However, this could quickly
       * exceed the free Finnhub API limit (60 requests/minute) when multiple tickers are tracked,
       * resulting in HTTP 429 errors (Too Many Requests). To mitigate this, fetch each ticker
       * sequentially and wait a small delay between calls. This keeps the total request rate under
       * Finnhub's free quota even when the poll interval is large (e.g. 200 seconds) and several
       * tickers are present.
       */
      for(const t of tickers){
  await fetchQuoteFinnhub(t);
  // Fetch company name if not cached or older than 7 days
  if(!COMPANY_NAMES[t] || (Date.now() - COMPANY_NAMES[t].ts > 7*24*60*60*1000)){
    try{
      const profile = await fetchCompanyProfile(t);
      if(profile && profile.name) setCompanyName(t, profile.name);
    }catch(_){}
  }
  await new Promise(resolve => setTimeout(resolve, 1200));
}
            window.__lastApiRefreshAt = Date.now(); try{ if(window.setApiTime) window.setApiTime(window.__lastApiRefreshAt); }catch(_){}
try { renderMain(); } catch(e) {}
      try { renderWishlist(); } catch(e) {}
      try { updateSidebarBlinkStates(); } catch(e) {}
      try { updateWishlistBlinkState(); } catch(e) {}
        try { checkAndPlayPortfolioAlerts(); checkAndPlayWishlistAlert(); } catch(e) {}
    } finally {
      isPollingQuotes = false;
    }
  };
  doPoll();
  quoteTimer = setInterval(doPoll, secs*1000);
}

  function computeTargetPrice(lot){
    // Sprzedaż (take-profit)
    if(lot?.targetPrice && Number(lot.targetPrice)>0) return Number(lot.targetPrice);
    if(lot?.targetPct && Number(lot.targetPct)!=0){
      return Number(lot.unitCost) * (1 + Number(lot.targetPct)/100);
    }
    return null;
  }

  function computeBuyTargetPrice(lot){
    if(lot?.buyTargetPrice && Number(lot.buyTargetPrice)>0) return Number(lot.buyTargetPrice);
    if(lot?.buyTargetPct && Number(lot.buyTargetPct)!=0){
      return Number(lot.unitCost) * (1 - Number(lot.buyTargetPct)/100);
    }
    return null;
  }

function targetStatus(lot){ if(lot && lot.muted) return {state:'none'}; 
  const price = getQuote(lot._ticker||"");
  const sellT = computeTargetPrice(lot);
  const buyT  = computeBuyTargetPrice(lot);
  if(price==null) return {state:"none"};
  const tol = (Number(DB.settings.approachTolerancePct)||1)/100; // np. 1%

  const cand = [];

  if(sellT!=null){
    if(price >= sellT) cand.push({state:"hit", kind:"sell", price, target:sellT});
    else if(price >= sellT*(1 - tol)) cand.push({state:"near", kind:"sell", price, target:sellT});
    else cand.push({state:"far", kind:"sell", price, target:sellT});
  }

  if(buyT!=null){
    if(price <= buyT) cand.push({state:"hit", kind:"buy", price, target:buyT});
    else if(price <= buyT*(1 + tol)) cand.push({state:"near", kind:"buy", price, target:buyT});
    else cand.push({state:"far", kind:"buy", price, target:buyT});
  }

  if(cand.length===0) return {state:"none"};

  const prio = { "hit":0, "near":1, "far":2 };
  cand.sort((a,b)=>{
    if(prio[a.state]!==prio[b.state]) return prio[a.state]-prio[b.state];
    const da = Math.abs((price - a.target)/a.target);
    const db = Math.abs((price - b.target)/b.target);
    return da - db;
  });
  return cand[0];
}

  // Compute portfolio-level alert state based on current quotes and lot targets
  function portfolioTargetState(pf){
  // returns {state: "hit"|"near"|"none", kind: "sell"|"buy"|null}
  let hitSell=false, hitBuy=false, nearSell=false, nearBuy=false;
  const tol = (Number(DB.settings.approachTolerancePct)||1)/100;
  for(const [ticker, book] of Object.entries(pf.holdings||{})){
    const lots = book?.lots || [];
    const price = getQuote(ticker);
    if(price==null) continue;
    for(const l of lots){
      const sellT = computeTargetPrice(l);
      const buyT  = computeBuyTargetPrice(l);
      if(sellT!=null){
        if (price >= sellT && !(l && l.muted)) { hitSell = true; break; }
        if(price >= sellT*(1 - tol) && !(l && l.muted)) nearSell = true;
      }
      if(buyT!=null){
        if (price <= buyT && !(l && l.muted)) { hitBuy = true; break; }
        if(price <= buyT*(1 + tol) && !(l && l.muted)) nearBuy = true;
      }
    }
    if(hitSell || hitBuy) break;
  }
  if(hitSell) return {state:"hit",  kind:"sell"};
  if(hitBuy)  return {state:"hit",  kind:"buy"};
  if(nearSell) return {state:"near", kind:"sell"};
  if(nearBuy)  return {state:"near", kind:"buy"};
  return {state:"none", kind:null};
}


function updateSidebarBlinkStates(){
  // Clear previous blinking classes on all sidebar items
  document.querySelectorAll('.portfolio-item').forEach(el=>{
    el.classList.remove('hit-target','near-target','hit-target-sell','near-target-sell','hit-target-buy','near-target-buy');
  });
  // For each portfolio, add blink only if there's at least one NON-ACKED ticker with hit/near
  for(const pf of ((typeof ST!=='undefined' && ST.DB && Array.isArray(ST.DB.portfolios)) ? ST.DB.portfolios : ((typeof DB!=='undefined' && Array.isArray(DB.portfolios)) ? DB.portfolios : []))){
    const el = document.querySelector(`.portfolio-item[data-pf-id="${pf.id}"]`);
    if(!el) continue;
    let pfState = null;
    try{
      for(const [ticker, book] of Object.entries(pf.holdings||{})){
        const lots = book.lots||[];
        let rank=-1, state='none', kind=null;
        for(const l of lots){
          l._ticker = ticker;
          const st = targetStatus(l);
          const r = st.state==="hit" ? (st.kind==="sell"?3:2) : (st.state==="near" ? (st.kind==="sell"?1:0) : -1);
          if(r>rank){ rank=r; state=st.state; kind=st.kind; }
        }
        if(rank>=0 && (state==='hit' || state==='near') && kind && !isAlertAcked(ticker, kind, state)){
          pfState = {state, kind};
          break;
        }
      }
    }catch(_){}
    if(pfState){
      if(pfState.state === "hit") el.classList.add(pfState.kind==="sell"?'hit-target-sell':'hit-target-buy');
      else if(pfState.state === "near") el.classList.add(pfState.kind==="sell"?'near-target-sell':'near-target-buy');
    }
  }
}




  
  // === Sound Alerts Engine ===
(function(){
  let __audio = { ctx: null, unlocked: false };
  let __lastPortfolioSig = 'none';
  let __lastWishlistSig = 'none';
  let __lastPortfolioBeep = 0;
  let __lastWishlistBeep = 0;
  function __repeatMs(){ return Math.max(5000, Number(DB?.settings?.soundRepeatSeconds ?? 60) * 1000); }

  function __getSoundVolumePct(){
    try { return Math.max(0, Math.min(100, Number(DB?.settings?.soundVolume ?? 40))); }
    catch(_) { return 40; }
  }
  function __gainFromVol(mult){ const base = (__getSoundVolumePct()/100); return Math.max(0.0005, Math.min(1.0, base * 0.20 * (mult||1))); }

  function ensureAudio(){
    try{
      if(!__audio.ctx){
        const AC = window.AudioContext || window.webkitAudioContext;
        if(!AC) return null;
        __audio.ctx = new AC();
      }
      return __audio.ctx;
    }catch(e){ return null; }
  }

  function unlockAudio(){
    const ctx = ensureAudio();
    if(!ctx) return;
    if(ctx.state === 'suspended'){
      ctx.resume().catch(()=>{}).then(()=>{ __audio.unlocked = true; });
    }else{
      __audio.unlocked = true;
    }
    window.removeEventListener('pointerdown', unlockAudio);
    window.removeEventListener('keydown', unlockAudio);
    window.removeEventListener('click', unlockAudio);
  }
  window.addEventListener('pointerdown', unlockAudio, { once:false, capture:true });
  window.addEventListener('keydown', unlockAudio, { once:false, capture:true });
  window.addEventListener('click', unlockAudio, { once:false, capture:true });


// === Web Audio unlock helper to comply with Chrome autoplay policy ===
(function(){
  try{
    if(!window.__AUDIO){
      window.__AUDIO = { ctx: null, unlocked: false, queue: [] };
    }
    function __resumeAudio(){
      try{
        const A = window.__AUDIO;
        if(!A.ctx){
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if(!Ctx) return;
          A.ctx = new Ctx();
        }
        A.ctx.resume().then(function(){
          A.unlocked = (A.ctx && A.ctx.state === 'running');
          if(A.unlocked){
            ['pointerdown','touchstart','click','keydown'].forEach(function(ev){
              document.removeEventListener(ev, __resumeAudio, { once: true });
            });
            // flush pending beeps
            var q = A.queue.splice(0);
            q.forEach(function(fn){ try{ fn(); }catch(e){} });
            if(typeof console!=='undefined' && console.debug){
              console.debug('[audio] unlocked + queue flushed');
            }
          }
        }).catch(function(_){});
      }catch(_){}
    }
    window.ensureAudioUnlocked = function(){
      try{
        const A = window.__AUDIO;
        if(A.unlocked) return true;
        if(!A.ctx){
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if(!Ctx) return false;
          A.ctx = new Ctx();
        }
        ['pointerdown','touchstart','click','keydown'].forEach(function(ev){
          document.addEventListener(ev, __resumeAudio, { once: true, passive: true });
        });
        if(typeof console!=='undefined' && console.debug){
          console.debug('[audio] waiting for user gesture to unlock...');
        }
        return false;
      }catch(_){ return false; }
    };
  }catch(_){}
})();
// === end unlock helper ===


  
function playBeep(freq, durationMs, gainVal){
  try{
    var f = Number(freq)||1000;
    var ms = Number(durationMs)||200;
    var g = Number(gainVal); 
    if(!isFinite(g) || g<=0) g = 1.0;
    var ok = (typeof ensureAudioUnlocked==='function') ? ensureAudioUnlocked() : true;

    var doPlay = function(){
      try{
        var A = window.__AUDIO || (window.__AUDIO = { ctx:null, unlocked:false, queue:[] });
        var Ctx = window.AudioContext || window.webkitAudioContext;
        if(!A.ctx) A.ctx = new Ctx();
        // Ensure context is running
        if(A.ctx.state !== 'running'){
          // Best effort resume
          if (A.ctx.resume) A.ctx.resume().catch(function(){ });
        }
        var ctx = A.ctx;
        var osc = ctx.createOscillator();
        var gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f;

        // simple anti-click envelope
        var t = ctx.currentTime;
        var dur = ms/1000;
        gain.gain.setValueAtTime(0.0001, t);
        gain.gain.exponentialRampToValueAtTime(Math.max(0.0002, Math.min(g, 2.0)), t + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + dur);

        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(t);
        osc.stop(t + dur);
      }catch(_){}
    };

    if((window.__AUDIO && window.__AUDIO.unlocked) || ok){
      doPlay();
    }else{
      // queue until unlock via first click/touch/keydown
      try{
        var A = window.__AUDIO || (window.__AUDIO = { ctx:null, unlocked:false, queue:[] });
        // Keep queue small
        if (A.queue.length < 5) A.queue.push(doPlay);
      }catch(_){}
    }
  }catch(_){}
}


  function portfolioGlobalSignal(){
    let anyHit=false, anyNear=false;
    for(const pf of (DB.portfolios||[])){
      const sig = (typeof portfolioTargetState==='function') ? portfolioTargetState(pf) : {state:'none'};
      if(sig.state==='hit'){ anyHit=true; break; }
      if(sig.state==='near'){ anyNear=true; }
    }
    return anyHit ? 'hit' : (anyNear ? 'near' : 'none');
  }

  function checkAndPlayPortfolioAlerts(){
    const s = portfolioGlobalSignal();
    const nowMs = Date.now();
    if(s==='hit' && DB?.settings?.soundHitTarget !== false){
      if(__lastPortfolioSig!=='hit' || (nowMs - __lastPortfolioBeep) >= __repeatMs()){
        playBeep(1100, 260, 1.3);  try{ if(__shouldIncrementBadge('portfolio_global', 'hit')){ const k='alerts_unread_count'; const n=Number(localStorage.getItem(k)||0)||0; localStorage.setItem(k, String(Math.min(n+1,999))); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); } }catch(_){} __lastPortfolioBeep = nowMs;
      }
    }else if(s==='near' && DB?.settings?.soundNearTarget !== false){
      if(__lastPortfolioSig!=='near' || (nowMs - __lastPortfolioBeep) >= __repeatMs()){
        playBeep(650, 220, 1.0);  try{ if(__shouldIncrementBadge('portfolio_global', 'near')){ const k='alerts_unread_count'; const n=Number(localStorage.getItem(k)||0)||0; localStorage.setItem(k, String(Math.min(n+1,999))); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); } }catch(_){} __lastPortfolioBeep = nowMs;
      }
    }
     __lastPortfolioSig = s;
  }

  function checkAndPlayWishlistAlert(){
    if(typeof wishlistSignal!=='function') return;
    const s = wishlistSignal(); // 'hit' | 'near' | 'none'
    const nowMs = Date.now();
    if(s==='hit' && DB?.settings?.soundHitTarget !== false){
      if(__lastWishlistSig!=='hit' || (nowMs - __lastWishlistBeep) >= __repeatMs()){
        playBeep(1000, 240, 1.3);  try{ if(__shouldIncrementBadge('wishlist_global', 'hit')){ const k='alerts_unread_count'; const n=Number(localStorage.getItem(k)||0)||0; localStorage.setItem(k, String(Math.min(n+1,999))); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); } }catch(_){} __lastWishlistBeep = nowMs;
      }
    }else if(s==='near' && DB?.settings?.soundNearTarget !== false){
      if(__lastWishlistSig!=='near' || (nowMs - __lastWishlistBeep) >= __repeatMs()){
        playBeep(600, 200, 1.0);  try{ if(__shouldIncrementBadge('wishlist_global', 'near')){ const k='alerts_unread_count'; const n=Number(localStorage.getItem(k)||0)||0; localStorage.setItem(k, String(Math.min(n+1,999))); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); } }catch(_){} __lastWishlistBeep = nowMs;
      }
    }
    __lastWishlistSig = s;
  }

  try{
    window.checkAndPlayPortfolioAlerts = checkAndPlayPortfolioAlerts;
    window.checkAndPlayWishlistAlert = checkAndPlayWishlistAlert;
    window.__testBeep = (f=800,d=250,m=1.0)=>{ try{ playBeep(f,d,m); }catch(_){ } };
  }catch(_){}
})();;

  
/* === Acknowledged Alerts (suppress blinking for read ones) === */
window.__ackedAlerts = window.__ackedAlerts || {};
function __ackKey(ticker, kind, state){ try{ return [String(ticker||'').toUpperCase(), String(kind||''), String(state||'')].join('|'); }catch(_){ return String(ticker||''); } }
function isAlertAcked(ticker, kind, state){ try{ return !!window.__ackedAlerts[__ackKey(ticker,kind,state)]; }catch(_){ return false; } }
function ackAlert(ticker, kind, state){ try{ window.__ackedAlerts[__ackKey(ticker,kind,state)] = Date.now(); }catch(_){} }

function ackCurrentAlerts(){
  try{
    // Portfolios - per ticker best state
    const tol = (Number(DB?.settings?.approachTolerancePct)||1)/100;
    for(const pf of (DB?.portfolios||[])){
      for(const [ticker, book] of Object.entries(pf.holdings||{})){
        const lots = book.lots||[];
        const price = getQuote(ticker);
        if(price==null) continue;
        let rank = -1, state='none', kind=null;
        for(const l of lots){
          l._ticker = ticker;
          const st = targetStatus(l);
          const r = st.state==="hit" ? (st.kind==="sell"?3:2) : (st.state==="near" ? (st.kind==="sell"?1:0) : -1);
          if(r > rank){ rank=r; state = st.state; kind = st.kind; }
        }
        if(rank>=0 && (state==='hit' || state==='near') && kind) ackAlert(ticker, kind, state);
      }
    }
    // Wishlist - active target only
    const tol2 = (Number(DB?.settings?.approachTolerancePct)||1)/100;
    (DB?.watchlist||[]).forEach(w=>{
      const t = (w.ticker||'').toUpperCase();
      const p = getQuote(t);
      const targets = Array.isArray(w.targets) ? w.targets.map(x=>Number(x)||0).filter(x=>x>0) : [];
      const ai = Math.min(Math.max(Number(w.activeIndex)||0, 0), Math.max(targets.length-1,0));
      const d = targets.length ? Number(targets[ai])||0 : (Number(w.price)||0);
      if(!t || !(d>0) || p==null) return;
      if(p <= d) ackAlert(t, 'buy', 'hit');
      else if(p <= d*(1+tol2)) ackAlert(t, 'buy', 'near');
    });
  }catch(_){}
}
/* === Wishlist (Lista życzeń) === */
  
  function ensureWatchlistStructure(){
    try{
      DB.watchlist = DB.watchlist || [];
      for(const w of DB.watchlist){
        if(!Array.isArray(w.targets)){
          const base = Number(w.price)||0;
          w.targets = base>0 ? [base] : [];
          try{ delete w.price; }catch(_){}
        }
        if(typeof w.activeIndex!=='number') w.activeIndex = 0;
        if(typeof w.name!=='string') w.name = w.name||'';
      }
    }catch(_){}
  }
function ensureWatchlist(){ DB.watchlist = DB.watchlist || []; ensureWatchlistStructure(); }

  
function setActiveView(v){
  const main = document.querySelector('.main') || document.querySelector('main');
  if(!main) return;
  const panels = main.querySelectorAll(':scope > section');
  panels.forEach(sec=>{
    if(v==='wishlist') sec.style.display = (sec.id==='wishlistPanel') ? '' : 'none';
    else if(v==='alerts') sec.style.display = (sec.id==='alertsPanel') ? '' : 'none';
    else sec.style.display = (sec.id==='wishlistPanel' || sec.id==='alertsPanel') ? 'none' : '';
  });
  const btnW = document.getElementById('wishlistTabBtn');
  if(btnW){ btnW.classList.toggle('secondary', v!=='wishlist'); }
  const btnA = document.getElementById('alertsTabBtn');
  if(btnA){ btnA.classList.toggle('secondary', v!=='alerts'); }
}


  function wishlistSignal(){
    ensureWatchlist();
    const tol = (Number(DB.settings.approachTolerancePct)||1)/100;
    let hit=false, near=false;
    for(const w of DB.watchlist){
      const t = (w.ticker||'').toUpperCase();
      const p = getQuote(t);
      const targets = Array.isArray(w.targets) ? w.targets.map(x=>Number(x)||0).filter(x=>x>0) : [];
      const ai = Math.min(Math.max(Number(w.activeIndex)||0, 0), Math.max(targets.length-1,0));
      const d = (targets.length ? Number(targets[ai])||0 : (Number(w.price)||0));
      if(!t || !(d>0) || p==null) continue;
      if(p <= d){ hit = true; break; }
      if(p <= d*(1+tol)) near = true;
    }
    return hit ? 'hit' : (near ? 'near' : 'none');
  }

  function updateWishlistBlinkState(){
    try{
      const btn = document.getElementById('wishlistTabBtn');
      if(!btn) return;
      btn.classList.remove('hit-target-buy','near-target-buy');
      const sig = wishlistSignal();
      if(sig==='hit') btn.classList.add('hit-target-buy');
      else if(sig==='near') btn.classList.add('near-target-buy');
    }catch(e){}
  }

  function addWatchItem(ticker, price){
    ensureWatchlist();
    ticker = (ticker||'').toUpperCase().trim();
    const p = Number(price)||0;
    if(!ticker || !(p>0)){ alert('Podaj poprawny ticker i cenę.'); return; }
    const ex = DB.watchlist.find(w=> w.ticker===ticker);
    if(ex){ ex.price = p; ex.updatedAt = new Date().toISOString(); }
    else { DB.watchlist.push({ id:id(), ticker, price:p, createdAt:new Date().toISOString(), updatedAt:new Date().toISOString() }); }
    save(); renderWishlist(); updateWishlistBlinkState();
  }

  function removeWatchItem(wid){
    ensureWatchlist();
    const i = DB.watchlist.findIndex(w=> w.id===wid);
    if(i>=0){ DB.watchlist.splice(i,1); save(); renderWishlist(); updateWishlistBlinkState(); }
  }

  async function editWatchItem(wid){
    ensureWatchlist();
    const item = DB.watchlist.find(w=> w.id===wid);
    if(!item) return;
    const t = (item.ticker||'').toUpperCase();
    // Build default targets string from existing targets or fallback to old price
    const defaultTargets = (Array.isArray(item.targets) && item.targets.length) 
      ? item.targets.join(', ')
      : ((item.price!=null && item.price!=='') ? (item.price+'') : '');
    const data = await openModal({
      title: `Edytuj cele kupna — ${__esc(t)}`,
      innerHTML: `<form class="grid">
        <div class="col-12"><label>Ceny docelowe (kupno) — wpisz po przecinku, w kolejności realizacji</label>
          <input name="targets" type="text" placeholder="np. 350, 300, 250" value="${__esc(defaultTargets)}" />
          <div class="muted small">Aktywna będzie pierwsza; po zakupie przełączy się na kolejną.</div>
        </div>
      </form>`,
      okText:"Zapisz"
    });
    if(!data) return;
    const raw = (data.targets||'')+'';
    const targets = raw.split(/[,;\s]+/).map(x=>Number(x)).filter(x=>x>0);
    if(!targets.length){ alert('Podaj co najmniej jedną poprawną cenę docelową.'); return; }
    item.targets = targets;
    if(typeof item.activeIndex!=='number' || item.activeIndex>=targets.length) item.activeIndex = 0;
    try{ delete item.price; }catch(_){}
    item.updatedAt = new Date().toISOString();
    save(); renderWishlist(); updateWishlistBlinkState();
  }

  function renderWishlist(){
    ensureWatchlist();
    const wrap = document.getElementById('wlTableWrap');
    if(!wrap) return;
    const tol = (Number(DB.settings.approachTolerancePct)||1)/100;
    const rows = (DB.watchlist||[]).map(w=>{
      const t = (w.ticker||'').toUpperCase();
      const price = getQuote(t);
      const targets = Array.isArray(w.targets) ? w.targets.map(x=>Number(x)||0).filter(x=>x>0) : ((Number(w.price)||0)?[Number(w.price)]:[]);
      const ai = Math.min(Math.max(Number(w.activeIndex)||0, 0), Math.max(targets.length-1,0));
      const desired = targets.length ? Number(targets[ai])||0 : 0;
      let dist = null, status='—', cls='';
      if(price!=null && desired>0){
        dist = (price - desired)/desired;
        if(price <= desired){ status = '🎯 KUP'; cls='hit-target-buy'; }
        else if(price <= desired*(1+tol)){ status = '⏳ blisko'; cls='near-target-buy'; }
      }
      return { ...w, t, price, desired, dist, status, cls };
    }).sort((a,b)=>{
      const ad = (a.dist==null) ? 1e9 : Math.abs(a.dist);
      const bd = (b.dist==null) ? 1e9 : Math.abs(b.dist);
      return ad - bd;
    });

    
    // Log wishlist alarms (deduplicated), for rows in 'near' or 'hit' states
    try{
      rows.forEach(r=>{
        const info = (r.cls==='hit-target-buy') ? {state:'hit', kind:'buy'}
                    : (r.cls==='near-target-buy') ? {state:'near', kind:'buy'}
                    : null;
        if(info && r.desired>0 && r.price!=null){
          const key = ['wl', r.id || r.t, info.kind].join('|');
          if(__shouldLogAlarm(key, info.state)){ try{ window.showToast && showToast({ticker:r.t, state:info.state, kind:info.kind}); }catch(_){} try{ window.showToast && showToast({ticker, state:info.state, kind:info.kind}); }catch(_){}
            logAlarmEvent({scope:'wishlist', ticker:r.t, state:info.state, kind:info.kind, price:r.price, target:r.desired});
          }
        }
      });
    }catch(_){}
const body = rows.map(r=>{
      const priceTxt = (r.price!=null) ? __fmtNum(r.price) : '—';
      const distTxt = (r.dist==null) ? '—' : ( (r.dist*100).toFixed(2) + '%' );
      return `<tr class="${r.cls}">
        <td class="ticker">${__esc(r.t)}${(()=>{ const cn=getCompanyName(r.t); return cn?`<div class="muted small" style="font-weight:400;margin-top:2px">${__esc(cn)}</div>`:''; })()}</td>
        <td>${priceTxt}</td>
        <td>${(()=>{ const ch=getQuoteChangePct(r.t); return (ch!=null)? ("<span class='pct-badge "+(ch>=0?"pct-pos ok-text":"pct-neg danger-text")+"'>"+fmtPct(ch)+"</span>") : "—"; })()}</td>
        <td>${__fmtNum(r.desired)}</td>
        <td>${(()=>{ const _c = r.cls||''; const _d=(typeof r.dist==='number')?r.dist:null; let _cls=''; if(_c.includes('hit-target-buy')){ _cls='ok-text'; } else if(_c.includes('near-target-buy')){ _cls = (_d!=null && _d<= (tol/2)) ? 'warn-strong-text' : 'warn-text'; } return `<span class="${_cls}">${distTxt}</span>`; })()}</td>
        <td>${r.status}</td>
        <td class="row" style="gap:6px">
          <button class="btn ok wl-buy" data-id="${r.id}">Kup</button>
          <button class="btn ghost wl-edit" data-id="${r.id}">Edytuj</button>
          <button class="btn danger wl-del" data-id="${r.id}">Usuń</button> <button class="btn ghost tv-link" data-ticker="${r.t}" title="TradingView">TV</button>
          <button class="btn ghost wl-info" data-ticker="${r.t}">ℹ️</button>
        </td>
      </tr>`;
    }).join('') || `<tr><td colspan="8" class="center muted">Brak pozycji. Dodaj pierwszy cel kupna powyżej.</td></tr>`;

    const html = `<div class="table-wrap">
      <table>
        <thead><tr>
          <th>Ticker</th><th>Kurs (live)</th><th>Δ dzienny</th><th>Cel kupna</th><th>Odległość</th><th>Status</th><th>Akcje</th>
        </tr></thead>
        <tbody>${body}</tbody>
      </table>
    </div>`;

    wrap.innerHTML = html;

    // bind row actions
    
    wrap.querySelectorAll('.wl-info').forEach(btn=>{ btn.addEventListener('click', e=>{ const t=e.currentTarget.getAttribute('data-ticker'); if(t) openCompanyInfoModal(t); }); });
wrap.querySelectorAll('.wl-del').forEach(btn=>{
      btn.addEventListener('click', e=>{
        const id = e.currentTarget.getAttribute('data-id'); removeWatchItem(id);
      });
    });
    wrap.querySelectorAll('.wl-edit').forEach(btn=>{
      btn.addEventListener('click', e=>{
        const id = e.currentTarget.getAttribute('data-id'); editWatchItem(id);
      });
    });
    wrap.querySelectorAll('.wl-buy').forEach(btn=>{
      btn.addEventListener('click', async e=>{
        const id = e.currentTarget.getAttribute('data-id');
        const item = (DB.watchlist||[]).find(w=> w.id===id);
        if(!item) return;
        const t = (item.ticker||'').toUpperCase();
        try{ await fetchQuoteFinnhub(t); }catch(e){}
        const lastPrice = getQuote(t);
        const opts = DB.portfolios.map(p=>`<option value="${p.id}">${__esc(p.name)} (${p.currency})</option>`).join('');
        const data = await openModal({
          title: `Kup ${__esc(t)} (z listy życzeń)`,
          innerHTML: `<form class="grid">
            <div class="col-6"><label>Portfel</label><select name="pfId">${opts}</select></div>
            <div class="col-6"><label>Ilość</label><input name="qty" type="number" step="0.0001" min="0" required /></div>
            <div class="col-6"><label>Cena / szt.</label><input name="price" type="number" step="0.0001" min="0" value="${lastPrice!=null?lastPrice:''}" required oninput="__wlSyncTargets(this.form)" /></div>
            <div class="col-3"><label>Opłaty</label><input name="fees" type="number" step="0.01" min="0" value="0" /></div>
            <div class="col-3"><label>Data</label><input name="date" type="date" value="${today()}" /></div>
            <div class="col-6"><label>Cel SPRZEDAŻY %</label><input name="targetPct" type="number" step="0.01" placeholder="np. 5 = +5%" oninput="__wlSyncTargets(this.form)" /></div><div class="col-6"><label>Cel SPRZEDAŻY (cena)</label><input name="targetPrice" type="number" step="0.0001" min="0" placeholder="np. 350.00" oninput="__wlSyncTargets(this.form)" /></div>
            <div class="col-6"><label>Kolejne kupno %</label><input name="buyTargetPct" type="number" step="0.01" placeholder="np. -5 = kup przy -5%" oninput="__wlSyncTargets(this.form)" /></div><div class="col-6"><label>Kolejne kupno (cena)</label><input name="buyTargetPrice" type="number" step="0.0001" min="0" placeholder="np. 280.00" oninput="__wlSyncTargets(this.form)" /></div>
            <div class="col-12"><label>Usuń z listy po zakupie</label><input type="checkbox" name="remove" /></div>
          </form>`,
          okText:"Zaksięguj zakup"
        });
        if(!data) return;
        const pfId = data.pfId || currentPfId;
        const payload = { ticker:t, date:data.date, qty:data.qty, price:data.price, fees:data.fees, targetPct: data.targetPct||"", targetPrice: data.targetPrice||"", buyTargetPct: data.buyTargetPct||"", buyTargetPrice: data.buyTargetPrice||"" };
        const ts = Number(data.targetSell)||0;
        const tbn = Number(data.targetBuyNext)||0;
        if(ts>0) payload.targetSell = ts;
        if(tbn>0) payload.targetBuyNext = tbn;
        await buy(pfId, payload);
        if(data.remove){ removeWatchItem(id); } else { renderWishlist(); }
      });
    });
  }

  // Search helper for wishlist
  async function wlSearchSymbols(q){
    const {result, error} = await searchSymbolFinnhub(q||'*');
    if(error){ alert('Błąd wyszukiwania: '+error); return; }
    const box = document.getElementById('wlSearchResults');
    if(!box) return;
    const list = (result||[]).slice(0,20).map(r=>`
      <div class="row" data-sym="${r.symbol}" style="padding:4px 6px; border-bottom:1px solid #1f2937; cursor:pointer">
        <div class="ticker" style="min-width:120px">${r.symbol}</div>
        <div class="small" style="opacity:.9">${r.description||''}</div>
      </div>`).join('') || '<div class="small muted">Brak wyników.</div>';
    box.innerHTML = list;
    box.querySelectorAll('[data-sym]').forEach(el=>{
      el.addEventListener('click', async (e)=>{
        const sym = e.currentTarget.getAttribute('data-sym');
        const tEl = document.getElementById('wlTicker');
        if(tEl) tEl.value = sym;
        try{ await fetchQuoteFinnhub(sym); }catch(e){}
        // Fetch and cache company name
try{ const profile = await fetchCompanyProfile(sym); if(profile && profile.name) setCompanyName(sym, profile.name);}catch(_){}
renderWishlist(); updateWishlistBlinkState();
      });
    });
  }

  
  // Live sync between % and absolute targets in wishlist modal
  function __wlSyncTargets(form){
    if(!form) return;
    const priceEl = form.querySelector('input[name="price"]');
    const tgtPctEl = form.querySelector('input[name="targetPct"]');
    const tgtPriceEl = form.querySelector('input[name="targetPrice"]');
    const buyPctEl = form.querySelector('input[name="buyTargetPct"]');
    const buyPriceEl = form.querySelector('input[name="buyTargetPrice"]');
    const p = Number(priceEl && priceEl.value) || 0;
    // SELL target
    if(p>0){
      if(document.activeElement===tgtPctEl || (tgtPctEl && tgtPctEl._lastChanged)){
        const pct = Number(tgtPctEl.value);
        if(!Number.isNaN(pct)) { const v = p * (1 + pct/100); if(tgtPriceEl) tgtPriceEl.value = v ? v.toFixed(4) : ""; }
      }else if(tgtPriceEl){
        const abs = Number(tgtPriceEl.value);
        if(abs>0){ const pct = ((abs/p)-1)*100; if(tgtPctEl) tgtPctEl.value = pct.toFixed(2); }
      }
      // BUY-NEXT target: interpret % literally (np. -5 => -5% od ceny zakupu)
      if(document.activeElement===buyPctEl || (buyPctEl && buyPctEl._lastChanged)){
        const pct = Number(buyPctEl.value);
        if(!Number.isNaN(pct)) { const v = p * (1 + pct/100); if(buyPriceEl) buyPriceEl.value = v ? v.toFixed(4) : ""; }
      }else if(buyPriceEl){
        const abs2 = Number(buyPriceEl.value);
        if(abs2>0){ const pct2 = ((abs2/p)-1)*100; if(buyPctEl) buyPctEl.value = pct2.toFixed(2); }
      }
    }
    // mark last-changed inputs (to avoid ping-pong)
    [tgtPctEl, buyPctEl].forEach(el=>{
      if(el){
        el.addEventListener('input', ()=>{ el._lastChanged = true; });
        el.addEventListener('blur', ()=>{ el._lastChanged = false; });
      }
    });
  }

  
  // Responsive tables: wrap any table without wrapper to enable horizontal scroll on mobile
  function ensureResponsiveTables(){
    document.querySelectorAll('table').forEach(tbl=>{
      if(!tbl.closest('.table-wrap')){
        const wrap = document.createElement('div');
        wrap.className = 'table-wrap';
        tbl.parentNode.insertBefore(wrap, tbl);
        wrap.appendChild(tbl);
      }
    });
  }

  // Event wiring
  $("#addPortfolioBtn").addEventListener('click', async()=>{
    await openModal({
      title:"Nowy portfel",
      innerHTML:`<form class="row">
        <div style="flex:1">
          <label>Nazwa portfela</label>
          <input name="name" placeholder="np. Dywidendy 2026" required />
        </div>
        <div style="width:180px">
          <label>Waluta</label>
          <input name="currency" value="${ensureCurrency()}" placeholder="PLN" />
        </div>
      </form>`
    }).then(data=>{
      if(!data) return;
      addPortfolio();
      renamePortfolio(currentPfId, data.name || "Nowy portfel");
      const pf = getPf(currentPfId);
      if(pf){ pf.currency = (data.currency||"PLN").toUpperCase(); save(); render(); }
    });
  });

  $("#renameBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Zmień nazwę",
      innerHTML:`<form>
        <label>Nazwa</label>
        <input name="name" value="${__esc(pf.name)}" />
      </form>`
    });
    if(data && data.name){ renamePortfolio(currentPfId, data.name); }
  });

  $("#deleteBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return;
    const confirmData = await openModal({
      title:"Usuń portfel",
      okText:"Tak, usuń",
      cancelText:"Jednak nie",
      innerHTML:`<div class="content">
        <p>Czy na pewno chcesz usunąć portfel <b>${__esc(pf.name)}</b>? Operację można cofnąć przez 2 dni (↩️ Cofnij)..</p>
        <p class="small">Saldo: ${__go_fmtCurrency(pf.cash, pf.currency)} • Pozycje: ${Object.keys(pf.holdings).length}</p>
      </div>`
    });
    if(confirmData!==null){ deletePortfolio(currentPfId); }
  });

  $("#settingsBtn").addEventListener('click', async ()=>{
    const s = DB.settings;
    const data = await openModal({
      title:"Ustawienia",
      innerHTML:`<form class="settings-form">
  <style>
    /* Scoped styles for Settings modal */
    .settings-form{ display:flex; flex-direction:column; gap:14px; }
    .settings-sections{ display:grid; grid-template-columns: 1fr; gap:12px; }
    .settings-card{
      border:1px solid #334155; border-radius:12px; padding:12px;
      background: linear-gradient(180deg, rgba(17,24,39,.96), rgba(15,23,42,.96));
    }
    .settings-card h4{ margin:0 0 8px 0; font-size:15px; display:flex; align-items:center; gap:8px; }
    .settings-grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:10px; }
    .s-col-3{ grid-column: span 3; }
    .s-col-4{ grid-column: span 4; }
    .s-col-6{ grid-column: span 6; }
    .s-col-12{ grid-column: span 12; }
    @media (max-width: 720px){
      .settings-grid > *{ grid-column: span 12 !important; }
    }
    .desc{ font-size:12px; opacity:.8; margin-top:6px; }
    .switch{
      display:inline-flex; align-items:center; gap:10px; cursor:pointer; user-select:none;
      padding:8px 10px; border-radius:10px; border:1px solid #334155; background:#0b1222;
    }
    .switch input{ appearance:none; width:36px; height:20px; border-radius:999px; background:#334155; position:relative; outline:none; transition:.2s; }
    .switch input:before{ content:""; position:absolute; width:16px; height:16px; top:2px; left:2px; border-radius:50%; background:#e5e7eb; transition:.2s; }
    .switch input:checked{ background:#10b981; }
    .switch input:checked:before{ transform: translateX(16px); background:#0b1222; }
    .inline{ display:flex; align-items:center; gap:10px; }
    .muted{ color:#94a3b8; }
    .kv{ display:flex; align-items:center; justify-content:space-between; gap:10px; font-size:12px; }
    .kv code{ font-size:12px; opacity:.9; }
    .row{ display:flex; align-items: center; gap:8px; }
    .small{ font-size:12px; color:#94a3b8; }
  
  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

  <div class="settings-sections">

    <!-- OGÓLNE -->
    <div class="settings-card">
      <h4>⚙️ Ogólne</h4>
      <div class="settings-grid">
        <div class="s-col-4">
          <label>Domyślna waluta</label>
          <input name="currencyDefault" value="${s.currencyDefault||'PLN'}" />
          <div class="desc">Używana przy nowych portfelach i formatowaniu wartości.</div>
        </div>
        <div class="s-col-4">
          <label>Stawka podatku (Belki)</label>
          <input name="taxRate" type="number" step="0.01" min="0" max="1" value="${s.taxRate}" />
          <div class="desc">np. 0.19 = 19% (naliczane tylko przy zysku ze sprzedaży).</div>
        </div>
        <div class="s-col-4">
          <label>Saldo ujemne</label>
          <label class="switch">
            <input type="checkbox" name="allowNegativeCash" ${s.allowNegativeCash?'checked':''} />
            <span>Zezwól na saldo ujemne (kredyt/margin)</span>
          </label>
        </div>
      </div>
    </div>

    <!-- API i CENY -->
    <div class="settings-card">
      <h4>📡 API i ceny</h4>
      <div class="settings-grid">
        <div class="s-col-6">
          <label>Finnhub API Token</label>
          <input name="finnhubToken" value="${s.finnhubToken||''}" />
          
        </div>
        <div class="s-col-3">
          <label>Odświeżanie kursów [s]</label>
          <input name="pricePollSeconds" type="number" min="5" step="1" value="${s.pricePollSeconds||30}" />
          <div class="desc">Częstotliwość pobierania cen.</div>
        </div>
        <div class="s-col-3">
          <label>Tolerancja „zbliża się” [%]</label>
          <input name="approachTolerancePct" type="number" step="0.1" min="0" value="${s.approachTolerancePct||1}" />
          <div class="desc">Ile % od celu uznajemy za „blisko”.</div>
        </div>
      </div>
    </div>

    <!-- ALERTY DŹWIĘKOWE -->
    <div class="settings-card">
      <h4>🛎️ Alerty dźwiękowe</h4>
      <div class="settings-grid">
        <div class="s-col-4">
          <label>Główne</label>
          <label class="switch">
            <input type="checkbox" name="soundAlertsEnabled" ${s.soundAlertsEnabled!==false?'checked':''} />
            <span>Włącz alarmy dźwiękowe</span>
          </label>
        </div>
        <div class="s-col-4">
          <label>„Cel osiągnięty”</label>
          <label class="switch">
            <input type="checkbox" name="soundHitTarget" ${s.soundHitTarget!==false?'checked':''} />
            <span>Odtwarzaj przy trafieniu w cel</span>
          </label>
        </div>
        <div class="s-col-4">
          <label>„Blisko celu”</label>
          <label class="switch">
            <input type="checkbox" name="soundNearTarget" ${s.soundNearTarget!==false?'checked':''} />
            <span>Odtwarzaj przy zbliżeniu</span>
          </label>
        </div>

        <div class="s-col-6">
          <label>Głośność alarmu</label>
          <div class="inline">
            <input name="soundVolume" type="range" min="0" max="150" step="1"
                   value="${(s.soundVolume??60)}"
                   oninput="this.nextElementSibling.value=this.value + '%'" />
            <output class="small">${(s.soundVolume??60)}%</output>
          </div>
        </div>
        <div class="s-col-6">
          <label>Powtarzanie alarmu [s]</label>
          <input name="soundRepeatSeconds" type="number" min="5" step="5" value="${(s.soundRepeatSeconds??60)}" />
          <div class="desc">Co ile sekund ponowić sygnał, gdy stan nadal trwa.</div>
        </div>
      </div>
    </div>

  </div>

    <div class="settings-card">
      <h4>Historia i cofanie</h4>
      <div class="row">
        <button class="btn ghost" id="undoBtn" title="Cofnij ostatnią zmianę (historia 2 dni)">↩️ Cofnij</button>
        <span class="small muted">Ctrl/Cmd+Z — cofnij transakcję • Shift+↩️ / Ctrl/Cmd+Shift+Z — krokowo</span>
      </div>
    </div>
</form>`
    });
    if(data){
      DB.settings.taxRate = Number(data.taxRate)||0.19;
      DB.settings.currencyDefault = (data.currencyDefault||"PLN").toUpperCase();
      DB.settings.allowNegativeCash = !!data.allowNegativeCash;
      DB.settings.finnhubToken = data.finnhubToken||"";
      DB.settings.pricePollSeconds = Number(data.pricePollSeconds)||30;
      DB.settings.approachTolerancePct = Number(data.approachTolerancePct)||1;
      DB.settings.soundAlertsEnabled = !!data.soundAlertsEnabled;
      DB.settings.soundHitTarget = !!data.soundHitTarget;
      DB.settings.soundNearTarget = !!data.soundNearTarget;
            DB.settings.soundVolume = Number(data.soundVolume ?? DB.settings.soundVolume ?? 40);
      DB.settings.soundRepeatSeconds = Number(data.soundRepeatSeconds ?? DB.settings.soundRepeatSeconds ?? 60);
save(); render();
      startPollingQuotes();
    }
    if(data){
      DB.settings.taxRate = Number(data.taxRate)||0.19;
      DB.settings.currencyDefault = (data.currencyDefault||"PLN").toUpperCase();
      DB.settings.allowNegativeCash = !!data.allowNegativeCash;
      save(); render();
    }
  });

  $("#depositBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Wpłata do portfela",
      innerHTML:`<form class="grid">
        <div class="col-6">
          <label>Kwota (${pf.currency})</label>
          <input name="amount" type="number" step="0.01" min="0" required />
        </div>
        <div class="col-12">
          <label>Notatka (opcjonalnie)</label>
          <input name="note" />
        </div>
      </form>`
    });
    if(data && data.amount){ deposit(currentPfId, data.amount, data.note||""); }
  });

  $("#cashActionsBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Operacje gotówkowe",
      innerHTML:`<form class="grid">
        <div class="col-6">
          <label>Kwota (${pf.currency})</label>
          <input name="amount" type="number" step="0.01" min="0" required />
        </div>
        <div class="col-6">
          <label>Rodzaj</label>
          <select name="kind">
            <option value="deposit">Wpłata</option>
            <option value="withdraw">Wypłata</option>
          </select>
        </div>
        <div class="col-12">
          <label>Notatka</label>
          <input name="note" />
        </div>
      </form>`
    });
    if(!data) return;
    if(data.kind==="deposit") deposit(currentPfId, data.amount, data.note||"");
    else withdraw(currentPfId, data.amount, data.note||"");
  });

  $("#withdrawBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Wypłata z portfela",
      innerHTML:`<form class="grid">
        <div class="col-6">
          <label>Kwota (${pf.currency})</label>
          <input name="amount" type="number" step="0.01" min="0" required />
        </div>
        <div class="col-12">
          <label>Notatka (opcjonalnie)</label>
          <input name="note" />
        </div>
      </form>`
    });
    if(data && data.amount){ withdraw(currentPfId, data.amount, data.note||""); }
  });

  $("#transferBtn").addEventListener('click', async ()=>{
    if(DB.portfolios.length<2){ return alert("Dodaj przynajmniej dwa portfele, aby wykonać przelew."); }
    const opts = DB.portfolios.map(p=>`<option value="${p.id}">${__esc(p.name)} (${p.currency})</option>`).join("");
    const data = await openModal({
      title:"Przelew między portfelami",
      innerHTML:`<form class="grid">
        <div class="col-6">
          <label>Źródło</label>
          <select name="fromId">${opts}</select>
        </div>
        <div class="col-6">
          <label>Cel</label>
          <select name="toId">${opts}</select>
        </div>
        <div class="col-6">
          <label>Kwota</label>
          <input name="amount" type="number" step="0.01" min="0" required />
        </div>
        <div class="col-6">
          <label>Data</label>
          <input name="date" type="date" value="${today()}" />
        </div>
        <div class="col-12">
          <label>Notatka</label>
          <input name="note" placeholder="np. pożyczka z firmy A do B" />
        </div>
      </form>`
    });
    if(!data) return;
    transfer(data.fromId, data.toId, data.amount, data.note||"");
  });

  $("#buyBtn").addEventListener('click', async ()=>{
    const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
    const data = await openModal({
      title:"Zakup (nowa partia)",
      innerHTML:`<form class="grid">
        <div class="col-4">
          <label>Ticker <span class="small">(Enter pobierze kurs z Finnhub)</span></label>
          <div class="row" style="gap:6px"><input name="ticker" id="buyTicker" placeholder="np. TSLA / PKN.WA" required /><button type="button" class="btn secondary" id="btnFetchPrice">Pobierz cenę</button><button type="button" class="btn ghost" id="btnSearchSymbol">Szukaj symbolu</button></div>
        </div>
        <div class="col-4">
          <label>Ilość</label>
          <input name="qty" type="number" step="0.0001" min="0" required />
        </div>
        <div class="col-4">
          <label>Cena / szt.</label>
          <input name="price" id="buyPrice" type="number" step="0.0001" min="0" required />
        </div>
        <div class="col-4">
          <label>Opłaty</label>
          <input name="fees" type="number" step="0.01" min="0" value="0" />
        </div>
        <div class="col-4">
          <label>Data</label>
          <input name="date" type="date" value="${today()}" />
        </div>
        <div class="col-4">
          <label>Cel zysku % (opcjonalnie)</label>
          <input name="targetPct" type="number" step="0.01" placeholder="np. 5 = +5%" />
        </div>
        <div class="col-4">
          <label>Cel cena / szt. (opcjonalnie)</label>
          <input name="targetPrice" type="number" step="0.0001" placeholder="np. 120.00" />
        </div>
        <div class="col-4">
          <label>Cel KUPNA % (spadek, opcj.)</label>
          <input name="buyTargetPct" type="number" step="0.01" placeholder="np. 5 = -5% od kosztu" />
        </div>
        <div class="col-4">
          <label>Cel KUPNA cena / szt. (opcj.)</label>
          <input name="buyTargetPrice" type="number" step="0.0001" placeholder="np. 95.00" />
        </div>
        <div class="col-12 small" id="buyPriceMsg" style="min-height:20px"></div>
        <div class="col-12">
          <label>Notatka</label>
          <input name="note" placeholder="np. zakup wg strategii momentum" />
        </div>
        <div class="col-12 small">Uwaga: kurs z Finnhub może być w walucie notowania instrumentu (bez konwersji).</div>
      </form>`
    });
    const tEl = $("#buyTicker"), pEl = $("#buyPrice"), msgEl = $("#buyPriceMsg");
    async function uiFetchPrice(){
      msgEl.textContent = "Pobieram cenę z Finnhub…";
      const sym = (tEl.value||"").trim().toUpperCase();
      if(!sym){ msgEl.textContent = "Podaj symbol (np. TSLA, PKN.WA)"; return; }
      const {price, error} = await fetchQuoteFinnhub(sym);
      if(price!=null){ pEl.value = price; msgEl.textContent = "OK: " + price; }
      else { msgEl.textContent = "Błąd: " + (error||"brak danych"); }
    }
    tEl?.addEventListener('keydown', async (ev)=>{
      if(ev.key==="Enter"){
        ev.preventDefault();
        await uiFetchPrice();
      }
    });
    $("#btnFetchPrice")?.addEventListener('click', uiFetchPrice);

    $("#btnSearchSymbol")?.addEventListener('click', async ()=>{
      const q = (tEl.value||"").trim();
      const {result, error} = await searchSymbolFinnhub(q||"*");
      if(error){ alert("Szukaj symbolu — błąd: "+error); return; }
      if(!result.length){ alert("Brak wyników dla: "+q); return; }
      // simple picker in-place
      const list = result.slice(0,10).map(r=>`
        <tr data-sym="${r.symbol}"><td>${r.symbol}</td><td>${r.description||''}</td><td class="small">${r.type||''}</td><td class="small">${r.displaySymbol||''}</td></tr>
      `).join("");
      const picker = document.createElement('div');
      picker.className = "card panel";
      picker.innerHTML = `<div class="small" style="margin:6px 0">Wybierz symbol:</div><div class="table-wrap"><table><thead><tr><th>Symbol</th><th>Opis</th><th>Typ</th><th>Display</th></tr></thead><tbody>${list}</tbody></table></div>`;
      modalContent.appendChild(picker);
      picker.addEventListener('click', async (e)=>{
        const tr = e.target.closest('tr[data-sym]'); if(!tr) return;
        const sym = tr.getAttribute('data-sym');
        tEl.value = sym;
        picker.remove();
        await uiFetchPrice();
      }, {once:false});
    });

    if(!data) return;
    buy(currentPfId, {
      ticker: data.ticker, date: data.date, qty: data.qty, price: data.price, fees: data.fees, note: data.note,
      targetPct: data.targetPct, targetPrice: data.targetPrice, buyTargetPct: data.buyTargetPct, buyTargetPrice: data.buyTargetPrice
    });
  });

  
$("#sellBtn").addEventListener('click', ()=>{
  const pf = getPf(currentPfId); if(!pf) return alert("Najpierw wybierz portfel.");
  const tickers = Object.keys(pf.holdings||{});
  if(!tickers.length) return alert("Brak pozycji do sprzedaży.");
  const optsTick = tickers.map(t=>`<option value="${t}">${t}</option>`).join("");

  const prom = openModal({
    title:"Sprzedaż — wybierz partie i ilości",
    innerHTML:`<form id="sellForm" class="content">
      <label>Ticker</label>
      <select name="ticker" id="sellTicker">${optsTick}</select>
      <div id="sellLotsBox" style="margin-top:12px"></div>
    </form>`,
    okText:"Zaksięguj"
  });

  const selEl = $("#sellTicker");
  const lotsBox = $("#sellLotsBox");
  function renderLots(){
    const t = selEl.value;
    const book = pf.holdings[t];
    if(!book){ lotsBox.innerHTML = "<div class='small'>Brak partii.</div>"; return; }
    const rows = (book.lots||[]).map(l=>`
      <tr>
        <td><code>${l.lotId.slice(0,8)}</td>
        <td>${__esc(l.date||"")}</td>
        <td>${__fmtNum(l.qty)}</td>
        <td>${__go_fmtCurrency(l.unitCost, pf.currency)}</td>
        <td><input name="lot_${l.lotId}" type="number" step="0.0001" min="0" max="${l.qty}" placeholder="0" /></td>
      </tr>
    `).join("");
    lotsBox.innerHTML = `
      <div class="grid">
        <div class="col-4">
          <label>Cena sprzedaży / szt.</label>
          <input name="sellPrice" id="sellPrice" type="number" step="0.0001" min="0" required />
        </div>
        <div class="col-4">
          <label>Opłaty</label>
          <input name="sellFees" id="sellFees" type="number" step="0.01" min="0" value="0" />
        </div>
        <div class="col-4">
          <label>Data</label>
          <input name="sellDate" id="sellDate" type="date" value="${today()}" />
        </div>
        <div class="col-12">
          <label>Notatka</label>
          <input name="sellNote" id="sellNote" placeholder="np. realizacja zysku" />
        </div>
      </div>
      <div style="margin-top:10px"></div>
      <table>
        <thead>
          <tr><th>Partia</th><th>Data</th><th>Ilość dostępna</th><th>Koszt / szt.</th><th>Ilość do sprzedaży</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <div class="small">Wpisz ilości do sprzedaży w wybranych partiach (sprzedaż specyficzna — nie FIFO).</div>
    `;
  }
  renderLots();
  selEl.addEventListener('change', renderLots);

  prom.then(data=>{
    if(!data) return; // cancel
    const t = (data.ticker||"").toUpperCase().trim();
    const pSell = Number(data.sellPrice||0);
    const fees = Number(data.sellFees||0);
    const date = data.sellDate || today();
    const note = data.sellNote || "";
    const allocations = Object.entries(data)
      .filter(([k,v])=> k.startsWith('lot_') && Number(v)>0)
      .map(([k,v])=>({ lotId: k.slice(4), qty: Number(v) }));
    sell(currentPfId, { ticker: t, date, sellPrice: pSell, fees, allocations, note });
  });
});

  // Ex/Im port
  function exportJSON(){
    const data = JSON.stringify(DB, null, 2);
    const blob = new Blob([data], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `portfele_firmy_backup_${new Date().toISOString().slice(0,10)}.json`;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      URL.revokeObjectURL(url);
      a.remove();
    }, 1000);
  }
  $("#exportBtn").addEventListener('click', exportJSON);
  $("#exportLink2").addEventListener('click', exportJSON);
  $("#importLink2").addEventListener('click', ()=> $("#importFile").click());
  $("#importFile").addEventListener('change', async (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const txt = await file.text();
    try{
      const obj = JSON.parse(txt);
      if(!obj.portfolios) throw new Error("Brak klucza portfolios.");
      DB = obj; try{ ensureWatchlistStructure(); }catch(_){} save(); render(); startPollingQuotes();
      alert("Zaimportowano dane.");
    }catch(err){
      alert("Błąd importu: "+err.message);
    }
    e.target.value = "";
  });

  
  // History actions: Edit / Delete
  txTableWrap.addEventListener('click', async (e)=>{
    const row = e.target.closest('tr.tx-row');
    const btn = e.target.closest('button');
    const pf = getPf(currentPfId); if(!pf) return;
    if(row && !btn){ // click row to edit
      const txId = row.getAttribute('data-tx');
      const txIndex = pf.transactions.findIndex(x=>x.id===txId);
      if(txIndex>=0){ const fakeBtn = document.createElement('button'); fakeBtn.className='tx-edit'; fakeBtn.setAttribute('data-tx', txId); fakeBtn.click(); }
      return;
    }
    if(!btn) return;
    const txId = btn.getAttribute('data-tx'); if(!txId) return;
    const txIndex = pf.transactions.findIndex(x=>x.id===txId);
    if(txIndex<0) return;

    if(btn.classList.contains('tx-sell-from-buy')){
      const txId = btn.getAttribute('data-tx');
      const txIndex = pf.transactions.findIndex(x=>x.id===txId);
      if(txIndex<0) return;
      const t = pf.transactions[txIndex];
      if(t.type!=='buy'){ return; }
      const lotId = t.lotId; const ticker = t.ticker; const maxQty = t.qty;
      const formHTML = `<form class="grid">
          <div class="col-4">
            <label>Cena sprzedaży / szt.</label>
            <input name="sellPrice" type="number" step="0.0001" min="0" required />
          </div>
          <div class="col-4">
            <label>Opłaty</label>
            <input name="fees" type="number" step="0.01" min="0" value="0" />
          </div>
          <div class="col-4">
            <label>Data</label>
            <input name="date" type="date" value="${today()}" />
          </div>
          <div class="col-4">
            <label>Ilość do sprzedaży</label>
            <input name="qty" type="number" step="0.0001" min="0" max="${maxQty}" value="${maxQty}" />
          </div>
          <div class="col-12">
            <label>Notatka</label>
            <input name="note" placeholder="sprzedaż tej transakcji (szybka)" />
          </div>
        </form>`;
      openModal({ title:`Sprzedaj tę transakcję — ${__esc(ticker)}`, innerHTML: formHTML, okText:'Zaksięguj' }).then(data=>{
        if(!data) return;
        const qty = Number(data.qty||0);
        const price = Number(data.sellPrice||0);
        const fees = Number(data.fees||0);
        const date = data.date || today();
        const note = data.note || '';
        if(qty<=0 || price<=0){ alert('Podaj ilość i cenę.'); return; }
        sell(currentPfId, { ticker, date, sellPrice: price, fees, allocations: [{ lotId, qty }], note });
      });
      return;
    }

    if(btn.classList.contains('tx-del')){
      const ok = confirm("Usunąć tę transakcję? Operacja nieodwracalna.");
      if(!ok) return;
      pf.transactions.splice(txIndex,1);
      rebuildPortfolio(pf); save(); render();
      return;
    }

    if(btn.classList.contains('tx-edit')){
      const t = pf.transactions[txIndex];
      // Build form per type
      let formHTML = "";
      if(t.type==="deposit" || t.type==="withdraw" || t.type==="transfer_in" || t.type==="transfer_out"){
        formHTML = `<form>
          <label>Kwota (${pf.currency})</label>
          <input name="amount" type="number" step="0.01" value="${t.amount||0}" />
          <label>Data</label>
          <input name="date" type="date" value="${t.date||today()}" />
          <label>Notatka</label>
          <input name="note" value="${__esc(t.note||'')}" />
        </form>`;
      }else if(t.type==="buy"){
        formHTML = `<form>
          <label>Ticker</label>
          <input name="ticker" value="${__esc(t.ticker||'')}" />
          <label>Ilość</label>
          <input name="qty" type="number" step="0.0001" value="${t.qty||0}" />
          <label>Cena / szt.</label>
          <input name="price" type="number" step="0.0001" value="${t.price||0}" />
          <label>Opłaty</label>
          <input name="fees" type="number" step="0.01" value="${t.fees||0}" />
          <label>Data</label>
          <input name="date" type="date" value="${t.date||today()}" />
          <label>Notatka</label>
          <input name="note" value="${__esc(t.note||'')}" />
        
        <label>Cel zysku % (opcjonalnie)</label>
        <input name="targetPct" type="number" step="0.01" value="${t.targetPct ?? ''}" placeholder="np. 5 = +5%" />
        <label>Cel cena / szt. (opcjonalnie)</label>
        <input name="targetPrice" type="number" step="0.0001" value="${t.targetPrice ?? ''}" placeholder="np. 120.00" />
        <label>Cel KUPNA % (spadek, opcj.)</label>
        <input name="buyTargetPct" type="number" step="0.01" value="${t.buyTargetPct ?? ''}" placeholder="np. 5 = -5% od kosztu" />
        <label>Cel KUPNA cena / szt. (opcj.)</label>
        <input name="buyTargetPrice" type="number" step="0.0001" value="${t.buyTargetPrice ?? ''}" placeholder="np. 95.00" />
        
        </form>`;
      }else if(t.type==="sell"){
        // For now: edit price/fees/date/note; allocations pozostają bez zmian
        formHTML = `<form>
          <div class="small">Edycja sprzedaży dotyczy ceny/opłat/daty/uwag. (Alokacje partii bez zmian w tej wersji)</div>
          <label>Ticker</label>
          <input name="ticker" value="${__esc(t.ticker||'')}" />
          <label>Łączna ilość (informacyjnie)</label>
          <input type="number" step="0.0001" value="${t.qty||0}" disabled />
          <label>Cena sprzedaży / szt.</label>
          <input name="price" type="number" step="0.0001" value="${t.price||0}" />
          <label>Opłaty</label>
          <input name="fees" type="number" step="0.01" value="${t.fees||0}" />
          <label>Data</label>
          <input name="date" type="date" value="${t.date||today()}" />
          <label>Notatka</label>
          <input name="note" value="${__esc(t.note||'')}" />
        </form>`;
      }

      const data = await openModal({ title:"Edytuj transakcję", innerHTML: formHTML, okText:"Zapisz" });
      if(!data) return;

      // Apply edits
      if(t.type==="deposit" || t.type==="withdraw" || t.type==="transfer_in" || t.type==="transfer_out"){
        t.amount = Number(data.amount)||0;
        t.date = data.date || t.date;
        t.note = data.note || "";
      }else if(t.type==="buy"){
        t.ticker = (data.ticker||t.ticker||"").toUpperCase().trim();
        t.qty = Number(data.qty)||t.qty;
        t.price = Number(data.price)||t.price;
        t.fees = Number(data.fees)||t.fees;
        t.date = data.date || t.date;
        t.note = data.note || "";
        ensureBuyLotIdInTx(t);
      }else if(t.type==="sell"){
        t.ticker = (data.ticker||t.ticker||"").toUpperCase().trim();
        t.price = Number(data.price)||t.price;
        t.fees = Number(data.fees)||t.fees;
        t.date = data.date || t.date;
        t.note = data.note || "";
        // gross/net will be recomputed during rebuild
      }
      // Rebuild to keep everything consistent
      try{
        rebuildPortfolio(pf);
      }catch(err){
        alert("Edycja powoduje niespójność (np. sprzedaż > posiadane). Szczegóły: "+err.message);
        return; // do not save/render on failure
      }
      save(); render();
    }
  });

  
  // Quick actions in holdings: edit lot (buy tx) or sell this lot
  holdingsTableWrap.addEventListener('click', async (e)=>{
    const btn = e.target.closest('button'); if(!btn) return;
    

    if (btn.classList.contains('del-company')){
      const ticker = btn.getAttribute('data-ticker');
      if(!ticker) return;
      const pf = getPf(currentPfId); if(!pf) return;
      const ok = confirm(`Na pewno usunąć spółkę ${ticker} z portfela (skasuje WSZYSTKIE transakcje tej spółki)?`);
      if(!ok) return;
      try{
        pf.transactions = (pf.transactions||[]).filter(tx => (tx.ticker||'').toUpperCase() !== ticker);
        try{ delete pf.holdings[ticker]; }catch(_){}
        rebuildPortfolio(pf);
        save(); render();
        try{ showToast && showToast({title:'Usunięto spółkę', message:ticker}); }catch(_){}
      }catch(err){
        alert('Nie udało się usunąć spółki: ' + (err && err.message || err));
      }
      return;
    }
    if (btn.classList.contains('info-company')){
      const ticker = btn.getAttribute('data-ticker');
      if(!ticker) return;
      openCompanyInfoModal(ticker);
      return;
    }
    if(btn.classList.contains('transfer-company')){
  const ticker = btn.getAttribute('data-ticker');
  await transferCompanyDialog(currentPfId, ticker);
  return;
}
const pf = getPf(currentPfId); if(!pf) return;
    if(btn.classList.contains('lot-edit')){
      const ticker = btn.getAttribute('data-ticker');
      const lotId = btn.getAttribute('data-lot');
      const txIndex = pf.transactions.findIndex(x=> x.type==='buy' && x.lotId===lotId);
      if(txIndex<0) { alert('Nie znaleziono transakcji zakupu dla tej partii.'); return; }
      const t = pf.transactions[txIndex];
      const formHTML = `<form>
          <label>Ticker</label>
          <input name="ticker" value="${__esc(t.ticker||'')}" />
          <label>Ilość</label>
          <input name="qty" type="number" step="0.0001" value="${t.qty||0}" />
          <label>Cena / szt.</label>
          <input name="price" type="number" step="0.0001" value="${t.price||0}" />
          <label>Opłaty</label>
          <input name="fees" type="number" step="0.01" value="${t.fees||0}" />
          <label>Data</label>
          <input name="date" type="date" value="${t.date||today()}" />
          <label>Cel zysku %</label>
          <input name="targetPct" type="number" step="0.01" value="${t.targetPct??''}" />
          <label>Cel cena / szt.</label>
          <input name="targetPrice" type="number" step="0.0001" value="${t.targetPrice??''}" />
          <label>Cel KUPNA %</label>
          <input name="buyTargetPct" type="number" step="0.01" value="${t.buyTargetPct??''}" />
          <label>Cel KUPNA cena / szt.</label>
          <input name="buyTargetPrice" type="number" step="0.0001" value="${t.buyTargetPrice??''}" />
          <label>Notatka</label>
          <input name="note" value="${__esc(t.note||'')}" />
        </form>`;
      const data = await openModal({ title:"Edytuj zakup (partia)", innerHTML: formHTML, okText:"Zapisz"  });
if(!data) return;
      t.ticker = (data.ticker||t.ticker||'').toUpperCase().trim();
      t.qty = Number(data.qty)||t.qty;
      t.price = Number(data.price)||t.price;
      t.fees = Number(data.fees)||t.fees;
      t.date = data.date || t.date;
      t.note = data.note || "";
      t.targetPct = (data.targetPct!=='' && data.targetPct!==undefined) ? Number(data.targetPct) : null;
      t.targetPrice = (data.targetPrice!=='' && data.targetPrice!==undefined) ? Number(data.targetPrice) : null;
        t.buyTargetPct = (data.buyTargetPct!=='' && data.buyTargetPct!==undefined) ? Number(String(data.buyTargetPct).replace(',', '.')) : null;
        t.buyTargetPrice = (data.buyTargetPrice!=='' && data.buyTargetPrice!==undefined) ? Number(String(data.buyTargetPrice).replace(',', '.')) : null;
      try{
        rebuildPortfolio(pf);
      }catch(err){
        alert("Edycja powoduje niespójność (np. sprzedaż > posiadane). Szczegóły: "+err.message);
        return;
      }
      save(); render();
    }
    if(btn.classList.contains('lot-sell')){
      const ticker = btn.getAttribute('data-ticker');
      const lotId = btn.getAttribute('data-lot');
      const maxQty = Number(btn.getAttribute('data-maxqty')||0);
      const formHTML = `<form class="grid">
          <div class="col-4">
            <label>Cena sprzedaży / szt.</label>
            <input name="sellPrice" type="number" step="0.0001" min="0" required />
          </div>
          <div class="col-4">
            <label>Opłaty</label>
            <input name="fees" type="number" step="0.01" min="0" value="0" />
          </div>
          <div class="col-4">
            <label>Data</label>
            <input name="date" type="date" value="${today()}" />
          </div>
          <div class="col-4">
            <label>Ilość do sprzedaży</label>
            <input name="qty" type="number" step="0.0001" min="0" max="${maxQty}" value="${maxQty}" />
          </div>
          <div class="col-12">
            <label>Notatka</label>
            <input name="note" placeholder="sprzedaż partii # (szybka)" />
          </div>
        </form>`;
      const data = await openModal({ title:`Sprzedaj partię — ${__esc(ticker)}`, innerHTML: formHTML, okText:"Zaksięguj" });
      if(!data) return;
      const qty = Number(data.qty||0);
      const price = Number(data.sellPrice||0);
      const fees = Number(data.fees||0);
      const date = data.date || today();
      const note = data.note || "";
      if(qty<=0 || price<=0){ alert("Podaj ilość i cenę."); return; }
      sell(currentPfId, { ticker, date, sellPrice: price, fees, allocations: [{ lotId, qty }], note });
    }
    if(btn.classList.contains('add-lot')){
      const ticker = (btn.getAttribute('data-ticker')||'').trim().toUpperCase();
      const pf = getPf(currentPfId); if(!pf) return;
      const lastPrice = getQuote(ticker);
      const data = await openModal({
        title: `Zakup (nowa partia) — ${ticker}`,
        innerHTML: `<form class="grid">
          <div class="col-4">
            <label>Ticker</label>
            <input name="ticker" value="${ticker}" readonly />
          </div>
          <div class="col-4">
            <label>Ilość</label>
            <input name="qty" type="number" step="0.0001" min="0" required />
          </div>
          <div class="col-4">
            <label>Cena / szt.</label>
            <input name="price" type="number" step="0.0001" min="0" value="${lastPrice!=null?lastPrice:''}" required />
          </div>
          <div class="col-4">
            <label>Opłaty</label>
            <input name="fees" type="number" step="0.01" min="0" value="0" />
          </div>
          <div class="col-4">
            <label>Data</label>
            <input name="date" type="date" value="${today()}" />
          </div>
          <div class="col-4">
            <label>Cel zysku % (opcjonalnie)</label>
            <input name="targetPct" type="number" step="0.01" placeholder="np. 5 = +5%" />
          </div>
          <div class="col-4">
            <label>Cel cena / szt. (opcjonalnie)</label>
            <input name="targetPrice" type="number" step="0.0001" placeholder="np. 120.00" />
          </div>
          <div class="col-4">
            <label>Cel KUPNA % (spadek, opcj.)</label>
            <input name="buyTargetPct" type="number" step="0.01" placeholder="np. -5 = kup przy -5%" />
          </div>
          <div class="col-4">
            <label>Cel KUPNA, cena/szt. (opcj.)</label>
            <input name="buyTargetPrice" type="number" step="0.0001" placeholder="np. 90.00" />
          </div>
          <div class="col-12">
            <label>Notatka</label>
            <textarea name="note" rows="2" placeholder="np. dokup pod odbicie"></textarea>
          </div>
        </form>`
      });
      if(!data) return;
      buy(currentPfId, {
        ticker: data.ticker, date: data.date, qty: data.qty, price: data.price, fees: data.fees, note: data.note,
        targetPct: data.targetPct, targetPrice: data.targetPrice,
        buyTargetPct: data.buyTargetPct, buyTargetPrice: data.buyTargetPrice
      });
      return;
    }

 else if(btn.classList.contains('lot-mute')){
      const lotId = btn.getAttribute('data-lot');
      // find the lot in current portfolio
      let target = null, targetTicker=null;
      for(const [tk, book] of Object.entries(pf.holdings||{})){
        const found = (book.lots||[]).find(x=> x.lotId === lotId);
        if(found){ target = found; targetTicker=tk; break; }
      }
      if(!target) return;
      target.muted = !target.muted;
      save(); render();
      return;
    }
});


  // Tab button
  document.getElementById('wishlistTabBtn')?.addEventListener('click', ()=>{
    const isWishlistVisible = document.getElementById('wishlistPanel')?.style.display !== 'none';
    setActiveView(isWishlistVisible ? 'portfolio' : 'wishlist');
  });

  // Wishlist form actions
  document.getElementById('wlSearch')?.addEventListener('click', async ()=>{
    const q = (document.getElementById('wlTicker')?.value||'').trim();
    await wlSearchSymbols(q);
  });
  document.getElementById('wlAdd')?.addEventListener('click', async ()=>{
    const t = document.getElementById('wlTicker')?.value||'';
    const p = document.getElementById('wlPrice')?.value||'';
    addWatchItem(t, p);
    const tEl=document.getElementById('wlTicker'); if(tEl) tEl.value='';
    const pEl=document.getElementById('wlPrice'); if(pEl) pEl.value='';
    try{ const t=document.getElementById('wlTicker')?.value||''; if(t){ const profile = await fetchCompanyProfile(t); if(profile && profile.name) setCompanyName(t, profile.name); } }catch(_){}
    renderWishlist();
  });


  // Filters
  filterQueryEl.addEventListener('input', ()=> renderMain());

  // Strategy autosave
  strategyBox.addEventListener('input', ()=>{
    const pf = getPf(currentPfId); if(!pf) return;
    pf.strategy = strategyBox.value;
    pf.updatedAt = new Date().toISOString();
    save();
  });

  function render(){
    renderPortfolioList();
    renderMain();
    try{ ensureResponsiveTables(); }catch(_){ }
  try { updateSidebarBlinkStates(); } catch(e) {}
  try { updateWishlistBlinkState(); } catch(e) {}
    
  // Filter clear
  const filterClearBtn = document.getElementById('filterClearBtn');
  if(filterClearBtn && !filterClearBtn.dataset.bound){
    filterClearBtn.dataset.bound='1';
    filterClearBtn.addEventListener('click', ()=>{ filterQueryEl.value=''; renderMain(); });
  }
startPollingQuotes();
  }

  // Initial render
  render();
  try { renderWishlist(); updateWishlistBlinkState(); } catch(e) {}
  // Upublicznienie wiązań dla Firebase
  try{
    window.save = save;
    window.render = render;
    window.__setAppDB = (obj)=>{ 
      DB = obj; 
      try{
        // Migrate wishlist items to multi-target schema after loading from server
        DB.watchlist = DB.watchlist || [];
        for(const w of DB.watchlist){
          if(!Array.isArray(w.targets)){
            const base = Number(w.price)||0;
            w.targets = base>0 ? [base] : [];
            try{ delete w.price; }catch(_){}
          }
          if(typeof w.activeIndex!=='number') w.activeIndex = 0;
          if(typeof w.name!=='string') w.name = w.name||'';
        }
      }catch(_){}
      save(); 
      try { render(); } catch(_){}
      try { renderWishlist(); updateWishlistBlinkState(); } catch(_){}
    };
  }catch(e){ console.warn('Expose bindings failed', e); }
})();
</script>
<script>
// === Collapsible History (persist state) ===
(function(){
  function setupHistoryCollapse(){
    const panel = document.getElementById('historyPanel');
    if(!panel) return;
    const btn = document.getElementById('historyCollapseBtn');
    const title = document.getElementById('historyTitle');
    const KEY = 'historyCollapsed';
    try{
      const initial = localStorage.getItem(KEY) === '1';
      if(initial) panel.classList.add('collapsed');
    }catch(e){}
    function toggle(){
      panel.classList.toggle('collapsed');
      try{ localStorage.setItem(KEY, panel.classList.contains('collapsed') ? '1':'0'); }catch(e){}
    }
    if(btn && !btn.dataset.bound){ btn.addEventListener('click', toggle); btn.dataset.bound='1'; }
    if(title && !title.dataset.bound){ title.addEventListener('click', toggle); title.dataset.bound='1'; }
  }
  // run now (scripts loaded at end of body), and also after any global re-render if needed
  try { setupHistoryCollapse(); } catch(e) {}
  // re-apply on renderMain
  if(typeof renderMain === 'function'){
    const orig = renderMain;
    window.renderMain = function(){
      const result = orig.apply(this, arguments);
      try { setupHistoryCollapse(); } catch(e) {}
      return result;
    }
  }
})();
</script>

  <script>
  // Status UI between title and actions
  (function(){
    function findHeader(){ return document.querySelector('header'); }
    function findActions(){ return document.querySelector('header .actions'); }
    function ensureStatusBetween(){
      const h = findHeader(); const a = findActions(); if(!h) return null;
      let wrap = document.getElementById('syncStatusWrap');
      if(!wrap){
        wrap = document.createElement('div');
        wrap.id='syncStatusWrap';
        wrap.style.display='inline-flex';
        wrap.style.alignItems='center';
        wrap.style.gap='6px';
        wrap.style.marginLeft='16px';
        const dot = document.createElement('span'); dot.id='syncDot';
        dot.style.width='12px'; dot.style.height='12px'; dot.style.borderRadius='50%'; dot.style.display='inline-block';
        dot.style.boxShadow='0 0 0 1px rgba(0,0,0,0.25) inset'; dot.style.background='#9ca3af';
        const txt = document.createElement('span'); txt.id='syncText'; txt.style.fontSize='12px'; txt.style.opacity='0.9'; txt.textContent='Firebase: ...';
        wrap.appendChild(dot); wrap.appendChild(txt);
        if(a){ h.insertBefore(wrap, a); } else { h.appendChild(wrap); }
      }
      return wrap;
    }
    function color(c){ const d=document.getElementById('syncDot'); if(d) d.style.background=c; }
    function label(t){ const e=document.getElementById('syncText'); if(e) e.textContent=t; }
    function pad(n){ return (n<10?'0':'')+n; } function hhmmss(ts){ const d=new Date(ts); return pad(d.getHours())+':'+pad(d.getMinutes())+':'+pad(d.getSeconds()); }
    window.setSyncStatus = function(state){
      ensureStatusBetween();
      if(state==='syncing'){ color('#f59e0b'); label('Firebase: Synchronizacja...'); return; }
      if(state==='ok'){ color('#10b981'); var t=window.__lastSyncAt?(' ('+hhmmss(window.__lastSyncAt)+')'):''; label('Firebase: OK'+t); return; }
      if(state==='error'){ color('#ef4444'); label('Firebase: Błąd'); return; }
      if(state==='offline'){ color('#ef4444'); label('Firebase: OFFLINE'); return; }
      if(state==='ready'){ color('#3b82f6'); label('Firebase: Gotowe'); return; }
      color('#9ca3af'); label('Firebase: ...');
    };
    document.addEventListener('DOMContentLoaded', ()=>{
      ensureStatusBetween();
      window.setSyncStatus(navigator.onLine?'ready':'offline');
      window.addEventListener('online', ()=>window.setSyncStatus('ready'));
      window.addEventListener('offline', ()=>window.setSyncStatus('offline'));
    }, {once:true});
  })();
  </script>


  <script>
  // --- HARDFIX: manual Firebase Wyślij/Pobierz + incognito auth ---
  window.setSyncStatus = window.setSyncStatus || function(){};
  function fbLog(msg, cls){
    // pokaż tylko błędy/ostrzeżenia — brak toastów dla OK
    if (cls!=='err' && cls!=='warn') return;

    try{
      const box = document.getElementById('fbLog'); if(!box) return;
      box.innerHTML = '<b>Firebase</b>: ' + (msg||'') + (cls?('<span class="'+cls+'"></span>'):''); 
      box.classList.add('show');
      clearTimeout(window.__fbLogTimer); window.__fbLogTimer = setTimeout(()=>{ box.classList.remove('show'); }, 6000);
    }catch(_){}
  }

  const FB_CFG = {
    apiKey: "AIzaSyBGFuXxLYQfmyo-TaxJGER2qZ0wzEvPPxk",
    authDomain: "gt-portfolios.firebaseapp.com",
    projectId: "gt-portfolios",
    appId: "1:224230120021:web:87901a167e1fc6079792dc",
    storageBucket: "gt-portfolios.appspot.com",
    messagingSenderId: "224230120021"
  };
  const FB_COL = "gt_portfolios";
  const FB_DOC = "default";

  function detectLSKey(){
  const FIXED = "portfele_firmy_v1"; // stały klucz
  // jeśli już istnieje — użyj
  try{ if(localStorage.getItem(FIXED)) return FIXED; }catch(_){}
  // migracja z innych potencjalnych kluczy
  try{
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      try{
        const v = JSON.parse(localStorage.getItem(k));
        if (v && typeof v==='object' && v.settings && Array.isArray(v.portfolios)) {
          console.log(`Znaleziono dane w kluczu: ${k}, migruję do ${FIXED}`);
          localStorage.setItem(FIXED, JSON.stringify(v));
          return FIXED;
        }
      }catch(_){}
    }
  }catch(_){}
  // jeśli nic nie znaleziono — zwróć stały
  return FIXED;
}
const LS_KEY = detectLSKey();

  async function fbInit(){
    
    // Ensure single initialization per page (singleton)
    if (window.__fbInitPromise) return window.__fbInitPromise;
    window.__fbInitPromise = (async () => {
try{
      if (!window.firebase || !firebase.apps) throw new Error("Brak Firebase SDK");
      if (!firebase.apps.length) firebase.initializeApp(FB_CFG);
      const auth = firebase.auth();
      // diagnostyka stanu auth (zabezpieczone przed wielokrotnym podpięciem)
      try{
        if(!window.__fbAuthBound){
          auth.onAuthStateChanged((user)=>{
            if(user){
              console.log('Firebase auth: zalogowano anonimowo', user.uid);
              if(typeof window.setSyncStatus==='function') window.setSyncStatus('ready');
            }else{
              console.log('Firebase auth: brak użytkownika');
            }
          });
          window.__fbAuthBound = true;
        }
      }catch(_){}
      try{ await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL); }catch(_){}
      if (!auth.currentUser) await auth.signInAnonymously();
      const db = firebase.firestore();
      return {auth, db};
    }catch(e){
      console.warn("fbInit error:", e); alert("Błąd inicjalizacji Firebase: " + (e && e.message || e)); return {};
    }
  
    })();
    return window.__fbInitPromise;
}

  
// === AutoSync Helpers ===

// === Alarm Logging (Firestore) ===
const ALARM_LOG_REPEAT_MS = 15 * 60 * 1000; // re-log same state after 15 minutes
window.__lastLoggedAlerts = window.__lastLoggedAlerts || {};

function __shouldLogAlarm(key, state){
  try{
    const now = Date.now();
    const prev = window.__lastLoggedAlerts[key];
    if(!prev || prev.state !== state || (now - prev.time) > ALARM_LOG_REPEAT_MS){
      window.__lastLoggedAlerts[key] = {state, time: now};
      return true;
    }
    return false;
  }catch(_){ return true; }
}

// Track state changes for badge counting (separate from logging)
window.__lastBadgeStates = window.__lastBadgeStates || {};

function __shouldIncrementBadge(key, state){
  try{
    const prev = window.__lastBadgeStates[key];
    const changed = !prev || prev !== state;
    if(changed){
      window.__lastBadgeStates[key] = state;
      return true;
    }
    return false;
  }catch(_){ return false; }
}



/**
 * Save alarm event to Firestore.
 * data: {scope:'portfolio'|'wishlist', pfId?, ticker, state:'hit'|'near', kind:'sell'|'buy', price, target}
 */
async function logAlarmEvent(data){
  try{
    const pack = Object.assign({}, data||{});
    const {auth, db, firebase} = await fbInit();
    if(!db || !auth || !auth.currentUser){ return; }
    const uid = auth.currentUser.uid;
    pack.uid = uid;
    // Normalize ticker/kind/state
    if(pack.ticker) pack.ticker = String(pack.ticker||'').toUpperCase();
    if(pack.kind)   pack.kind   = String(pack.kind||'').toLowerCase();
    if(pack.state)  pack.state  = String(pack.state||'').toLowerCase();
    // Add createdAt server timestamp if available, else client
    try{
      pack.createdAt = (firebase?.firestore?.FieldValue?.serverTimestamp && firebase.firestore.FieldValue.serverTimestamp()) || new Date();
    }catch(_){
      pack.createdAt = new Date();
    }
    await db.collection('alerts').add(pack);
  }catch(e){
    console.warn('logAlarmEvent failed:', e);
  }
}
const AUTO_SYNC_ENABLED = true;
const AUTO_SYNC_INTERVAL_MS = 8000; // co kilka sekund
const DEVICE_KEY = 'gt_deviceId';
function getDeviceId(){
  try{
    let id = localStorage.getItem(DEVICE_KEY);
    if(!id){ id = 'dev_' + Math.random().toString(36).slice(2,10); localStorage.setItem(DEVICE_KEY, id); }
    return id;
  }catch(_){ return 'dev_unknown'; }
}
function djb2(str){
  let h = 5381, i = str.length;
  while(i) h = (h * 33) ^ str.charCodeAt(--i);
  return (h>>>0).toString(16);
}
window.__dirtySince = null;
window.__lastUploadHash = null;
window.__isSyncing = false;
window.__deviceId = getDeviceId();
window.__markDirty = function(){
  window.__dirtySince = Date.now();
  // opcjonalny log
  try{ fbLog('Zmieniono dane lokalne — auto-sync wkrótce wyśle', 'ok'); }catch(_){}
};
async function hardUpload(){
    const {db} = await fbInit(); if(!db) return false;
    let data=null; try{ data = JSON.parse(localStorage.getItem(LS_KEY)); }catch(_){}
    if (!data){ alert("Brak danych lokalnych do wysłania (klucz: "+LS_KEY+")"); return false; }
    data._ts = Date.now(); data._ver = data.version||1;
    try{
      window.setSyncStatus('syncing');
      await db.collection(FB_COL).doc(FB_DOC).set(data, {merge:false});
    try{ window.__lastUploadHash = djb2(JSON.stringify(data)); }catch(_){}
    window.__dirtySince = null;
      window.__lastSyncAt = Date.now(); window.setSyncStatus('ok');
      return true;
    }catch(e){
      console.warn("UPLOAD error:", e); window.setSyncStatus('error'); alert("Błąd zapisu: " + (e && e.message || e)); return false;
    }
  }

  async function hardDownload(silent=false){
    
    const {db} = await fbInit(); if(!db) return false;
    try{
      window.setSyncStatus('syncing');
      const snap = await db.collection(FB_COL).doc(FB_DOC).get();
      if(!snap.exists){ window.setSyncStatus('error'); if(!silent) alert("Brak dokumentu w chmurze. Najpierw użyj 'Wyślij'."); fbLog('Brak dokumentu '+FB_COL+'/'+FB_DOC, 'err'); return false; }
      const data = snap.data(); if(!data){ window.setSyncStatus('error'); alert("Dokument pusty/niepoprawny."); return false; }
      localStorage.setItem(LS_KEY, JSON.stringify(data));
      
      // aktualizacja aplikacji
      if (typeof window.__setAppDB === 'function') {
        try { window.__setAppDB(data); } catch(e){ console.error('Błąd __setAppDB:', e); }
      } else {
        if (typeof window.save==='function') try{ window.save(); }catch(_){}
        if (typeof window.render==='function') try{ window.render(); }catch(_){}
      }
      if (typeof DB!=='undefined') window.DB = data;
      if (typeof save==='function') try{ save(); }catch(_){}
      if (typeof render==='function') try{ render(); }catch(_){}
      window.__lastSyncAt = Date.now(); window.setSyncStatus('ok');
      /* success alert suppressed */fbLog('Pobrano dane z chmury', 'ok');
      return true;
    }catch(e){
      console.warn("DOWNLOAD error:", e); window.setSyncStatus('error'); alert("Błąd odczytu: " + (e && e.message || e)); fbLog('Błąd odczytu: '+(e&&e.message||e), 'err'); return false;
    }
  }

  
  async function hardDiag(){
  function foldCounts(db){
    const out = { portfolios: 0, companies: 0, positions: 0 };
    try{
      const setTickers = new Set();
      const pfs = Array.isArray(db?.portfolios) ? db.portfolios : [];
      out.portfolios = pfs.length;
      for(const pf of pfs){
        const holdings = pf && pf.holdings ? pf.holdings : {};
        for(const [ticker, h] of Object.entries(holdings)){
          if (ticker) setTickers.add(String(ticker).trim());
          const lots = (h && Array.isArray(h.lots)) ? h.lots.length : 0;
          out.positions += lots;
        }
      }
      out.companies = setTickers.size;
    }catch(_){}
    return out;
  }

  let local = {portfolios:0, companies:0, positions:0};
  try{
    const localData = JSON.parse(localStorage.getItem(LS_KEY)||'null');
    local = foldCounts(localData);
    console.log('Diag lokalnie:', {exists: !!localData, ...local});
  }catch(e){ console.warn('Błąd odczytu lokalnego:', e); }

  const {db} = await fbInit(); if(!db) return false;
  try{
    window.setSyncStatus('syncing');
    await db.collection(FB_COL).doc(FB_DOC).set({_ping: Date.now(), _diag:'test connection'}, {merge:true});
    const snap = await db.collection(FB_COL).doc(FB_DOC).get();
    if(!snap.exists){ fbLog('Diag: zapis ok, odczyt brak dokumentu', 'err'); window.setSyncStatus('error'); return false; }
    const data = snap.data();
    const remote = foldCounts(data);
    const lastTs = data? (data._ts? new Date(data._ts).toLocaleString() : 'brak') : 'brak';

    fbLog('Diag: zapis/odczyt OK', 'ok');
    window.setSyncStatus('ok');

    const msg = `Diagnostyka OK!

Lokalnie (${LS_KEY}):
- Portfeli: ${local.portfolios}
- Spółek (unikalne tickery): ${local.companies}
- Pozycji (lotów): ${local.positions}

W chmurze:
- Portfeli: ${remote.portfolios}
- Spółek (unikalne tickery): ${remote.companies}
- Pozycji (lotów): ${remote.positions}

Ostatni upload: ${lastTs}`;
    alert(msg);
    return true;
  }catch(e){
    fbLog('Diag error: '+(e&&e.message||e), 'err');
    window.setSyncStatus('error');
    alert('Diag error: '+(e&&e.message||e));
    return false;
  }
}

document.addEventListener('DOMContentLoaded', ()=>{
    const up = document.getElementById('firebaseUploadBtn');
    const down = document.getElementById('firebaseDownloadBtn');
    if (up) up.addEventListener('click', hardUpload);
    if (down) down.addEventListener('click', ()=>hardDownload(true));
    const diag = document.getElementById('firebaseDiagBtn'); if (diag) diag.addEventListener('click', hardDiag);
    // auto-silent download on start if doc exists (no alert)
    (async ()=>{
      const {db} = await fbInit(); if(!db) return;
    // === Real-time nasłuch zdalnych zmian ===
    if (db) {
  if (window.__fb_unsub) { try{ window.__fb_unsub(); }catch(_){ } }
  window.__fb_unsub = db.collection(FB_COL).doc(FB_DOC).onSnapshot((snap)=>{
    if (window.__UNDO_RESTORING) { try{console.log('[UNDO] ignore remote during restore');}catch(_){ } return; }

    try{
      if (!snap.exists) return;
      const remote = snap.data();
      if (remote && remote._device && remote._device === getDeviceId()) return; // nasza zmiana
      fbLog('Wykryto zdalną zmianę — auto pobieranie…', 'ok');
      hardDownload(true);
    }catch(e){ console.warn('onSnapshot error', e); }
  });
}
// === Auto PUSH (co kilka sekund) ===
    try{
      function startAutoSync(){
        if (window.__autoSyncTimer) return;
        window.__autoSyncTimer = setInterval(async ()=>{
          try{
            if (!AUTO_SYNC_ENABLED) return;
            if (window.__isSyncing) return;
            if (!navigator.onLine) return;
            const raw = localStorage.getItem(LS_KEY) || '';
            if (!raw) return;
            const h = djb2(raw);
            if (window.__lastUploadHash && window.__lastUploadHash === h && !window.__dirtySince) return;
            window.__isSyncing = true;
          }catch(e){}
          try{
            fbLog('Auto: wysyłam zmiany…', 'ok');
            await hardUpload();
          }catch(e){ console.warn('AutoSync upload error', e); }
          finally {
            window.__isSyncing = false;
          }
        }, AUTO_SYNC_INTERVAL_MS);
      }
      function stopAutoSync(){ if (window.__autoSyncTimer){ clearInterval(window.__autoSyncTimer); window.__autoSyncTimer = null; } }
      // wrap save()
      if (typeof window.save==='function' && !window.__saveWrapped){
        const __origSave = window.save;
        window.save = function(){
          const r = __origSave.apply(this, arguments);
          try{ window.__markDirty(); }catch(_){}
          return r;
        };
        window.__saveWrapped = true;
      }
      // flush on hide/unload
      document.addEventListener('visibilitychange', ()=>{
        if (document.visibilityState==='hidden'){ try{ if (window.__dirtySince) hardUpload(); }catch(_){ } }
      });
      window.addEventListener('beforeunload', ()=>{ try{ if (window.__dirtySince) navigator.sendBeacon && navigator.sendBeacon('/noop'); }catch(_){ } });
      startAutoSync();
    }catch(e){ console.warn('AutoSync init error', e); }

      try{
        const snap = await db.collection(FB_COL).doc(FB_DOC).get();
        if(snap.exists){ await hardDownload(true); }
        else { fbLog('Auto: brak dokumentu do pobrania', 'err'); }
      }catch(e){ fbLog('Auto-load błąd: '+(e&&e.message||e), 'err'); }
    })();
  });
  </script>


  <style>
    #fbLog {
      position: fixed; right: 12px; bottom: 12px; z-index: 9999;
      max-width: 38ch; background: rgba(17,24,39,0.9); color: #eee;
      border-radius: 12px; padding: 10px 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.4);
      font: 12px/1.35 system-ui, Segoe UI, Roboto, Arial, sans-serif;
      display: none;
    }
    #fbLog.show{ display:block; }
    #fbLog b{ color:#93c5fd; }
    #fbLog .err{ color:#fca5a5; }
    #fbLog .ok{ color:#86efac; }
  /* === Daily change arrows === */
.change-arrow{ font-weight: 700; margin-right: 4px; }
.change-arrow.up{ color: var(--ok); }
.change-arrow.down{ color: var(--danger); }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
  <div id="fbLog"></div>


<script>
// Global click delegate for per-lot mute/unmute
document.addEventListener('click', (e)=>{
  const btn = e.target.closest('button.lot-mute');
  if(!btn) return;
  try{
    const DBref = window.DB || {};
    const pfId = DBref.currentPfId || DBref.selectedPfId || (DBref.portfolios && Object.keys(DBref.portfolios)[0]);
    const pf = (DBref.portfolios && pfId) ? DBref.portfolios[pfId] : null;
    if(!pf) return;
    const lotId = btn.getAttribute('data-lot');
    let lot = null;
    for(const [tk, book] of Object.entries(pf.holdings||{})){
      lot = (book.lots||[]).find(x=> x.lotId === lotId);
      if(lot) break;
    }
    if(!lot) return;
    lot.muted = !lot.muted;
    if(typeof save === 'function') save();
    if(typeof render === 'function') render();
  }catch(err){
    console.error("lot-mute toggle error", err);
  }
});</script>


<script>
// === Persist expanded company panels across mute/refresh renders ===
(function(){
  const SS_KEY = 'openDetailsTickers_v2';

  function loadSet(){
    try{ const raw = sessionStorage.getItem(SS_KEY); const arr = raw? JSON.parse(raw): []; return new Set(Array.isArray(arr)? arr: []);}catch(_){ return new Set(); }
  }
  function saveSet(set){
    try{ sessionStorage.setItem(SS_KEY, JSON.stringify(Array.from(set||[]))); }catch(_){}
  }
  window.__openDetailsTickers = window.__openDetailsTickers || loadSet();

  function ensureDataTicker(root){
    const ctx = root || document;
    const nodes = ctx.querySelectorAll('#holdingsTableWrap details:not([data-ticker]) summary');
    nodes.forEach(sum=>{
      try{
        // Take the first text node content as ticker (before any buttons/icons)
        let txt = '';
        for(const n of sum.childNodes){
          if(n.nodeType === Node.TEXT_NODE){
            txt = (n.textContent||'').trim();
            if(txt){ break; }
          }
        }
        if(!txt){
          // fallback: whole text without inner button labels
          txt = (sum.textContent||'').trim().split('\n')[0].trim();
        }
        const details = sum.closest('details');
        if(details && txt) details.dataset.ticker = txt;
      }catch(_){}
    });
  }

  function rememberOpen(){
    try{
      ensureDataTicker();
      const wrap = document.getElementById('holdingsTableWrap');
      if(!wrap) return;
      const opened = Array.from(wrap.querySelectorAll('details[open][data-ticker]')).map(d=>d.dataset.ticker);
      window.__openDetailsTickers = new Set(opened);
      saveSet(window.__openDetailsTickers);
    }catch(_){}
  }

  function restoreOpen(root){
    try{
      ensureDataTicker(root);
      const ctx = root || document;
      const wrap = ctx.getElementById ? ctx : document;
      (wrap.querySelectorAll ? wrap.querySelectorAll('#holdingsTableWrap details[data-ticker]') : []).forEach(d=>{
        const t = d.dataset.ticker;
        if(window.__openDetailsTickers && window.__openDetailsTickers.has(t)) d.setAttribute('open','');
      });
    }catch(_){}
  }

  // Keep set in sync when user toggles any details
  document.addEventListener('toggle', (e)=>{
    const d = e.target && e.target.closest && e.target.closest('#holdingsTableWrap details[data-ticker]');
    if(!d) return;
    const t = d.dataset.ticker;
    if(!t) return;
    if(!window.__openDetailsTickers) window.__openDetailsTickers = new Set();
    if(d.open) window.__openDetailsTickers.add(t); else window.__openDetailsTickers.delete(t);
    saveSet(window.__openDetailsTickers);
  }, true);

  // Before any click that might re-render, snapshot the state (capture phase)
  document.addEventListener('click', ()=>{ try{ rememberOpen(); }catch(_){} }, true);

  // Observe DOM mutations and re-open after changes
  const mo = new MutationObserver((list)=>{
    let need = false;
    for(const m of list){
      if(m.addedNodes && m.addedNodes.length){
        need = true; break;
      }
      if(m.type === 'childList') { need = true; break; }
    }
    if(need){
      // slight delay to allow innerHTML to settle
      setTimeout(()=>restoreOpen(), 0);
    }
  });
  mo.observe(document.documentElement, {subtree:true, childList:true});

  // Wrap all known render* functions
  function wrapRenders(){
    const names = ['render','renderMain','renderLots','renderPortfolioList','renderWishlist'];
    names.forEach(n=>{
      try{
        const fn = window[n];
        if(typeof fn === 'function' && !fn.__patchedKeepOpen){
          const wrapped = function(){
            rememberOpen();
            const res = fn.apply(this, arguments);
            setTimeout(()=>restoreOpen(), 0);
            return res;
          };
          wrapped.__patchedKeepOpen = true;
          window[n] = wrapped;
        }
      }catch(_){}
    });
  }

  // Initial restore after first paint
  window.addEventListener('DOMContentLoaded', ()=>{ setTimeout(()=>{ wrapRenders(); restoreOpen(); }, 0); });
  // Also try soon in case scripts define renders later
  setTimeout(wrapRenders, 0);
  setTimeout(restoreOpen, 50);
})();

// === API last refresh clock ===
window.setApiTime = function(ts){
  try{
    if(typeof ensureStatusBetween === 'function') ensureStatusBetween();
    const wrap = document.getElementById('syncStatusWrap');
    if(!wrap) return;
    let el = document.getElementById('apiTime');
    if(!el){
      el = document.createElement('span');
      el.id = 'apiTime';
      el.style.marginLeft = '6px';
      el.className = 'muted';
      wrap.appendChild(el);
    }
    function pad(n){ return (n<10?'0':'')+n; }
    const d = new Date(ts || (window.__lastApiRefreshAt||Date.now()));
    el.textContent = '• API: ' + pad(d.getHours())+':'+pad(d.getMinutes())+':'+pad(d.getSeconds());
  }catch(_){}
};

</script>

<script>
// === Toasts & Unread badge ===
(function(){
  function ensureWrap(){ return document.getElementById('toastsWrap'); }
  window.showToast = function({ticker, state, kind}){
    try{
  const wrap = (typeof ensureWrap==='function') ? ensureWrap() : null;
  if(wrap){
    const el = document.createElement('div');
    el.className = 'toast ' + (state||'');
    const label = state==='hit' ? '🎯 Cel osiągnięty' : (state==='near' ? '⏳ Blisko celu' : '🔔 Alarm');
    el.innerHTML = `<strong>${label}</strong> • ${ticker ? (ticker.toUpperCase?.()||ticker) : '—'} • ${kind ? kind.toUpperCase?.() : '—'} <span class="time">${new Date().toLocaleTimeString()}</span>`;
    wrap.appendChild(el);
    setTimeout(()=>{ try{ el.remove(); }catch(_){ } }, 6000);
  }
  // bump unread regardless of toast container availability
  try{
    const k='alerts_unread_count';
    const curr = Number(localStorage.getItem(k)||0) || 0;
    const val = Math.min(curr+1, 999);
    localStorage.setItem(k, String(val));
    if(typeof updateAlertsBadge==='function') updateAlertsBadge();
  }catch(_){}
}catch(_){}

  };
  window.updateAlertsBadge = function(){
    try{
      const el = document.getElementById('alertsTabBtn');
      if(!el) return;
      const k='alerts_unread_count';
      const n = Number(localStorage.getItem(k)||0) || 0;
      let b = el.querySelector('.badge');
      if(n>0){
        if(!b){ b = document.createElement('span'); b.className='badge'; el.appendChild(b); }
        b.textContent = String(n);
      }else if(b){ b.remove(); }
    }catch(_){}
  };
  window.resetAlertsUnread = function(){
    try{ localStorage.setItem('alerts_unread_count', '0'); updateAlertsBadge(); }catch(_){}
  };
  document.addEventListener('DOMContentLoaded', updateAlertsBadge);
})();
</script>


<script>
(function(){
  function __fallbackSetActive(v){
    try{
      const main = document.querySelector('.main') || document.querySelector('main');
      if(!main) return;
      const panels = main.querySelectorAll(':scope > section');
      panels.forEach(sec=>{
        if(v==='wishlist') sec.style.display = (sec.id==='wishlistPanel') ? '' : 'none';
        else if(v==='alerts') sec.style.display = (sec.id==='alertsPanel') ? '' : 'none';
        else sec.style.display = (sec.id==='wishlistPanel' || sec.id==='alertsPanel') ? 'none' : '';
      });
      const btnW = document.getElementById('wishlistTabBtn');
      if(btnW){ btnW.classList.toggle('secondary', v!=='wishlist'); }
      const btnA = document.getElementById('alertsTabBtn');
      if(btnA){ btnA.classList.toggle('secondary', v!=='alerts'); }
      const btnP = document.getElementById('portfoliosTabBtn');
      if(btnP){ btnP.classList.toggle('secondary', !(v!=='wishlist' && v!=='alerts')); } // primary when main
    }catch(_){}
  }
  const navSet = (window.setActiveView || __fallbackSetActive);
  try{
    const btnP = document.getElementById('portfoliosTabBtn');
    if(btnP){ btnP.addEventListener('click', ()=>{ navSet('main'); }); }
    const btnA = document.getElementById('alertsTabBtn');
    if(btnA){ btnA.addEventListener('click', ()=>{ navSet('alerts'); window.resetAlertsUnread && window.resetAlertsUnread(); try{ ackCurrentAlerts(); updateSidebarBlinkStates && updateSidebarBlinkStates(); }catch(_){ } window.renderAlerts && window.renderAlerts(); }); }
    const btnW = document.getElementById('wishlistTabBtn');
    if(btnW){ btnW.addEventListener('click', ()=>{ navSet('wishlist'); }); }
  }catch(_){}
})();
</script>


<script>
(function(){
  async function jumpToTicker(ticker){
    try{
      ticker = (ticker||'').toUpperCase();
      if(!ticker) return;
      // pick first portfolio that contains this ticker
      let pfId = null;
      try{
        for(const pf of (window.DB?.portfolios||[])){
          if(pf && pf.holdings && Object.prototype.hasOwnProperty.call(pf.holdings, ticker)){
            pfId = pf.id || pf.name || null;
            break;
          }
        }
      }catch(_){}
      // switch view to main
      const navSet = (window.setActiveView || function(v){ 
        const main = document.querySelector('.main') || document.querySelector('main');
        if(!main) return;
        const panels = main.querySelectorAll(':scope > section');
        panels.forEach(sec=>{
          if(v==='wishlist') sec.style.display = (sec.id==='wishlistPanel') ? '' : 'none';
          else if(v==='alerts') sec.style.display = (sec.id==='alertsPanel') ? '' : 'none';
          else sec.style.display = (sec.id==='wishlistPanel' || sec.id==='alertsPanel') ? 'none' : '';
        });
      });
      navSet('main');
      // optionally select portfolio if app exposes API
      try{
        if(pfId && typeof window.setCurrentPortfolioId==='function'){
          await window.setCurrentPortfolioId(pfId);
        }
      }catch(_){}
      // ensure render
      try{ if(typeof window.render==='function') window.render(); else if(typeof window.renderMain==='function') window.renderMain(); }catch(_){}
      // scroll to row containing ticker
      setTimeout(()=>{
        try{
          const candidates = Array.from(document.querySelectorAll('td.ticker'));
          const cell = candidates.find(td => (td.textContent||'').toUpperCase().includes(ticker));
          if(cell){
            cell.scrollIntoView({behavior:'smooth', block:'center'});
            cell.classList.add('highlight');
            setTimeout(()=>{ try{ cell.classList.remove('highlight'); }catch(_){} }, 2000);
          }
        }catch(_){}
      }, 50);
    }catch(_){}
  }
  // simple highlight style
  try{
    const css = document.createElement('style');
    css.textContent = '.highlight{outline:3px solid #f59e0b; border-radius:6px; transition: outline-color .3s}';
    document.head.appendChild(css);
  }catch(_){}
  // event delegation
  document.addEventListener('click', (e)=>{
    const a = e.target.closest('a.alert-ticker');
    if(a){
      e.preventDefault();
      const t = a.getAttribute('data-ticker');
      jumpToTicker(t);
    }
  });
  // expose for debugging
  window.jumpToTicker = jumpToTicker;
})();
</script>

<script>
// === Alerts panel logic ===
// (local helpers for Alerts panel to avoid global deps)
const __esc = (s)=>{
  try{
    if (typeof window.escapeHtml === 'function') return window.escapeHtml(String(s||''));
  }catch(_){}
  const t = document.createElement('textarea');
  t.textContent = String(s||'');
  return t.innerHTML;
};
const __fmtNum = (v)=>{
  try{
    if (typeof window.fmtNum === 'function') return window.fmtNum(v);
  }catch(_){}
  const n = Number(v);
  if (!isFinite(n)) return '—';
  return n.toLocaleString(undefined, {maximumFractionDigits: 2});
};


async function fetchAlertsPage({limit=100, startAfter=null}={}){
  const empty = {items:[], lastDoc:null};
  try{
    const {auth, db} = await fbInit(); if(!db || !auth || !auth.currentUser) return empty;
    const uid = auth.currentUser.uid;
    let qBase = db.collection('alerts').where('uid','==', uid);
    let q = qBase.orderBy('createdAt','desc');
    if(limit) q = q.limit(limit);
    if(startAfter) q = q.startAfter(startAfter);
    try{
      const snap = await q.get();
      const out = []; let lastDoc = null;
      snap.forEach(doc=>{
        const d = doc.data() || {};
        const createdAt = (d.createdAt && d.createdAt.toDate) ? d.createdAt.toDate() : (d.createdAtClient ? new Date(d.createdAtClient) : null);
        out.push({
          id: doc.id,
          ticker: (d.ticker||'').toUpperCase(),
          state: d.state||'',
          kind: d.kind||'',
          price: (d.price!=null? Number(d.price): null),
          target: (d.target!=null? Number(d.target): null),
          scope: d.scope||'',
          pfId: d.pfId||'',
          createdAt
        });
        lastDoc = doc;
      });
      return {items: out, lastDoc};
    }catch(e){
      const msg = (e && (e.message||e.toString())) || '';
      if(msg.includes('requires an index')){
        console.info('Alerts: falling back to client-side sort (no composite index yet).');
        let q2 = qBase;
        if(limit) q2 = q2.limit(limit * 5);
        const snap2 = await q2.get();
        const items = [];
        snap2.forEach(doc=>{
          const d = doc.data() || {};
          const createdAt = (d.createdAt && d.createdAt.toDate) ? d.createdAt.toDate() : (d.createdAtClient ? new Date(d.createdAtClient) : null);
          items.push({
            id: doc.id,
            ticker: (d.ticker||'').toUpperCase(),
            state: d.state||'',
            kind: d.kind||'',
            price: (d.price!=null? Number(d.price): null),
            target: (d.target!=null? Number(d.target): null),
            scope: d.scope||'',
            pfId: d.pfId||'',
            createdAt
          });
        });
        items.sort((a,b)=> (b.createdAt?.getTime()||0) - (a.createdAt?.getTime()||0));
        return {items: items.slice(0, limit||items.length), lastDoc: null};
      }else{
        console.warn('fetchAlertsPage failed', e);
        return empty;
      }
    }
  }catch(e){
    console.warn('fetchAlertsPage failed', e);
    return empty;
  }
}

function fmtDateTime(dt){
  try{
    if(!dt) return '—';
    const pad = n=> (n<10?'0':'')+n;
    return dt.getFullYear()+'-'+pad(dt.getMonth()+1)+'-'+pad(dt.getDate())+' '+pad(dt.getHours())+':'+pad(dt.getMinutes())+':'+pad(dt.getSeconds());
  }catch(_){ return '—'; }
}

async function renderAlerts(){
  const body = document.getElementById('alertsTableBody');
  const stats = document.getElementById('alertsStats');
  if(!body) return;
  body.innerHTML = `<tr><td colspan="7" class="muted">Ładowanie…</td></tr>`;
  const res = await fetchAlertsPage({limit:200});
  let rows = res.items;

  // Filters
  const fScope = document.getElementById('alertsScope')?.value || '';
  const fState = document.getElementById('alertsState')?.value || '';
  const fKind  = document.getElementById('alertsKind')?.value  || '';
  rows = rows.filter(r=> (!fScope || r.scope===fScope) && (!fState || r.state===fState) && (!fKind || r.kind===fKind));

  // Stats
  const total = rows.length;
  const hits = rows.filter(r=> r.state==='hit').length;
  const nears = rows.filter(r=> r.state==='near').length;
  if(stats) stats.textContent = `Wpisów: ${total} — 🎯 hit: ${hits}, ⏳ near: ${nears}`;

  // Render
  if(!rows.length){
    body.innerHTML = `<tr><td colspan="7" class="muted">Brak alarmów do wyświetlenia.</td></tr>`;
    return;
  }
  body.innerHTML = rows.map(r=>{
    const stateTxt = r.state==='hit' ? '🎯 cel osiągnięty' : (r.state==='near' ? '⏳ blisko celu' : r.state);
    const kindTxt = r.kind ? r.kind.toUpperCase() : '—';
    const scopeTxt = r.scope==='wishlist' ? 'Wishlist' : (r.scope==='portfolio' ? 'Portfel' : '—');
    return `<tr class="${r.state==='hit'?(r.kind==='sell'?'hit-target-sell':'hit-target-buy'):(r.state==='near'?(r.kind==='sell'?'near-target-sell':'near-target-buy'):'')}">
      <td>${fmtDateTime(r.createdAt)}</td>
      <td><a href=\"#\" class=\"alert-ticker\" data-ticker=\"${__esc(r.ticker||'')}\">${__esc(r.ticker||'')}</a></td>
      <td>${stateTxt}</td>
      <td>${kindTxt}</td>
      <td>${r.price!=null? __fmtNum(r.price) : '—'}</td>
      <td>${r.target!=null? __fmtNum(r.target) : '—'}</td>
      <td>${scopeTxt}</td>
    </tr>`;
  }).join('');
}


(function wireAlertsUI(){
  try{
    const clr = document.getElementById('alertsClearBtn');
    if(clr){
      clr.addEventListener('click', async ()=>{
        try{
          clr.disabled = true;
          const old = clr.textContent;
          clr.textContent = 'Kasuję…';
          await clearAlertsHistory();
          clr.textContent = old;
        }finally{
          clr.disabled = false;
        }
      });
    }
  }catch(_){}

  try{
    function __fallbackSetActive(v){
      try{
        const main = document.querySelector('.main') || document.querySelector('main');
        if(!main) return;
        const panels = main.querySelectorAll(':scope > section');
        panels.forEach(sec=>{
          if(v==='wishlist') sec.style.display = (sec.id==='wishlistPanel') ? '' : 'none';
          else if(v==='alerts') sec.style.display = (sec.id==='alertsPanel') ? '' : 'none';
          else sec.style.display = (sec.id==='wishlistPanel' || sec.id==='alertsPanel') ? 'none' : '';
        });
        const btnW = document.getElementById('wishlistTabBtn');
        if(btnW){ btnW.classList.toggle('secondary', v!=='wishlist'); }
        const btnA = document.getElementById('alertsTabBtn');
        if(btnA){ btnA.classList.toggle('secondary', v!=='alerts'); }
      }catch(_){}
    }
    const navSet = (window.setActiveView || __fallbackSetActive);

    const btn = document.getElementById('alertsTabBtn');
    if(btn){
      btn.addEventListener('click', ()=>{ navSet('alerts'); renderAlerts(); try{ localStorage.setItem('alerts_unread_count','0'); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); }catch(_){} });
    }
    const ref = document.getElementById('alertsRefreshBtn');
    if(ref){
      ref.addEventListener('click', ()=> renderAlerts());
    }
    ['alertsScope','alertsState','alertsKind'].forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.addEventListener('change', ()=> renderAlerts());
    });
  }catch(_){}
})();
</script>

<script>
try{
  window.addEventListener('storage', function(e){
    try{
      if(e && e.key === 'alerts_unread_count'){
        if(typeof updateAlertsBadge === 'function') updateAlertsBadge();
      }
    }catch(_){}
  });
  document.addEventListener('visibilitychange', function(){
    try{
      if(document.visibilityState === 'visible' && typeof updateAlertsBadge === 'function') updateAlertsBadge();
    }catch(_){}
  });
}catch(_){}
</script>


<script>
/* === Global Alarm Scanner (runs on price updates) === */
try{
  window.__lastGlobalAlarmScanAt = window.__lastGlobalAlarmScanAt || 0;
  const SCAN_MIN_INTERVAL_MS = 1000; // throttle to avoid heavy loops each tick

  window.scanAlarmsGlobal = function(){
    try{
      const now = Date.now();
      if((now - window.__lastGlobalAlarmScanAt) < SCAN_MIN_INTERVAL_MS) return;
      window.__lastGlobalAlarmScanAt = now;

      const tol = (Number(DB?.settings?.approachTolerancePct)||1)/100;

      // --- Portfolio holdings ---
      try{
        const pfs = Array.isArray(DB?.portfolios) ? DB.portfolios : [];
        for(const pf of pfs){
          const holdings = pf?.holdings || {};
          for(const [ticker, book] of Object.entries(holdings)){
            const lots = Array.isArray(book?.lots) ? book.lots : [];
            for(const lot of lots){
              try{
                lot._ticker = ticker;
                if(lot && lot.muted) continue;
                const st = (typeof targetStatus==='function') ? targetStatus(lot) : {state:'none'};
                if(st.state==='hit' || st.state==='near'){
                  const kind = st.kind || (st.state==='hit' ? 'sell' : 'buy');
                  const price = getQuote(ticker);
                  const target = (kind==='sell') 
                                  ? (typeof computeTargetPrice==='function' ? computeTargetPrice(lot) : null)
                                  : (typeof computeBuyTargetPrice==='function' ? computeBuyTargetPrice(lot) : null);
                  if(price!=null && target!=null){
                    const key = ['pf', pf?.id || 'default', ticker, kind].join('|');
                    if(typeof __shouldLogAlarm==='function' ? __shouldLogAlarm(key, st.state) : true){
                      try{ if(window.showToast) showToast({ticker, state:st.state, kind}); }catch(_){}
                      try{ logAlarmEvent({scope:'portfolio', pfId:(pf&&pf.id)||'', ticker, state:st.state, kind, price, target}); }catch(_){}
                    }
                  }
                }
              }catch(_){}
            }
          }
        }
      }catch(_){}

      // --- Wishlist (buy targets only) ---
      try{
        const wl = Array.isArray(DB?.watchlist) ? DB.watchlist : [];
        for(const w of wl){
          try{
            const t = (w?.ticker||'').toUpperCase();
            const price = getQuote(t);
            const targets = Array.isArray(w?.targets) ? (w.targets || []).map(Number).filter(x=>x>0)
                           : ((Number(w?.price)||0) ? [Number(w.price)] : []);
            const ai = Math.min(Math.max(Number(w?.activeIndex)||0, 0), Math.max(targets.length-1,0));
            const desired = targets.length ? Number(targets[ai])||0 : 0;
            if(price!=null && desired>0){
              let state = null;
              if(price <= desired){ state = 'hit'; }
              else if(price <= desired*(1+tol)){ state = 'near'; }
              if(state){
                const key = ['wl', w?.id || t, 'buy'].join('|');
                if(typeof __shouldLogAlarm==='function' ? __shouldLogAlarm(key, state) : true){
                  try{ if(window.showToast) showToast({ticker:t, state, kind:'buy'}); }catch(_){}
                  try{ logAlarmEvent({scope:'wishlist', ticker:t, state, kind:'buy', price, target:desired}); }catch(_){}
                }
              }
            }
          }catch(_){}
        }
      }catch(_){}
    }catch(_){}
  };

  // Helper that can be called from setQuote
  window.maybeScanAlarmsGlobal = function(){
    try{ window.scanAlarmsGlobal && window.scanAlarmsGlobal(); }catch(_){}
  };
}catch(_){}
</script>


<script>
// === Clear Alerts History ===
async function clearAlertsHistory(){
  try{
    const go = (typeof window.confirm==='function') ? window.confirm('Skasować historię alarmów? Operację można cofnąć przez 2 dni (↩️ Cofnij)..') : true;
    if(!go) return;
    const ctx = await fbInit();
    const {auth, db} = ctx || {};
    if(!db || !auth || !auth.currentUser){ throw new Error('no-auth'); }
    const uid = auth.currentUser.uid;
    const q = db.collection('alerts').where('uid','==', uid);
    const snap = await q.get();
    if(snap && !snap.empty){
      let batch = db.batch();
      let i = 0, commits = [];
      snap.forEach(doc=>{
        batch.delete(doc.ref);
        i++;
        if(i % 400 === 0){
          commits.push(batch.commit());
          batch = db.batch();
        }
      });
      commits.push(batch.commit());
      await Promise.all(commits);
    }
    // success path
    try{ window.__lastLoggedAlerts = {}; }catch(_){}
    try{ const k='alerts_unread_count'; localStorage.setItem(k,'0'); if(typeof updateAlertsBadge==='function') updateAlertsBadge(); }catch(_){}
    // Refresh list
    return renderAlerts();
  }catch(e){
    // Fallback: local clear (hide all alerts locally)
    try{
      const ts = Date.now();
      localStorage.setItem('alerts_hidden_all_until', String(ts));
      window.__lastLoggedAlerts = {};
      const k='alerts_unread_count';
      localStorage.setItem(k,'0');
      if(typeof updateAlertsBadge==='function') updateAlertsBadge();
      if(typeof renderAlerts==='function') renderAlerts();
      console.warn('clearAlertsHistory: using local fallback due to', e && (e.code || e.message || e.toString()));
      alert('Brak uprawnień do kasowania w Firestore — wyczyszczono lokalnie (widok).');
      return;
    }catch(_){}
  }
}
</script>


<!-- ALLOW_RULES_ALERTS_SNIPPET
Suggested Firestore rules for alerts collection (replace with your setup):
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /alerts/{alertId} {
      allow read: if request.auth != null && resource.data.uid == request.auth.uid;
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.uid == request.auth.uid;
    }
  }
}
-->


<!-- === [GT ADDON] Global Overview Tab (Osobna Zakładka) === -->
<style>
  /* Namespaced styles to avoid collisions */
  #go-tab-overlay[hidden]{ display:none !important }
  #go-tab-overlay{
    position:fixed; inset:0; z-index:9999;
    background: radial-gradient(1200px 600px at 10% -10%, rgba(34,211,238,.06), transparent 40%),
                radial-gradient(1200px 600px at 110% 110%, rgba(16,185,129,.06), transparent 40%),
                linear-gradient(120deg,#0b1222 0%,#0f172a 40%, #101525 100%);
    color:#e5e7eb; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Noto Sans, Ubuntu, Cantarell, Arial;
  }
  #go-tab-header{
    display:flex; align-items:center; gap:10px; justify-content:space-between;
    padding:12px 14px; border-bottom:1px solid #1f2937;
    background: linear-gradient(0deg, rgba(15,23,42,.75), rgba(15,23,42,.75));
    backdrop-filter: blur(8px);
  }
  #go-tab-main{ padding:14px; display:flex; flex-direction:column; gap:14px; height: calc(100% - 60px); overflow:auto }
  #go-fab{
    position:fixed; right:16px; bottom:16px; z-index:9998;
    border:none; border-radius:14px; padding:12px 14px; cursor:pointer; font-weight:800;
    background:#22d3ee; color:#001018; box-shadow:0 12px 25px rgba(34,211,238,.35);
  }
  #go-fab:hover{ transform: translateY(-1px); filter: brightness(1.05) }
  #go-close{ border:none; border-radius:10px; padding:8px 10px; cursor:pointer; font-weight:800; background:#334155; color:#e5e7eb }
  #go-close:hover{ filter:brightness(1.1) }
  /* Cards, tables, etc. (scoped) */
  #go-tab-overlay .go-card{ background:linear-gradient(180deg, rgba(17,24,39,.92), rgba(16,23,42,.98)); border:1px solid #1f2937; border-radius:16px }
  #go-tab-overlay .go-panel{ padding:14px }
  #go-tab-overlay .go-grid{ display:grid; grid-template-columns: repeat(12, 1fr); gap:14px }
  #go-tab-overlay .go-col-3{ grid-column: span 3 } .go-col-4{ grid-column: span 4 } .go-col-6{ grid-column: span 6 } .go-col-8{ grid-column: span 8 } .go-col-12{ grid-column: span 12 }
  @media (max-width: 980px){ #go-tab-overlay .go-col-3, #go-tab-overlay .go-col-4, #go-tab-overlay .go-col-6, #go-tab-overlay .go-col-8{ grid-column: span 12 } }
  #go-tab-overlay table{ width:100%; border-collapse:collapse }
  #go-tab-overlay th, #go-tab-overlay td{ padding:10px; border-bottom:1px solid #1f2937; text-align:left; vertical-align: top }
  #go-tab-overlay th{ color:#cbd5e1; background:#0b1222; position:sticky; top:0 }
  #go-tab-overlay .go-ticker{ font-family: ui-monospace, Menlo, Consolas, "Courier New", monospace; letter-spacing:.3px; font-weight:700 }
  #go-tab-overlay input, #go-tab-overlay select{
    width:100%; padding:10px 12px; border-radius:12px; border:1px solid #334155;
    background:#0b1222; color:#e5e7eb; outline:none; font-size:14px
  }
  #go-tab-overlay .go-chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#0b1222; border:1px solid #1f2937; font-weight:700 }
  #go-tab-overlay .go-tag{ padding:3px 8px; border-radius:999px; border:1px solid #334155; color:#cbd5e1; font-size:12px; background:#0c1426 }
  #go-tab-overlay .go-stat{ display:flex; align-items:flex-start; justify-content:space-between; gap:8px; padding:12px; border-radius:14px; background:#0b1222; border:1px solid #1f2937 }
  #go-tab-overlay .go-big{ font-size:22px; font-weight:900 }
  #go-tab-overlay .go-muted{ color:#94a3b8 }
  #go-tab-overlay .go-badge{ font-weight:800; padding:2px 6px; border-radius:8px; background: rgba(255,255,255,.04); display:inline-block; min-width:62px; text-align:right }
  #go-tab-overlay .go-pos{ color:#10b981 } .go-neg{ color:#ef4444 }
  #go-tab-overlay .go-mini{ font-size:12px }
  #go-tab-overlay .go-switch{ display:flex; align-items:center; gap:8px }

  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>
<style>
  /* Details row in Positions (aggregation) */
  #go-tab-overlay .go-detail-row td { padding: 0; }
  #go-tab-overlay .go-detail-row .table-wrap { margin: 6px 0; }


  .banner.warn{
    background: #2b1f1f; color: #ffd7d7; border: 1px solid #6b2a2a;
    padding: 8px 12px; border-radius: 10px; margin: 8px 0;
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }

</style>

<button id="go-fab" title="Globalny Przegląd – osobna zakładka">📈 Przegląd</button>

<section id="go-tab-overlay" hidden>
  <div id="go-tab-header">
    <h3 style="margin:0;font-size:18px">📈 Globalny Przegląd Majątku </h3>
    <div style="display:flex;gap:8px;align-items:center">


      <span class="go-switch go-mini"><input type="checkbox" id="go-no-api"> <label for="go-no-api">Bez API (tylko istniejące ceny)</label></span>
      <button id="go-refresh" title="Odśwież">🔄</button>
      <button id="go-export-csv" title="Eksport CSV">⬇️ CSV</button>
      <button id="go-export-json" title="Eksport JSON">⬇️ JSON</button>
      <button id="go-close">✖ Zamknij</button>
    </div>
  </div>


  <div id="go-tab-main">
    <section class="go-card go-panel">
      <div class="go-grid" style="align-items:end">
        <div class="go-col-4">
          <label>Waluta bazowa</label>
          <select id="go-base">
            <option value="PLN">PLN</option>
            <option value="USD">USD</option>
            <option value="EUR">EUR</option>
          </select>
          <div class="go-muted go-mini">Sumy przeliczane bieżącym FX.</div>
        </div>
        <div class="go-col-4">
          <label>Token Finnhub</label>
          <input id="go-token" placeholder="np. d0b..." />
          <div class="go-muted go-mini">Jeśli puste — spróbuję z Ustawień.</div>
        </div>
        <div class="go-col-4">
          <label>Odświeżanie (sek.)</label>
          <input id="go-poll" type="number" min="5" step="1" value="45" />
        </div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
        <div class="go-chip">💱 FX: <span id="go-fx" style="font-family:ui-monospace">—</span></div>
<div class="go-chip">✏️ USD→PLN: <input id="go-fx-usdpln" type="number" min="0" step="0.0001" style="width:110px"> <button id="go-fx-apply" class="go-mini" title="Ustaw kurs ręcznie">Ustaw</button> <button id="go-fx-clear" class="go-mini" title="Wyczyść ręczny kurs">Wyczyść</button></div>
<script id="go-fx-storage">
(function(){
  const KEY = 'gt_fx_usd_pln';
  function toNum(v){
    if (v===undefined || v===null) return NaN;
    const s = String(v).replace(',', '.').trim();
    return Number(s);
  }
  function readSaved(){
    try{
      const v = localStorage.getItem(KEY);
      const n = toNum(v);
      return (Number.isFinite(n) && n>0) ? n : null;
    }catch(_){ return null; }
  }
  function save(val){
    try{
      const n = toNum(val);
      if (!Number.isFinite(n) || n<=0){ localStorage.removeItem(KEY); return null; }
      localStorage.setItem(KEY, String(n));
      return n;
    }catch(_){ return null; }
  }
  function clearSaved(){
    try{ localStorage.removeItem(KEY); }catch(_){}
  }

  function bind(){
    const root = document.getElementById('go-tab-overlay');
    if(!root) return;
    const input = root.querySelector('#go-fx-usdpln');
    const btnApply = root.querySelector('#go-fx-apply');
    const btnClear = root.querySelector('#go-fx-clear');
    if(!input) return;

    const saved = readSaved();
    if(saved){ input.value = saved; }

    if(btnApply){
      btnApply.addEventListener('click', function(){ save(input.value); }, {passive:true});
    }
    input.addEventListener('keydown', function(ev){
      if(ev.key==='Enter'){
        save(input.value);
        if(btnApply){ try{ btnApply.click(); }catch(_){ } }
      }
    });
    if(btnClear){
      btnClear.addEventListener('click', function(){ clearSaved(); }, {passive:true});
    }
    input.addEventListener('blur', function(){ save(input.value); });
  }

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', bind);
  }else{
    bind();
  }
})();
</script>

        <div class="go-chip">🧾 Źródła: Finnhub Quote, Frankfurter (ECB) / exchangerate.host</div>
        <div class="go-chip">🧊 Cache TTL: <span id="go-ttl" class="go-mini">60s</span></div>
        <div style="flex:1"></div>
        <button id="go-save" style="border:none;border-radius:12px;padding:10px 14px;font-weight:800;background:#22d3ee;color:#001018">💾 Zapisz</button>
      </div>
    </section>

    <section class="go-card go-panel">
      <h4 style="margin:0 0 8px 0">🔎 Szybkie statystyki (waluta bazowa)</h4>
      <div class="go-grid">
        <div class="go-col-3"><div class="go-stat"><div><div class="go-muted">Wartość akcji</div><div id="go-tot-hold" class="go-big">—</div></div><span class="go-tag">live</span></div></div>
        <div class="go-col-3"><div class="go-stat"><div><div class="go-muted">Gotówka</div><div id="go-tot-cash" class="go-big">—</div></div><span class="go-tag">suma</span></div></div>
        <div class="go-col-3"><div class="go-stat"><div><div class="go-muted">Suma majątku</div><div id="go-tot-eq" class="go-big">—</div></div><span class="go-tag">akcje+cash</span></div></div>
        <div class="go-col-3"><div class="go-stat"><div><div class="go-muted">Niezreal. P/L</div><div class="go-big"><span id="go-tot-unr">—</span> <span id="go-tot-unr-pct" class="go-badge">—</span></div><div class="go-muted go-mini">vs koszt własny</div></div><span id="go-day" class="go-tag">Δ dzienny: —</span></div></div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:6px">
        <div class="go-chip">💰 Zreal. P/L (brutto): <span id="go-real-g" style="font-family:ui-monospace">—</span></div>
        <div class="go-chip">🧾 Podatek: <span id="go-real-tax" style="font-family:ui-monospace">—</span></div>
        <div class="go-chip">🏁 Zreal. P/L (netto): <span id="go-real-n" style="font-family:ui-monospace">—</span></div>
        <div class="go-chip">⏱️ Śr. czas (zamknięte): <span id="go-avg-hold" style="font-family:ui-monospace">—</span></div>
        
        <div class="go-chip">📈 Śr. zysk % / pozycję (brutto): <span id="go-avg-pct" style="font-family:ui-monospace">—</span></div>

    
        <div class="go-chip">🎯 TP: <span id="go-tp-count">—</span></div><div class="go-chip"><label for="go-period" class="go-chip-label">📅 Okres</label> <select id="go-period" style="width:auto"><option value="day">Dzień</option><option value="week">Tydzień</option><option value="month">Miesiąc</option><option value="ytd">Ten rok</option><option value="1y">Rok</option><option value="2y">2 lata</option><option value="3y">3 lata</option><option value="all">Cały okres</option></select></div>
        
</section>

<!-- 🧭 [GO] Wkład vs Wartość — wykres liniowy -->
<style>
  /* Minimal styles for the GO line chart */
  #go-line-chart-card{ margin-top: 12px; }
  .go-legend{ display:flex; gap:16px; align-items:center; margin:6px 0 10px 0; flex-wrap:wrap; }
  .go-legend .dot{ width:12px; height:12px; border-radius:999px; display:inline-block; vertical-align:middle; margin-right:6px; }
  .go-legend .blue{ background:#3b82f6; }
  .go-legend .green{ background:#22c55e; }
  .go-legend .muted{ opacity:0.65; font-size:12px; }
  .go-chart-wrap{ width:100%; height:260px; position:relative; border:1px solid #1f2937; border-radius:10px; overflow:hidden; }
  #go-line-chart{ width:100%; height:100%; display:block; }
  #go-chart-empty{ padding:12px; font-size:13px; opacity:0.8; }
  .go-chart-tooltip{
    position:absolute; pointer-events:none; background:#0b1220; border:1px solid #1f2937;
    padding:6px 8px; border-radius:8px; font-size:12px; white-space:nowrap;
    transform:translate(-50%, -120%);
  }
  .go-gridline{ opacity:0.15; }
</style>
<section class="go-card go-panel" id="go-line-chart-card">
  <h4 style="margin:0 0 8px 0">📈 Wkład własny vs wartość (zakres czasu jak w filtrze)</h4>
  <div class="go-legend">
    <span><span class="dot blue"></span>Wkład własny (wpłaty − wypłaty)</span>
    <span><span class="dot green"></span>Wartość majątku (akcje + gotówka, wg bieżących cen)</span>
    <span class="muted">* brak historii cen — linia wartości zmienia się przy transakcjach/zastrzykach gotówki</span>
  </div>
  <div id="go-line-chart-info" class="muted" style="margin-bottom:6px">
    <span id="go-info-blue"></span> • <span id="go-info-green"></span>
  </div>
  <div class="go-chart-wrap">
    <canvas id="go-line-chart"></canvas>
    <canvas id="go-line-chart-overlay"></canvas>

    <div class="chart-tooltip-improved" id="go-chart-tooltip-imp">
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">Data:</span><span class="tooltip-value-improved" id="tt-date-imp">-</span></div>
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">Wkład własny:</span><span class="tooltip-value-improved" id="tt-invested-imp">-</span></div>
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">Wartość portfela:</span><span class="tooltip-value-improved" id="tt-value-imp">-</span></div>
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">Zysk/Strata:</span><span class="tooltip-value-improved" id="tt-profit-imp">-</span></div>
      <div class="tooltip-row-improved"><span class="tooltip-label-improved">ROI (%):</span><span class="tooltip-value-improved" id="tt-roi-imp">-</span></div>
    </div>
    
    <div id="go-chart-empty" style="display:none">Brak danych do wykresu w wybranym okresie.</div>
  </div>
</section>

    <section class="go-card go-panel">
      <div style="display:flex;align-items:center;gap:8px">
        <h4 style="margin:0">📂 Portfele</h4><div style="flex:1"></div><span class="go-muted go-mini">Kliknij, by rozwinąć pozycje.</span>
      </div>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Portfel</th><th>Waluta</th><th>Gotówka</th><th>Akcje</th><th>Razem (nat.)</th><th>Razem (baz.)</th><th>Koszt własny</th><th>Unreal. P/L</th><th>Unreal. %</th><th>Real. netto</th></tr></thead>
          <tbody id="go-pf-body"><tr><td colspan="10" class="go-muted">Brak danych…</td></tr></tbody>
        </table>
      </div>
    </section>

    <section class="go-card go-panel">
      <div style="display:flex;gap:8px;align-items:center">
        <h4 style="margin:0">🧩 Pozycje (agregacja)</h4>
        <div style="flex:1"></div>
        <input id="go-filter" placeholder="np. TSLA, .WA, zysk>0, strata>0, pf:Nazwa" style="max-width:320px">
      </div>
      <div class="table-wrap">
        <table>
          <thead><tr><th>Ticker</th><th>Portfel</th><th>Ilość</th><th>Śr. koszt</th><th>Koszt własny</th><th>Kurs</th><th>Wartość</th><th>Unreal. P/L</th><th>%</th><th>Δ dzienny</th></tr></thead>
          <tbody id="go-pos-body"><tr><td colspan="10" class="go-muted">Brak pozycji…</td></tr></tbody>
        </table>
      </div>
    </section>
  </div>
</section>

<script>
(function(){
  "use strict";

// === Period filter helpers ===
function toMs(d){
  try{
    if(d==null) return NaN;
    if(typeof d === 'number') return d;
    if(typeof d === 'string'){ const ms = Date.parse(d); return Number.isFinite(ms)?ms:NaN; }
    if(d && typeof d.toDate === 'function'){ try{ return d.toDate().getTime(); }catch(_){ return NaN; } }
    if(d && typeof d.seconds !== 'undefined'){ return Number(d.seconds)*1000; }
  }catch(_){}
  return NaN;
}
function getPeriodKey(){
  try{ return localStorage.getItem('global_overview_period') || 'all'; }catch(_){ return 'all'; }
}
function setPeriodKey(k){
  try{ localStorage.setItem('global_overview_period', String(k||'all')); }catch(_){}
}
function getPeriodRange(key){
  const now = new Date();
  const end = now.getTime();
  const msDay = 24*60*60*1000;
  const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
  switch(key){
    case 'day':  return {start:startOfToday, end};
    case 'week': return {start:end - 7*msDay, end};
    case 'month':return {start:end - 30*msDay, end};
    case 'ytd':  return {start:new Date(now.getFullYear(),0,1).getTime(), end};
    case '1y':   return {start:end - 365*msDay, end};
    case '2y':   return {start:end - 2*365*msDay, end};
    case '3y':   return {start:end - 3*365*msDay, end};
    default:     return {start:-Infinity, end};
  }
}
function inRangeMs(ms, range){
  if(!range) return true;
  if(!Number.isFinite(ms)) return false;
  const s = Number(range.start ?? -Infinity);
  const e = Number(range.end ?? Infinity);
  return ms >= s && ms <= e;
}

  // === GLOBAL, COOPERATIVE RATE-LIMITED QUOTE LAYER (shared across modules) ===
  const MIN_INTERVAL_MS = 1100;       //  ~1 req/sec (safe for free tiers)
  const CACHE_TTL_MS   = 60*1000;     //  60s cache per symbol
  const BACKOFF_429_MS = 15*1000;     //  15s cooldown on 429

  const W = window;
  W.__GT_QUOTE_CACHE = W.__GT_QUOTE_CACHE || new Map(); // symbol -> {q, at}
  W.__GT_QUOTE_PENDING = W.__GT_QUOTE_PENDING || new Map(); // symbol -> Promise
  W.__GT_QUOTE_LAST_CALL = W.__GT_QUOTE_LAST_CALL || 0;
  W.__GT_QUOTE_COOLDOWN_UNTIL = W.__GT_QUOTE_COOLDOWN_UNTIL || 0;

  function now(){ return Date.now(); }

  function readFromAppQuotes(symbol){
    try{
      // próbujemy współdzielić dane głównej aplikacji, jeśli ma global QUOTES
      const Q = W.QUOTES || W.__QUOTES || null;
      if(!Q || !Q[symbol]) return null;
      const v = Q[symbol];
      // heurystyka: rozmaite formaty
      if (typeof v === 'object'){
        const price = Number(v.price ?? v.c ?? v.last ?? v.p) || null;
        if (price){ return { c: price, pc: Number(v.prevPrice ?? v.pc ?? 0) || null, t: now() }; }
      }else if (isFinite(Number(v))){
        return { c: Number(v), pc: null, t: now() };
      }
    }catch(_){}
    return null;
  }

  async function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }

  async function fetchQuoteCoop(symbol, token, opts={}){
    const noApi = !!opts.noApi;
    const ttl = isFinite(opts.ttlMs) ? opts.ttlMs : CACHE_TTL_MS;
    const key = String(symbol).toUpperCase();

    // (1) cache
    const cached = W.__GT_QUOTE_CACHE.get(key);
    if (cached && (now() - cached.at) < ttl){ return cached.q; }

    // (2) try read from app's existing quotes
    const fromApp = readFromAppQuotes(key);
    if (fromApp){
      W.__GT_QUOTE_CACHE.set(key, {q: fromApp, at: now()});
      return fromApp;
    }

    // (3) no external calls mode
    if (noApi || !token){
      // keep last known cache or return null
      return cached ? cached.q : null;
    }

    // de-dup concurrent fetches for the same symbol
    if (W.__GT_QUOTE_PENDING.has(key)) return await W.__GT_QUOTE_PENDING.get(key);

    const p = (async ()=>{
      // cooldown window after 429
      const until = W.__GT_QUOTE_COOLDOWN_UNTIL || 0;
      if (now() < until) { await delay(until - now()); }

      // rate limit: spacing calls
      const wait = Math.max(0, (W.__GT_QUOTE_LAST_CALL + MIN_INTERVAL_MS) - now());
      if (wait>0) await delay(wait);

      try{
        const url = `https://finnhub.io/api/v1/quote?symbol=${encodeURIComponent(key)}&token=${encodeURIComponent(token)}`;
        const res = await fetch(url);
        if (res.status === 429){
          // backoff; keep old value if any
          W.__GT_QUOTE_COOLDOWN_UNTIL = now() + BACKOFF_429_MS;
          const cached = W.__GT_QUOTE_CACHE.get(key);
          return cached ? cached.q : null;
        }
        const js = await res.json();
        const q = { c:Number(js.c)||null, pc:Number(js.pc)||null, d:Number(js.d)||null, dp:Number(js.dp)||null, t: js.t||now() };
        W.__GT_QUOTE_CACHE.set(key, {q, at: now()});
        return q;
      }finally{
        W.__GT_QUOTE_LAST_CALL = now();
      }
    })();

    W.__GT_QUOTE_PENDING.set(key, p);
    try{ return await p; }
    finally{ W.__GT_QUOTE_PENDING.delete(key); }
  }

  // === Module-local code ===
  const KEY = "portfele_firmy_v1";
  const $ = (s, r=document)=> r.querySelector(s);
  const fmtMoney = (n, cur='PLN') => {
    const x = Number(n); if(!isFinite(x)) return "—";
    try{ return new Intl.NumberFormat('pl-PL',{style:'currency', currency:cur, maximumFractionDigits:2, minimumFractionDigits:2}).format(x); }
    catch(e){ return x.toFixed(2)+' '+cur; }
  };
  const fmtNum = (n,d=2)=> isFinite(Number(n)) ? Number(n).toFixed(d) : '—';

  const ST = {
    DB:null, base:'PLN', token:'', poll:45, FX:{PLN:{PLN:1, fxUsdplnAt:0}}, timer:null, noApi:false, ttlMs:60*1000
  };

  function loadPrefs(){
  try{
    ST.periodKey = getPeriodKey();
    const sel = document.getElementById('go-period');
    if(sel){ sel.value = ST.periodKey; }
    ST.periodRange = getPeriodRange(ST.periodKey);
  }catch(_){ ST.periodKey = 'all'; ST.periodRange = getPeriodRange('all'); }

    try{ ST.DB = JSON.parse(localStorage.getItem(KEY) || '{}'); } catch(_){ ST.DB = {}; }
    if(!ST.DB || !ST.DB.settings) ST.DB = ST.DB || {settings:{}};
    ST.base  = localStorage.getItem('global_overview_base') || 'PLN';
    ST.poll  = Number(localStorage.getItem('global_overview_poll')|| (ST.DB.settings?.pricePollSeconds || 45)) || 45;
    ST.token = (localStorage.getItem('global_overview_tok') || ST.DB.settings?.finnhubToken || '').trim();
    ST.noApi = localStorage.getItem('global_overview_noapi') === '1';
    $('#go-base').value = ST.base; $('#go-poll').value = ST.poll; $('#go-token').value = ST.token;
    $('#go-no-api').checked = ST.noApi;
    $('#go-ttl').textContent = Math.round(ST.ttlMs/1000)+'s';
  }

  
async function ensureFx(from, to){
  try{
    if(!ST.FX[from]) ST.FX[from] = {};
    const pairKey = from + '->' + to;
    const nowTs = Date.now();

    // same-currency shortcut
    if(from===to){
      ST.FX[from][to] = 1;
      try{ paintFx(); }catch(_){}
      return 1;
    }

    // Manual override for USD->PLN/PLN->USD (set via "Ustaw")
    try{
      if ((from==='USD' && to==='PLN') || (from==='PLN' && to==='USD')){
        const m = Number(localStorage.getItem('global_overview_fx_usdpln') || '');
        if (Number.isFinite(m) && m>0){
          // respect manual override
          ST.FX['USD'] = ST.FX['USD'] || {};
          ST.FX['PLN'] = ST.FX['PLN'] || {};
          ST.FX['USD']['PLN'] = m;
          ST.FX['PLN']['USD'] = 1/m;
          try{ paintFx(); }catch(_){}
          return (from==='USD') ? m : (1/m);
        }
      }
    }catch(_){}

    // For USD<->PLN refresh using TTL (defaults to ST.ttlMs)
    const isUsdPln = (from==='USD' && to==='PLN') || (from==='PLN' && to==='USD');
    const ttlMs = Math.max(10_000, Number(ST.ttlMs)||60_000);
    const cached = ST.FX[from] && ST.FX[from][to];
    const freshEnough = isUsdPln ? (nowTs - (ST.fxUsdplnAt||0) < ttlMs) : Number.isFinite(cached);

    if (Number.isFinite(cached) && freshEnough){
      return ST.FX[from][to];
    }

    // Decide fetch direction (normalize to USD->PLN if pair is PLN->USD)
    let a = from, b = to, invert = false;
    if (from==='PLN' && to==='USD'){ a='USD'; b='PLN'; invert = true; }

    let rate = null;

    // Try Frankfurter (ECB) first — CORS-friendly, no API key
    try{
      if (a==='USD' && b==='PLN'){
        const r = await fetch('https://api.frankfurter.app/latest?from=USD&to=PLN');
        if (r.ok){
          const j = await r.json();
          rate = Number(j && j.rates && j.rates.PLN);
        }
      }
    }catch(_){}

    // Fallback: exchangerate.host (also CORS-friendly)
    if(!Number.isFinite(rate) || rate<=0){
      try{
        const url = `https://api.exchangerate.host/latest?base=${encodeURIComponent(a)}&symbols=${encodeURIComponent(b)}`;
        const j = await (await fetch(url)).json().catch(()=>null);
        rate = Number(j && j.rates && j.rates[b]);
      }catch(_){}
    }

    // Finalize
    if (Number.isFinite(rate) && rate>0){
      const final = invert ? (1/rate) : rate;
      if(!ST.FX[from]) ST.FX[from] = {};
      if(!ST.FX[to]) ST.FX[to] = {};
      ST.FX[from][to] = final;
      ST.FX[to][from] = 1/final;

      // If specifically USD->PLN pair, update input and remember timestamp
      try{
        if ((from==='USD' && to==='PLN') || (from==='PLN' && to==='USD')){
          ST.fxUsdplnAt = nowTs;
          const v = (from==='USD') ? final : (1/final);
          // show in the input (without tripping manual override)
          const inp = document.getElementById('go-fx-usdpln');
          if (inp) inp.value = (Number(v)||0).toFixed(4);
          // store for convenience in the UI input helper
          try{ localStorage.setItem('gt_fx_usd_pln', String(v)); }catch(_){}
        }
      }catch(_){}

      try{ paintFx(); }catch(_){}
      return ST.FX[from][to];
    }

    // Fallback to previous or 1 if all failed
    if (Number.isFinite(cached)) return cached;
    ST.FX[from][to] = 1;
    try{ paintFx(); }catch(_){}
    return 1;
  }catch(e){
    console.warn('FX error', e);
    return 1;
  }
}
function paintFx(){
    try{
      const parts = [];
      for(const f in ST.FX){ for(const t in ST.FX[f]){ parts.push(`${f}->${t}:${fmtNum(ST.FX[f][t])}`); } }
      $('#go-fx').textContent = parts.join('  |  ') || '—';
    }catch(_){}
  }

  async function fetchAllQuotesCoop(){
    const set = new Set();
    const pfs = Array.isArray(ST.DB.portfolios) ? ST.DB.portfolios : [];
    for(const pf of pfs){ for(const t of Object.keys(pf.holdings||{})){ set.add(String(t).trim().toUpperCase()); } }
    const tickers = Array.from(set);
    const token = ($('#go-token').value || ST.token || '').trim();
    const noApi = $('#go-no-api').checked || !token;

    // fetch only stale/missing; respect queue, dedup with app
    const promises = tickers.map(sym => fetchQuoteCoop(sym, token, { noApi, ttlMs: ST.ttlMs }));
    const quotes = await Promise.all(promises);
    // map to object for later reads
    const obj = {};
    tickers.forEach((t,i)=>{ const q = quotes[i]||null; if(q) obj[t]=q; });
    return obj;
  }

  function realizedSums(pf, range){
    let g=0,t=0,n=0;
    for(const tx of (pf.transactions||[])){
      if(tx.type==='sell'){
        try{ const ms = toMs(tx && tx.date); if(range && !inRangeMs(ms, range)) continue; }catch(_){}
        const gross = Number(tx.grossPL)||0;
        const tax   = Number(tx.tax)|| (gross>0 ? gross*(ST.DB.settings?.taxRate||0.19) : 0);
        const net   = Number(tx.netPL)|| (gross - tax);
        g+=gross; t+=tax; n+=net;
      }
    }
    return {gross:g, tax:t, net:n};
  }

  async function computePortfolio(pf, Q, range){
    const base = $('#go-base').value || ST.base || 'PLN';
    const fx = await ensureFx(pf.currency||'PLN', base);
    let holdings=0, cost=0, day=0;
    const positions=[];
    for(const [ticker,book] of Object.entries(pf.holdings||{})){
      let qty=0,cst=0,avg=0;
      for(const lot of (book.lots||[])){ const q=Number(lot.qty)||0; const uc=Number(lot.unitCost)||0; qty+=q; cst+=q*uc; }
      avg = qty>0?cst/qty:0;
      const qd = (Q && Q[ticker]) ? Q[ticker] : null;
      const price = qd && isFinite(qd.c) ? Number(qd.c) : avg;
      const val = qty*price; holdings+=val; cost+=cst;
      if(qd && isFinite(qd.d)) day += qty*Number(qd.d);
      positions.push({ticker, qty, avg, cost:cst, price, value:val, d:qd?.d??null, dp:qd?.dp??null});
    }
    const cash = Number(pf.cash)||0;
    const {gross, tax, net} = realizedSums(pf, range);
    return {
      pf, fx,
      cashNat: cash, cashBase: cash*fx,
      holdingsNat: holdings, holdingsBase: holdings*fx,
      equityNat: cash+holdings, equityBase:(cash+holdings)*fx,
      costNat: cost, costBase: cost*fx,
      unrealNat: holdings-cost, unrealBase:(holdings-cost)*fx,
      unrealPct: cost>0? (holdings-cost)/cost : null,
      dayMoveNat: day, dayMoveBase: day*fx,
      realizedGrossNat:gross, realizedTaxNat:tax, realizedNetNat:net,
      realizedGrossBase:gross*fx, realizedTaxBase:tax*fx, realizedNetBase:net*fx,
      positions
    };
  }

  async function computeAll(Q, range){
    const base = $('#go-base').value || 'PLN';
    const pfs = Array.isArray(ST.DB.portfolios) ? ST.DB.portfolios : [];
    const results=[];
    let tot = {holdingsBase:0,cashBase:0,equityBase:0,costBase:0,unrealBase:0,dayMoveBase:0,realizedGrossBase:0,realizedTaxBase:0,realizedNetBase:0};
    for(const pf of pfs){
      const r = await computePortfolio(pf, Q, range);
      results.push(r);
      tot.holdingsBase+=r.holdingsBase; tot.cashBase+=r.cashBase; tot.equityBase+=r.equityBase;
      tot.costBase+=r.costBase; tot.unrealBase+=r.unrealBase; tot.dayMoveBase+=r.dayMoveBase;
      tot.realizedGrossBase+=r.realizedGrossBase; tot.realizedTaxBase+=r.realizedTaxBase; tot.realizedNetBase+=r.realizedNetBase;
    }
    const unrealPct = tot.costBase>0 ? (tot.unrealBase/tot.costBase) : null;
    return {base, results, tot, unrealPct};
  }

  function paintTotals({base, tot, unrealPct}){
    $('#go-tot-hold').textContent = fmtMoney(tot.holdingsBase, base);
    $('#go-tot-cash').textContent = fmtMoney(tot.cashBase, base);
    $('#go-tot-eq').textContent = fmtMoney(tot.equityBase, base);
    $('#go-tot-unr').textContent = fmtMoney(tot.unrealBase, base);
    const pct = $('#go-tot-unr-pct'); pct.textContent = unrealPct===null?'—':(unrealPct*100).toFixed(2)+'%';
    pct.className = 'go-badge ' + (unrealPct>0?'go-pos':(unrealPct<0?'go-neg':''));
    $('#go-day').textContent = 'Δ dzienny: ' + fmtMoney(tot.dayMoveBase, base);
    $('#go-real-g').textContent = fmtMoney(tot.realizedGrossBase, base);
    $('#go-real-tax').textContent = fmtMoney(tot.realizedTaxBase, base);
    $('#go-real-n').textContent = fmtMoney(tot.realizedNetBase, base);
  }

  function renderPositionsTable(positions, cur){
    if(!positions || !positions.length) return `<div class="go-muted go-mini">Brak pozycji.</div>`;
    const rows = positions.map(p=>{
      const pl = (p.value - p.cost);
      const dp = isFinite(p.dp) ? `<span class="go-badge ${p.dp>=0?'go-pos':'go-neg'}">${Number(p.dp).toFixed(2)}%</span>` : '—';
      const plCls = pl>0?'go-pos':(pl<0?'go-neg':'');
      return `<tr>
        <td class="go-ticker">${escapeHtml(p.ticker)}</td>
        <td>${Number(p.qty).toFixed(2)}</td>
        <td>${fmtMoney(p.avg, cur)}</td>
        <td>${fmtMoney(p.cost, cur)}</td>
        <td>${isFinite(p.price)?Number(p.price).toFixed(2):'—'}</td>
        <td>${fmtMoney(p.value, cur)}</td>
        <td class="${plCls}">${fmtMoney(pl, cur)}</td>
        <td>${isFinite(p.cost)&&p.cost>0?(((p.value-p.cost)/p.cost)*100).toFixed(2)+'%':'—'}</td>
        <td>${dp}</td>
      </tr>`;
    }).join('');
    return `<div class="table-wrap" style="margin-top:8px">
      <table>
        <thead><tr><th>Ticker</th><th>Ilość</th><th>Śr. koszt</th><th>Koszt własny</th><th>Kurs</th><th>Wartość</th><th>P/L</th><th>%</th><th>Δ dzienny</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    </div>`;
  }
  function escapeHtml(s){ const t=document.createElement('textarea'); t.textContent=String(s||''); return t.innerHTML; }

  function buildAllPositions(resList){
    const rows = [];
    for (let i=0;i<resList.length;i++){ const r = resList[i];
      for(const p of r.positions){
        rows.push({ ticker: p.ticker, pf: r.pf.name||'—', qty: p.qty, avg: p.avg, cost: p.cost,
          price: isFinite(p.price)?p.price:null, value: p.value, pl: p.value-p.cost,
          pct: p.cost>0? (p.value-p.cost)/p.cost : null, dp: isFinite(p.dp)?p.dp:null, currency: r.pf.currency||'PLN', pfIdx: i
        });
      }
    }
    return rows;
  }

  function paintPortfolios(resList, base){
    const tbody = $('#go-pf-body'); tbody.innerHTML='';
    if(!resList.length){ tbody.innerHTML = '<tr><td colspan="10" class="go-muted">Brak danych…</td></tr>'; return; }
    for(const r of resList){
      const unrealCls = r.unrealBase>0 ? 'go-pos' : (r.unrealBase<0 ? 'go-neg' : '');
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><details><summary>${escapeHtml(r.pf.name||'—')}</summary>${renderPositionsTable(r.positions, r.pf.currency)}</details></td>
        <td>${r.pf.currency||'PLN'}</td>
        <td>${fmtMoney(r.cashNat, r.pf.currency)}</td>
        <td>${fmtMoney(r.holdingsNat, r.pf.currency)}</td>
        <td><b>${fmtMoney(r.equityNat, r.pf.currency)}</b></td>
        <td>${fmtMoney(r.equityBase, base)}</td>
        <td>${fmtMoney(r.costNat, r.pf.currency)}</td>
        <td class="${unrealCls}">${fmtMoney(r.unrealNat, r.pf.currency)}</td>
        <td>${r.unrealPct===null?'—':(r.unrealPct*100).toFixed(2)+'%'}</td>
        <td>${fmtMoney(r.realizedNetNat, r.pf.currency)}</td>
      `;
      tbody.appendChild(tr);
    }
  }

  
  // === Expandable details for aggregated positions ===
  function renderTickerDetails(pf, ticker){
    try{
      function readLastPrice(t){
        try{
          const key = String(t||'').toUpperCase();
          const fromCache = (window.__GT_QUOTE_CACHE && window.__GT_QUOTE_CACHE.get) ? window.__GT_QUOTE_CACHE.get(key) : null;
          const q = fromCache && fromCache.q ? fromCache.q : null;
          if(q && isFinite(q.c)) return Number(q.c);
        }catch(_){}
        try{
          const K = String(t||'').toUpperCase();
          const q2 = (window.QUOTES && window.QUOTES[K]) ? window.QUOTES[K] : null;
          if(q2 && isFinite(q2.price)) return Number(q2.price);
        }catch(_){}
        return null;
      }
      const book = (pf && pf.holdings && pf.holdings[ticker]) ? pf.holdings[ticker] : null;
      const lots = Array.isArray(book && book.lots) ? book.lots : [];
      const cur = pf.currency || 'PLN';
      const last = readLastPrice(ticker);
    const rows = lots.map(l=>{
        const qty = Number(l.qty)||0;
        const uc  = Number(l.unitCost)||0;
        const cost = qty*uc;
        const price = (last!=null && isFinite(last)) ? Number(last) : uc;
        const val = qty*price;
        const pl = val - cost;
        const pct = cost>0 ? (pl/cost)*100 : null;
        const date = l.date || '';
        const note = l.note ? String(l.note) : '';
        return `<tr>
          <td>${escapeHtml(date)}</td>
          <td>${qty.toFixed(2)}</td>
          <td>${fmtMoney(uc, cur)}</td>
          <td>${fmtMoney(cost, cur)}</td>
          <td>${isFinite(price)?price.toFixed(2):'—'}</td>
          <td>${fmtMoney(val, cur)}</td>
          <td class="${pl>0?'go-pos':(pl<0?'go-neg':'')}">${fmtMoney(pl, cur)}</td>
          <td>${pct===null?'—':pct.toFixed(2)+'%'}</td>
          <td class="go-mini">${escapeHtml(note)}</td>
        </tr>`;
      }).join('') || `<tr><td colspan="9" class="go-mini go-muted center">Brak transakcji/partii dla ${escapeHtml(ticker)}</td></tr>`;

      return `
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>Data</th><th>Ilość</th><th>Cena zakupu</th><th>Koszt</th><th>Kurs</th><th>Wartość</th><th>Unreal. P/L</th><th>%</th><th>Notatka</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
    }catch(e){
      console.warn('renderTickerDetails error', e);
      return `<div class="go-mini go-muted">Błąd generowania szczegółów.</div>`;
    }
  }
function paintPositions(resList){
    const tbody = $('#go-pos-body');
    const filter = ($('#go-filter').value||'').trim().toUpperCase();
    const rows = buildAllPositions(resList).filter(r=>{
      if(!filter) return true;
      const wantGain = filter.includes('ZYSK>0');
      const wantLoss = filter.includes('STRATA>0');
      const pfQuery = /PF:([^ ,]+)/.exec(filter);
      const hasTicker = r.ticker.toUpperCase().includes(filter) || r.pf.toUpperCase().includes(filter);
      const pfMatch = pfQuery ? r.pf.toUpperCase().includes(pfQuery[1].toUpperCase()) : true;
      const byGain = wantGain ? (r.pl>0) : true;
      const byLoss = wantLoss ? (r.pl<0) : true;
      return (hasTicker || pfMatch) && byGain && byLoss;
    });

    tbody.innerHTML='';
    if(!rows.length){ tbody.innerHTML='<tr><td colspan="10" class="go-muted">Brak pozycji…</td></tr>'; return; }
    for(const r of rows){
      const plCls = r.pl>0?'go-pos':(r.pl<0?'go-neg':'');
      const dp = r.dp===null ? '—' : `<span class="go-badge ${r.dp>=0?'go-pos':'go-neg'}">${Number(r.dp).toFixed(2)}%</span>`;
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="go-ticker">${escapeHtml(r.ticker)}</td>
        <td>${escapeHtml(r.pf)}</td>
        <td>${Number(r.qty).toFixed(2)}</td>
        <td>${fmtMoney(r.avg, r.currency)}</td>
        <td>${fmtMoney(r.cost, r.currency)}</td>
        <td>${r.price===null?'—':Number(r.price).toFixed(2)}</td>
        <td>${fmtMoney(r.value, r.currency)}</td>
        <td class="${plCls}">${fmtMoney(r.pl, r.currency)}</td>
        <td>${r.pct===null?'—':(r.pct*100).toFixed(2)+'%'}</td>
        <td>${dp}</td>
      `;
      tbody.appendChild(tr);
    
      // attach expand-on-click for details
      tr.dataset.ticker = r.ticker;
      tr.dataset.pfIdx = String(r.pfIdx ?? -1);
      tr.style.cursor = 'pointer';
      tr.addEventListener('click', function(ev){
        if(ev.target && (ev.target.closest('button') || ev.target.closest('a'))) return;
        const existing = tr.nextElementSibling;
        if(existing && existing.classList.contains('go-detail-row')){
          existing.remove();
          return;
        }
        const idx = Number(tr.dataset.pfIdx);
        const ticker = tr.dataset.ticker;
        const pf = (resList && idx>=0 && resList[idx]) ? resList[idx].pf : null;
        const detail = document.createElement('tr');
        detail.className = 'go-detail-row';
        const colSpan = tr.children.length;
        detail.innerHTML = `<td colspan="${colSpan}" style="background:rgba(148,163,184,.08);padding:8px 12px;border-top:1px dashed #334155">
          ${renderTickerDetails(pf, ticker)}
        </td>`;
        tr.after(detail);
      });
    }
    
  }


  
  /* === [GO Extra Stats] avg holding time & avg % profit per position (closed trades) — ROBUST (replay) === */
  function computeClosedTradeStats(range){
  try{ ST.tpCount = 0; }catch(_){}
    try{
      // Prefer app context ST.DB (used w Global Overview), fallback to DB/window.DB
      const DBctx = (typeof ST!=='undefined' && ST && ST.DB) ? ST.DB
                  : ((typeof DB!=='undefined' && DB) ? DB : (window.DB||{}));
      const portfolios = Array.isArray(DBctx.portfolios) ? DBctx.portfolios : [];
      let samples = 0, sumDays = 0, sumPct = 0; let tpCountTx = 0;// Helper to parse date safely
      const toMs = (d)=>{
        try{
          if(!d) return NaN;
          // Accept ISO string or Date object or Firestore timestamp-like {seconds}
          if (d instanceof Date) return d.getTime();
          if (typeof d === 'object' && d !== null && Number.isFinite(d.seconds)) return d.seconds*1000;
          const ms = Date.parse(d);
          return Number.isFinite(ms) ? ms : NaN;
        }catch(_){ return NaN; }
      };

      // Iterate each portfolio independently
      for(const pf of portfolios){
        if(!pf) continue;
        const txs = Array.isArray(pf.transactions) ? pf.transactions.slice() : [];
        // CHRONOLOGICAL (oldest -> newest)
        const chrono = txs.reverse();

        // Minimal in-memory holdings book per ticker: FIFO queue of lots {lotId, dateMs, unitCost, qty}
        const book = Object.create(null);

        // Pre-index buy info by lotId for fast lookup when lotLinks exist
        const buyIdx = new Map();

        const pushLot = (ticker, lotId, dateVal, unitCost, qty)=>{
          const dateMs = toMs(dateVal);
          if(!Number.isFinite(dateMs) || !Number.isFinite(unitCost) || unitCost<=0 || !Number.isFinite(qty) || qty<=0) return;
          const t = (ticker||'').trim().toUpperCase(); if(!t) return;
          (book[t] ||= []).push({lotId, dateMs, unitCost, qty});
          buyIdx.set(lotId, {dateMs, unitCost}); // also index
        };

        for(const tx of chrono){
          if(!tx || !tx.type) continue;
          const t = tx.type;
          if(t==='buy'){
            const qty  = Number(tx.qty)||0;
            const price= Number(tx.price)||0;
            const fees = Number(tx.fees)||0;
            const lotId= tx.lotId || (tx.id ? `lot_${tx.id}` : null);
            const unitCost = qty>0 ? (price + fees/Math.max(qty,1)) : price;
            pushLot(tx.ticker, lotId, tx.date, unitCost, qty);
          }else if(t==='transfer_company_in'){
            const qty  = Number(tx.qty)||0;
            const lotId= tx.newLotId || tx.lotId || (tx.id ? `lot_${tx.id}` : null);
            const unitCost = Number(tx.unitCost ?? tx.price ?? 0);
            pushLot(tx.ticker, lotId, tx.date, unitCost, qty);
          }else if(t==='sell'){
            // Count TP as 1 per SELL transaction (within selected period)
            try{ if(inRangeMs(toMs(tx.date), range)) tpCountTx++; }catch(_){/*noop*/}

            // Count TP as 1 per SELL transaction (within selected period)
            try{ if(inRangeMs(toMs(tx.date), range)) tpCountTx++; }catch(_){/*noop*/}

            const ticker = (tx.ticker||'').trim().toUpperCase();
            const sellDateMs = toMs(tx.date);
            const sellPrice  = Number(tx.price ?? tx.sellPrice ?? 0);
            let remainingQty = Number(tx.qty)||0;
            if(!ticker || !Number.isFinite(sellDateMs) || !Number.isFinite(sellPrice) || sellPrice<=0) continue;

            // 1) Prefer precise allocations if they exist
            const links = Array.isArray(tx.lotLinks) ? tx.lotLinks : [];
            if(links.length>0){
              for(const link of links){
                const info = link ? buyIdx.get(link.lotId) : null;
                if(!info || !Number.isFinite(info.dateMs) || !Number.isFinite(info.unitCost) || info.unitCost<=0) continue;
                const days = Math.max(0, (sellDateMs - info.dateMs)/86400000);
                const pct  = ((sellPrice - info.unitCost)/info.unitCost)*100;
                if(!inRangeMs(sellDateMs ?? toMs(tx.date), range)) { /* skip out-of-range */ } else { sumDays += days; sumPct += pct; samples += 1;  }
              }
              continue; // done with this sell
            }

            // 2) Fallback: reconstruct FIFO from current book
            const qlots = book[ticker] || [];
            let need = Math.max(0, remainingQty);
            let i = 0;
            while(need>0 && i<qlots.length){
              const lot = qlots[i];
              const take = Math.min(need, lot.qty);
              if(take>0 && Number.isFinite(lot.dateMs) && Number.isFinite(lot.unitCost) && lot.unitCost>0){
                const days = Math.max(0, (sellDateMs - lot.dateMs)/86400000);
                const pct  = ((sellPrice - lot.unitCost)/lot.unitCost)*100;
                if(!inRangeMs(sellDateMs ?? toMs(tx.date), range)) { /* skip out-of-range */ } else { sumDays += days; sumPct += pct; samples += 1;  }
                lot.qty -= take;
                need -= take;
                if(lot.qty<=0){ i++; }
              }else{
                i++; // skip broken lot
              }
            }
            // Remove depleted lots
            if(i>0) book[ticker] = qlots.slice(i).filter(L=>L.qty>0);
          }
        }
      }

      return { avgDays: samples ? (sumDays/samples) : null, avgPct: samples ? (sumPct/samples) : null, samples, tpCountTx };
    }catch(e){
      console.warn('[GO] computeClosedTradeStats (robust) failed', e);
      return { avgDays: null, avgPct: null, samples: 0, tpCountTx: 0 };
    }
  }
  function paintExtraStats(stats){
    try{
      const elH = document.getElementById('go-avg-hold');
      const elP = document.getElementById('go-avg-pct');
      if(elH){ elH.textContent = (stats && Number.isFinite(stats.avgDays)) ? (Number(stats.avgDays).toFixed(1)+' d') : '—'; }
      if(elP){ elP.textContent = (stats && Number.isFinite(stats.avgPct))  ? (Number(stats.avgPct).toFixed(2)+'%') : '—'; }
      if(stats && stats.samples===0){
        if(elH) elH.title = 'Brak zamkniętych transakcji do wyliczenia lub brak dopasowań';
        if(elP) elP.title = 'Brak zamkniętych transakcji do wyliczenia lub brak dopasowań';
      }
    }catch(_){}
  }
  // Fallback/robust TP counter: counts SELL transactions within range directly from DB
  function countSellTxInRange(DBctx, range){
    try{
      const db = DBctx || (window.ST && ST.DB) || window.DB || {};
      const pfs = Array.isArray(db.portfolios) ? db.portfolios : [];
      let n = 0;
      for(const pf of pfs){
        const txs = Array.isArray(pf.transactions) ? pf.transactions : [];
        for(const tx of txs){
          if(tx && tx.type === 'sell'){
            const d = Date.parse(tx.date || '');
            if(Number.isFinite(d) && (!range || (d >= (range.start ?? -Infinity) && d <= (range.end ?? Infinity)))){
              n++;
            }
          }
        }
      }
      return n;
    }catch(_){ return 0; }
  }
// === [GO] LINIOWY WYKRES: Wkład (blue) vs Wartość (green) =====================
let __GO_CHART_CACHE = null;
function __go_toMs(d){ try{ if(typeof d === 'number') return d; return Date.parse(d || '1970-01-01'); }catch(_){ return 0; } }
function __go_floorDay(ms){ const dt = new Date(ms); dt.setHours(0,0,0,0); return dt.getTime(); }
function __go_fmt(d){ try{ return new Date(d).toLocaleDateString(); }catch(_){ return String(d); } }
function __go_sum(a){ return (a||[]).reduce((x,y)=>x+(+y||0),0); }

function __go_wap(lots){
  try{
    if(!Array.isArray(lots) || !lots.length) return 0;
    let sQty=0, sVal=0;
    for(const l of lots){ const q=Number(l.qty)||0, p=Number(l.price)||0; sQty+=q; sVal+=q*p; }
    return sQty>0 ? (sVal/sQty) : 0;
  }catch(_){ return 0; }
}


async function computeGlobalLineSeries(Q, periodRange, base){
  const startMs = __go_floorDay(periodRange.start);
  const endMs   = __go_floorDay(periodRange.end);
  const seriesBlue = []; // wkład
  const seriesGreen = []; // equity
  const pfStates = new Map();  // pf.id -> { cash, holdings: { TKR: {qty} } }
  const pfFx = new Map();      // pf.id -> fx to base
  const allTx = [];

  // Collect & prepare
  for(const pf of (ST.DB?.portfolios||[])){
    pfStates.set(pf.id||pf.name||pf.ticker||Math.random().toString(36).slice(2), { cash: 0, holdings: {} });
    const fx = await ensureFx(pf.currency||'PLN', base);
    pfFx.set(pf.id||pf.name||pf.ticker, fx);
    const txs = (pf.transactions||[]).map(t=>({...t, __pf: pf}));
    allTx.push(...txs);
  }
  // Sort ascending by date
  allTx.sort((a,b)=> __go_toMs(a.date) - __go_toMs(b.date));

  // Helpers that reuse existing engine
  function equityNow(){
    let total = 0;
    for(const pf of (ST.DB?.portfolios||[])){
      const st = pfStates.get(pf.id||pf.name||pf.ticker);
      const fx = pfFx.get(pf.id||pf.name||pf.ticker) || 1;
      total += (st.cash||0) * fx;
      for(const [tk, book] of Object.entries(st.holdings||{})){
        let price = (Q[tk]?.price ?? 0);
        if(!(price>0)){
          const lots = (book && Array.isArray(book.lots)) ? book.lots : [];
          const wap = __go_wap(lots);
          price = wap>0 ? wap : 0;
        }
        const qty = (book && Array.isArray(book.lots) && book.lots.length)
          ? __go_sum(book.lots.map(l=> +l.qty||0))
          : Number((book&&book.qty)||0);
        total += qty * price * fx;
      }
    }
    return total;
  }
  function applyTxToState(tx){
    const pf = tx.__pf;
    const st = pfStates.get(pf.id||pf.name||pf.ticker);
    if(!st) return;
    // cash-only flows
    if(tx.type==="deposit" || tx.type==="withdraw" || tx.type==="transfer_in" || tx.type==="transfer_out"){
      (typeof applyCash==='function' ? applyCash : __go_applyCashShim)(st, tx.type, tx.amount||0);
      return;
    }
    if(tx.type==="buy"){ try{ if(typeof ensureBuyLotIdInTx==='function') ensureBuyLotIdInTx(tx);}catch(_){}; (typeof applyBuy==='function' ? applyBuy : __go_applyBuy)(st, pf, tx); return; }
    if(tx.type==="sell"){ (typeof applySell==='function' ? applySell : __go_applySell)(st, pf, tx); return; }
    if(tx.type==="transfer_company_in"){ (typeof applyTransferCompanyIn==='function' ? applyTransferCompanyIn : __go_applyTransferCompanyIn)(st, pf, tx); return; }
    if(tx.type==="transfer_company_out"){ (typeof applyTransferCompanyOut==='function' ? applyTransferCompanyOut : __go_applyTransferCompanyOut)(st, pf, tx); return; }
    // ignore unknowns
  }

  // Build baseline up to start
  let wkładBase = 0;
  for(const tx of allTx){
    const tms = __go_toMs(tx.date);
    if(tms < startMs){
      // contributions
      if(tx.type==="deposit" || tx.type==="transfer_in"){
        wkładBase += (Number(tx.amount)||0) * (pfFx.get(tx.__pf.id)||1);
      }else if(tx.type==="withdraw" || tx.type==="transfer_out"){
        wkładBase -= (Number(tx.amount)||0) * (pfFx.get(tx.__pf.id)||1);
      }
      applyTxToState(tx);
    }else{
      break;
    }
  }
  // Snapshot at start
  seriesBlue.push({ x:startMs, y: wkładBase });
  seriesGreen.push({ x:startMs, y: equityNow() });

  // Apply in-range
  for(const tx of allTx){
    const tms = __go_toMs(tx.date);
    if(tms < startMs || tms > endMs) continue;
    if(tx.type==="deposit" || tx.type==="transfer_in"){
      wkładBase += (Number(tx.amount)||0) * (pfFx.get(tx.__pf.id)||1);
    }else if(tx.type==="withdraw" || tx.type==="transfer_out"){
      wkładBase -= (Number(tx.amount)||0) * (pfFx.get(tx.__pf.id)||1);
    }
    applyTxToState(tx);
    const day = __go_floorDay(tms);
    seriesBlue.push({ x: day, y: wkładBase });
    seriesGreen.push({ x: day, y: equityNow() });
  }

  // Force final point at end
  seriesBlue.push({ x:endMs, y: wkładBase });
  seriesGreen.push({ x:endMs, y: equityNow() });

  // Bounds
  const ys = [...seriesBlue, ...seriesGreen].map(p=>p.y);
  let minY = Math.min(...ys, 0);
  let maxY = Math.max(...ys, 0);
  if(!ys.length || !Number.isFinite(minY) || !Number.isFinite(maxY)){
      minY = 0; maxY = 1;
  }
  if(maxY - minY < 1e-6){ maxY = minY + 1; } // avoid 0 height

  return { seriesBlue, seriesGreen, bounds:{ minX:startMs, maxX:endMs, minY, maxY } };
}

function __go_fmtCurrency(v, code){ try{ if(typeof fmtCurrency==='function') return fmtCurrency(v, code); }catch(_){ } try{ return new Intl.NumberFormat(undefined,{style:'currency',currency:(code||'PLN')}).format(v||0);}catch(_){ return String(Math.round((v||0)*100)/100)+' '+(code||''); } }

function drawGlobalLineChart(cache){
    try{
      const base = document.getElementById('go-base')?.value || 'PLN';
      const b = cache?.seriesBlue || [];
      const g = cache?.seriesGreen || [];
      const lastB = b.length ? b[b.length-1].y : 0;
      const lastG = g.length ? g[g.length-1].y : 0;
      const ib = document.getElementById('go-info-blue'); if(ib) ib.textContent = 'Wkład: ' + __go_fmtCurrency(lastB, base);
      const ig = document.getElementById('go-info-green'); if(ig) ig.textContent = 'Wartość: ' + __go_fmtCurrency(lastG, base);
    }catch(_){}

    const wrap = document.querySelector('#go-line-chart-card .go-chart-wrap') || document.querySelector('.go-chart-wrap');
    const canvas = document.getElementById('go-line-chart');
    const empty = document.getElementById('go-chart-empty');
    const tip = document.getElementById('go-chart-tooltip-imp');
    if(!wrap || !canvas || !empty) return;

    if(!cache || !cache.seriesBlue?.length || !cache.seriesGreen?.length){
      empty.style.display = 'block'; canvas.style.display = 'none'; if(tip) tip.classList.remove('visible'); return;
    }
    empty.style.display = 'none'; canvas.style.display = 'block';

    const dpr = (window.devicePixelRatio||1);
    const desiredH = 820; try{ wrap.style.height = desiredH+'px'; wrap.style.minHeight = '820px'; wrap.style.maxHeight = desiredH+'px'; }catch(_){}
const w = Math.max(10, wrap.clientWidth);
const h = desiredH;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    const overlay = document.getElementById('go-line-chart-overlay');
    let octx = null;
    if(overlay){
      overlay.width = Math.floor(w * dpr);
      overlay.height = Math.floor(h * dpr);
      overlay.style.width = w + 'px';
      overlay.style.height = h + 'px';
      octx = overlay.getContext('2d');
      octx.setTransform(1,0,0,1,0,0);
      octx.scale(dpr, dpr);
    }


    const pad = { left: 110, right: 60, top: 56, bottom: 84 };

    const {minX, maxX} = cache.bounds || {};
const xs = (cache.seriesBlue||[]).map(p=>p.x).concat((cache.seriesGreen||[]).map(p=>p.x));
const _minX = Number.isFinite(minX) ? minX : (xs.length? Math.min(...xs):0);
const _maxX = Number.isFinite(maxX) ? maxX : (xs.length? Math.max(...xs):(_minX+1));
const allY = (cache.seriesBlue||[]).map(p=>p.y).concat((cache.seriesGreen||[]).map(p=>p.y)).filter(v=>Number.isFinite(v));
let _minY = allY.length? Math.min(...allY) : 0;
let _maxY = allY.length? Math.max(...allY) : (_minY+1);
let _rangeY = Math.max(1e-6, _maxY - _minY);
_minY = Math.max(0, _minY - _rangeY*0.20);
_maxY = _maxY + _rangeY*0.20;
_rangeY = Math.max(1e-6, _maxY - _minY);
    const X = x => pad.left + ( (x - _minX) / Math.max(1, (_maxX - _minX)) ) * (w - pad.left - pad.right);
    const Y = y => (h - pad.bottom) - ( (y - _minY) / Math.max(1e-6,(_maxY - _minY)) ) * (h - pad.top - pad.bottom);

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(0,0,w,h);

    const cw = w - pad.left - pad.right;
    const ch = h - pad.top - pad.bottom;

    // Grid
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
    ctx.lineWidth = 1;
    for(let i=0;i<=6;i++){
      const yy = pad.top + (ch/6)*i;
      ctx.beginPath(); ctx.moveTo(pad.left, yy); ctx.lineTo(w - pad.right, yy); ctx.stroke();
      const val = _maxY - (_maxY - _minY) * (i/6);
      ctx.fillStyle = '#94a3b8'; ctx.font = 'bold 13px system-ui, -apple-system, Segoe UI, Roboto';
      ctx.textAlign = 'right';
      try{
        const base = document.getElementById('go-base')?.value || 'PLN';
        ctx.fillText(__go_fmtCurrency(val, base), pad.left - 12, yy + 4);
      }catch(_){}
    }
    // Border
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 2;
    ctx.strokeRect(pad.left, pad.top, cw, ch);

    function strokeSeries(series, color, width){
      if(!series || !series.length) return;
      ctx.beginPath();
      let first = true;
      for(const p of series){
        const xx = X(p.x), yy = Y(p.y);
        if(first){ ctx.moveTo(xx,yy); first=false; } else { ctx.lineTo(xx,yy); }
      }
      ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.stroke();
    }

    strokeSeries(cache.seriesBlue, '#3b82f6', 4.6);
    strokeSeries(cache.seriesGreen, '#22c55e', 4.6);

    function drawPoints(series, fill){
      if(!series || !series.length) return;
      const r = 3.6;
      ctx.fillStyle = fill;
      for(const p of series){
        const xx = X(p.x), yy = Y(p.y);
        ctx.beginPath(); ctx.arc(xx,yy,r,0,Math.PI*2); ctx.fill();
      }
    }
    drawPoints(cache.seriesBlue, 'rgba(59,130,246,0.85)');
    drawPoints(cache.seriesGreen,'rgba(34,197,94,0.85)');

    // X labels
    const xStart = new Date(_minX), xMid = new Date((_minX+_maxX)/2), xEnd = new Date(_maxX);
    ctx.fillStyle = '#94a3b8'; ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto'; ctx.textAlign = 'left';
    ctx.fillText(xStart.toLocaleDateString(), pad.left, h-12);
    const midLabel = xMid.toLocaleDateString(); const midW = ctx.measureText(midLabel).width;
    ctx.fillText(midLabel, (w - midW)/2, h-12);
    const endLabel = xEnd.toLocaleDateString(); const endW = ctx.measureText(endLabel).width;
    
    // Snapshot base layer to prevent crosshair trails
    try{
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.restore();
    }catch(_){}

    // Tooltip events (attach once)

    (function attachTipHandlers(){
      if(!canvas) return;
      const b = cache.seriesBlue || [];
      const g = cache.seriesGreen || [];
      const tip = document.getElementById('go-chart-tooltip-imp');
      function showTip(ptIdx, clientX, clientY){
        if(!tip) return;
        const i = Math.max(0, Math.min(ptIdx, Math.min(b.length, g.length)-1));
        const vb = (b[i] && b[i].y) || 0;
        const vg = (g[i] && g[i].y) || 0;
        const dt = new Date((b[i] && b[i].x) || (g[i] && g[i].x) || _minX);
        const base = document.getElementById('go-base')?.value || 'PLN';
        tip.classList.add('visible');
        const d = document; 
        d.getElementById('tt-date-imp').textContent     = dt.toLocaleDateString('pl-PL');
        d.getElementById('tt-invested-imp').textContent = __go_fmtCurrency(vb, base);
        d.getElementById('tt-value-imp').textContent    = __go_fmtCurrency(vg, base);
        const profit = vg - vb;
        d.getElementById('tt-profit-imp').textContent   = __go_fmtCurrency(profit, base);
        const roi = (vb>0) ? (profit / vb * 100) : 0;
        d.getElementById('tt-roi-imp').textContent      = (roi.toFixed(2) + '%');

        const rect = canvas.getBoundingClientRect();
        let left = clientX - rect.left;
        let top  = clientY - rect.top - 140;
        if (left + 340 > rect.width) left = rect.width - 350;
        if (left < 10) left = 10;
        tip.style.left = left + 'px';
        tip.style.top  = top + 'px';
      }
      function hideTip(){ if(tip) tip.classList.remove('visible'); }

      if(!canvas.__tipBound){
        canvas.addEventListener('mousemove', (e)=>{
          // Restore base snapshot to clear previous crosshairs

          const rect = canvas.getBoundingClientRect();
          const rx = (e.clientX - rect.left) / rect.width;
          const domainX = _minX + Math.max(0, Math.min(1, rx)) * (_maxX - _minX);

          function nearestIdx(series){
            if(!series || !series.length) return -1;
            let lo = 0, hi = series.length-1;
            while(lo < hi){
              const mid = (lo + hi) >> 1;
              if(series[mid].x < domainX) lo = mid + 1; else hi = mid;
            }
            let cand = lo;
            if(lo > 0 && (Math.abs(series[lo-1].x - domainX) < Math.abs(series[lo].x - domainX))) cand = lo-1;
            return cand;
          }

          const bi = nearestIdx(b);
          const gi = nearestIdx(g);
          if(bi < 0 && gi < 0){ return hideTip(); }

          const vb = bi>=0 ? (b[bi].y||0) : 0;
          const vg = gi>=0 ? (g[gi].y||0) : 0;

          // Draw crosshair
          const cx = X(domainX);
          if(octx){ octx.clearRect(0,0,w,h); octx.strokeStyle='rgba(148,163,184,0.35)'; octx.lineWidth=1; octx.beginPath(); octx.moveTo(cx, pad.top); octx.lineTo(cx, h - pad.bottom); octx.stroke(); }

          showTip(Math.max(bi, gi), e.clientX, e.clientY, vb, vg, domainX);
        });
        canvas.addEventListener('mouseleave', ()=>{ hideTip(); if(octx){ octx.clearRect(0,0,w,h); } });
        window.addEventListener('scroll', hideTip, {passive:true});
        canvas.__tipBound = true;
      }
    })();
    }

async function paintGlobalLineChart(Q, periodRange, base){
  try{
    __GO_CHART_CACHE = await computeGlobalLineSeries(Q, periodRange, base);
    drawGlobalLineChart(__GO_CHART_CACHE);
  }catch(err){
    console.warn('[GO] Line chart error:', err);
    const empty = document.getElementById('go-chart-empty');
    const canvas = document.getElementById('go-line-chart');
    if(empty && canvas){ empty.style.display='block'; canvas.style.display='none'; }
  }
}
window.addEventListener('resize', ()=>{ try{ drawGlobalLineChart(__GO_CHART_CACHE); }catch(_){ } });
// === [/GO] =====================================================================
async function refresh(){loadPrefs();
    try{ const ps = document.getElementById('go-period'); if(ps){ ST.periodKey = ps.value||ST.periodKey||'all'; ST.periodRange = getPeriodRange(ST.periodKey); } }catch(_){}
    try{ await ensureFx('USD','PLN'); }catch(_){}
    const pfs = Array.isArray(ST.DB.portfolios) ? ST.DB.portfolios : [];
    const base = $('#go-base').value || ST.base || 'PLN';
    for(const pf of pfs){ await ensureFx(pf.currency||'PLN', base); }
    const Q = await fetchAllQuotesCoop();
    const comp = await computeAll(Q, ST.periodRange);
    paintTotals(comp); paintPortfolios(comp.results, comp.base); paintPositions(comp.results);
    const extra = computeClosedTradeStats(ST.periodRange);
    try{ ST.tpCount = countSellTxInRange(ST.DB, ST.periodRange); var __tp=document.getElementById('go-tp-count'); if(__tp){ __tp.textContent = String(ST.tpCount); } }catch(_){ }     paintExtraStats(extra);
    await paintGlobalLineChart(Q, ST.periodRange, base);
    return comp;
  }
  function schedule(){
    if(ST.timer) clearInterval(ST.timer);
    const sec = Math.max(5, Number($('#go-poll').value)||45);
    ST.timer = setInterval(refresh, sec*1000);
  }

  // UI events
  $('#go-fab').addEventListener('click', ()=>{ $('#go-tab-overlay').hidden=false; refresh(); schedule(); });
  $('#go-close').addEventListener('click', ()=>{ $('#go-tab-overlay').hidden=true; if(ST.timer) clearInterval(ST.timer); });
  $('#go-refresh').addEventListener('click', refresh);
  $('#go-save').addEventListener('click', ()=>{
    localStorage.setItem('global_overview_base', $('#go-base').value||'PLN');
    localStorage.setItem('global_overview_poll', String($('#go-poll').value||'45'));
    localStorage.setItem('global_overview_tok', ($('#go-token').value||'').trim());
    localStorage.setItem('global_overview_noapi', ($('#go-no-api').checked ? '1' : '0'));
    alert('Zapisano.');
    schedule();
  });
  $('#go-filter').addEventListener('input', refresh);
  const periodSel = document.getElementById('go-period');
  if(periodSel){
    periodSel.addEventListener('change', ()=>{
      try{
        ST.periodKey = periodSel.value || 'all';
        ST.periodRange = getPeriodRange(ST.periodKey);
        setPeriodKey(ST.periodKey);
      }catch(_){}
      refresh();
    });
  }

  $('#go-no-api').addEventListener('change', ()=>{
    localStorage.setItem('global_overview_noapi', ($('#go-no-api').checked ? '1' : '0'));
    refresh();
  });

  const fxInput = document.getElementById('go-fx-usdpln');
  const fxApply = document.getElementById('go-fx-apply');
  const fxClear = document.getElementById('go-fx-clear');
  if (fxApply){
    fxApply.addEventListener('click', ()=>{
      const v = parseFloat(fxInput && fxInput.value ? fxInput.value : '0');
      if (isFinite(v) && v > 0){
        if(!ST.FX['USD']) ST.FX['USD'] = {};
        if(!ST.FX['PLN']) ST.FX['PLN'] = {};
        ST.FX['USD']['PLN'] = v;
        ST.FX['PLN']['USD'] = 1/v;
        localStorage.setItem('global_overview_fx_usdpln', String(v));
        paintFx();
        // przelicz natychmiast totals
        refresh();
      }else{
        alert('Podaj dodatni kurs, np. 4.1234');
      }
    });
  }
  if (fxClear){
    fxClear.addEventListener('click', ()=>{
      localStorage.removeItem('global_overview_fx_usdpln');
      // usuwamy jedynie nadpisanie; pozostawiamy inne kursy
      try{
        if (ST.FX['USD']) delete ST.FX['USD']['PLN'];
        if (ST.FX['PLN']) delete ST.FX['PLN']['USD'];
      }catch(_){}
      paintFx();
      refresh();
    });
  }


  // === [GO Export: CSV / JSON] ===
  (function(){
    function downloadFile(name, mime, data){
      const blob = new Blob([data], {type: mime});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 1000);
    }
    function toCsvCell(v){
      if(v===null || v===undefined) return '';
      const s = String(v).replace(/"/g, '""');
      return /[;"\n,]/.test(s) ? `"${s}"` : s;
    }
    async function exportOverviewJSON(){
      try{
        const comp = await refresh(); // get fresh snapshot
        const now = new Date().toISOString();
        const positionsAgg = buildAllPositions(comp.results);
        const payload = {
          generatedAt: now,
          base: comp.base,
          totals: comp.tot,
          portfolios: comp.results.map(r => ({
            name: r.pf?.name || '—',
            currency: r.pf?.currency || 'PLN',
            equityBase: r.equityBase,
            cashBase: r.cashBase,
            holdingsBase: r.holdingsBase,
            costBase: r.costBase,
            unrealBase: r.unrealBase,
            dayMoveBase: r.dayMoveBase,
            realizedGrossBase: r.realizedGrossBase,
            realizedTaxBase: r.realizedTaxBase,
            realizedNetBase: r.realizedNetBase,
            positions: r.positions
          })),
          positionsAggregated: positionsAgg
        };
        const data = JSON.stringify(payload, null, 2);
        downloadFile(`global_overview_${now.slice(0,10)}.json`, "application/json", data);
      }catch(e){
        console.warn('[GO export json] failed', e);
        alert('Eksport JSON nie powiódł się: '+(e&&e.message?e.message:e));
      }
    }
    async function exportOverviewCSV(){
      try{
        const comp = await refresh(); // fresh snapshot
        const rows = buildAllPositions(comp.results);
        const header = ['Ticker','Portfel','Ilość','Śr. koszt','Koszt własny','Kurs','Wartość','P/L','%','Δ dzienny','Waluta'];
        const lines = [];
        lines.push(header.join(';'));
        for(const r of rows){
          const pct = (r.pct!=null && isFinite(r.pct)) ? (r.pct*100).toFixed(2) : '';
          const dp  = (r.dp!=null && isFinite(r.dp))  ? r.dp.toFixed(2) : '';
          const line = [
            toCsvCell(r.ticker),
            toCsvCell(r.pf),
            toCsvCell(Number(r.qty).toFixed(4)),
            toCsvCell(Number(r.avg).toFixed(4)),
            toCsvCell(Number(r.cost).toFixed(2)),
            toCsvCell(r.price!=null && isFinite(r.price) ? Number(r.price).toFixed(2) : ''),
            toCsvCell(Number(r.value).toFixed(2)),
            toCsvCell(Number(r.pl).toFixed(2)),
            toCsvCell(pct),
            toCsvCell(dp),
            toCsvCell(r.currency||'')
          ].join(';');
          lines.push(line);
        }
        const csv = '\ufeff' + lines.join('\n');
        const now = new Date().toISOString().slice(0,10);
        downloadFile(`global_overview_positions_${now}.csv`, "text/csv;charset=utf-8", csv);
      }catch(e){
        console.warn('[GO export csv] failed', e);
        alert('Eksport CSV nie powiódł się: '+(e&&e.message?e.message:e));
      }
    }
    const btnCsv  = document.getElementById('go-export-csv');
    const btnJson = document.getElementById('go-export-json');
    if(btnCsv)  btnCsv.addEventListener('click', exportOverviewCSV);
    if(btnJson) btnJson.addEventListener('click', exportOverviewJSON);
  })();
})();</script>
<!-- === [/GT ADDON] Global Overview Tab === -->

<script>
// === Helper: ignore inconsistent sell transactions (non-destructive) ===
window.__ignoreInconsistentSells = function(){
  try{
    const pf = getPf(currentPfId); if(!pf) return;
    const ids = new Set();
    const errs = Array.isArray(pf.__errors) ? pf.__errors : [];
    // Pick sells only
    for(const e of errs){
      if(e && /Sprzedaż bez pozycji|Brak partii/.test(e.message||'')){
        // find matching tx by ticker and date (best effort)
        const candidates = (pf.transactions||[]).filter(t => t.type==='sell' && (t.ticker||'').toUpperCase()===(e.ticker||'').toUpperCase());
        // mark all sells for this ticker that would error
        for(const t of candidates){ ids.add(t.id); }
      }
    }
    if(!ids.size){ alert('Brak sprzedaży do zignorowania.'); return; }
    const ok = confirm('Zignorować '+ids.size+' transakcji sprzedaży, które są niespójne? (można cofnąć ↩️ Cofnij)');
    if(!ok) return;
    try{ pushUndo({label:"Ignoruj niespójne sprzedaże", kind:'tx'}); }catch(_){}
    pf.transactions = pf.transactions.map(t => ids.has(t.id) ? Object.assign({}, t, {ignore:true, note: (t.note? t.note+' ' : '')+'[IGNORED: niespójność]'}) : t);
    pf.updatedAt = new Date().toISOString();
    rebuildPortfolio(pf); save(); render();
  }catch(e){
    alert('Operacja nie powiodła się: '+(e && e.message || e));
  }
};
</script>

<script id="auth-gate-js">
(function(){
  // ---- Firebase Init (compat) ----
  try{
    if (!window.__FIREBASE_CONFIG){
      // TODO: wklej poniżej swoje dane konfiguracyjne z Firebase Console → Project settings → General → Your apps (Web)
      window.__FIREBASE_CONFIG = {
  apiKey: "AIzaSyCfhxDgCqOaCfRKxtMECpRSjQU0TTgtGrM",
  authDomain: "mywallets-b55d9.firebaseapp.com",
  projectId: "mywallets-b55d9",
  storageBucket: "mywallets-b55d9.firebasestorage.app",
  messagingSenderId: "724728432741",
  appId: "1:724728432741:web:2a0a6302a68c78fc0ade8c"
};
    }
    if (window.firebase && !firebase.apps.length){
      firebase.initializeApp(window.__FIREBASE_CONFIG);
    }
  }catch(e){ console.error("Firebase init error:", e); }

  var auth = (window.firebase && firebase.auth ? firebase.auth() : null);
  var fs   = (window.firebase && firebase.firestore ? firebase.firestore() : null);

  // Utility toast (falls back to alert)
  function toast(msg){
    try{
      var wrap = document.getElementById('toastsWrap');
      if(!wrap){ alert(msg); return; }
      var el = document.createElement('div');
      el.className = 'toast';
      el.textContent = msg;
      wrap.appendChild(el);
      setTimeout(function(){ el.remove(); }, 2600);
    }catch(_){ alert(msg); }
  }

  function getLocalKey(){
    // Existing app uses a fixed localStorage key. We keep it, but bind lifecycle to current user.
    return "portfele_firmy_v1";
  }
  function readLocalDB(){
    try{ return JSON.parse(localStorage.getItem(getLocalKey()) || "null"); }catch(_){ return null; }
  }
  function writeLocalDB(dbObj){
    try{ localStorage.setItem(getLocalKey(), JSON.stringify(dbObj||{})); }catch(_){}
  }
  function clearLocal(){
    try{ localStorage.removeItem(getLocalKey()); }catch(_){}
  }

  // Firestore paths (per-user)
  function userDocRef(){
    var u = auth && auth.currentUser;
    if(!u || !fs) return null;
    // Path: /users/{uid}/gt/db
    return fs.collection('users').doc(u.uid).collection('gt').doc('db');
  }

  // Exported helpers for existing buttons
  window.hardUpload = async function(){
    try{
      if(!auth || !auth.currentUser) { alert("Zaloguj się najpierw."); return; }
      var ref = userDocRef(); if(!ref){ alert("Brak Firestore."); return; }
      var dbLocal = readLocalDB();
      if(!dbLocal){ alert("Brak danych lokalnych do wysłania."); return; }
      await ref.set({ db: dbLocal, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true });
      toast("☁️ Wysłano bazę do Firestore (konto: " + auth.currentUser.email + ")");
    }catch(e){
      console.error(e); alert("Błąd wysyłania: " + (e && e.message || e));
    }
  };

  window.hardDownload = async function(opts){
    try{
      if(!auth || !auth.currentUser) { alert("Zaloguj się najpierw."); return; }
      var ref = userDocRef(); if(!ref){ alert("Brak Firestore."); return; }
      var snap = await ref.get();
      if(!snap.exists){
        alert("W chmurze jeszcze nie ma danych dla tego konta.");
        return;
      }
      var data = snap.data() || {};
      if(data.db){
        writeLocalDB(data.db);
        // Po aktualizacji lokalnej bazy przeładuj UI (apka sama wczyta dane z localStorage podczas startu)
        location.reload();
      }else{
        alert("Dokument istnieje, ale pole 'db' jest puste.");
      }
    }catch(e){
      console.error(e); alert("Błąd pobierania: " + (e && e.message || e));
    }
  };

  window.hardDiag = async function(){
    try{
      if(!auth) { alert("Auth nie jest gotowy."); return; }
      var u = auth.currentUser;
      if(!u){ alert("Brak zalogowanego użytkownika."); return; }
      var ref = userDocRef(); if(!ref){ alert("Brak Firestore."); return; }
      var snap = await ref.get();
      var msg = "✅ Zalogowano jako: " + (u.email || u.uid) + "\\n"
              + (snap.exists ? "✅ Dokument istnieje w Firestore." : "ℹ️ Dokument jeszcze nie istnieje.");
      alert(msg);
    }catch(e){
      console.error(e); alert("Diag error: " + (e && e.message || e));
    }
  };

  // Attach to existing buttons when present
  function bindFirebaseButtons(){
    try{
      var up = document.getElementById('firebaseUploadBtn');
      var dn = document.getElementById('firebaseDownloadBtn');
      var tg = document.getElementById('firebaseDiagBtn');
      if(up && !up.__bound){ up.addEventListener('click', window.hardUpload); up.__bound = true; }
      if(dn && !dn.__bound){ dn.addEventListener('click', window.hardDownload); dn.__bound = true; }
      if(tg && !tg.__bound){ tg.addEventListener('click', window.hardDiag); tg.__bound = true; }
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', bindFirebaseButtons);
  window.addEventListener('load', bindFirebaseButtons);
  setTimeout(bindFirebaseButtons, 1500);

  // ---- Auth UI ----
  function showBanner(msg){
    var b = document.getElementById('authBanner');
    if(b){ b.textContent = msg; b.style.display = 'flex'; setTimeout(function(){ b.style.display='none'; }, 4200); }
  }
  async function tryBootstrapFromLocal(){
    try{
      var ref = userDocRef(); if(!ref) return;
      var snap = await ref.get();
      if(snap.exists) return; // nothing to do
      var dbLocal = readLocalDB();
      if(dbLocal){
        // Ask user if we should push local data into cloud for the first time
        if(confirm("Nie znaleziono bazy w chmurze dla tego konta. Czy wgrać aktualną bazę z tego urządzenia do Firestore?")){
          await ref.set({ db: dbLocal, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true });
          toast("☁️ Utworzono bazę w chmurze na podstawie danych lokalnych.");
        }
      }
    }catch(e){ console.warn("Bootstrap warn:", e); }
  }

  function enterApp(){
    document.body.classList.remove('require-auth');
    var gate = document.getElementById('authGate'); if(gate) gate.style.display='none';
    // Add "Wyloguj" button dynamically
    try{
      var actions = document.querySelector('header .actions');
      if(actions && !document.getElementById('signOutBtn')){
        var btn = document.createElement('button');
        btn.id = 'signOutBtn';
        btn.className = 'btn ghost';
        btn.title = 'Wyloguj';
        btn.textContent = '🚪 Wyloguj';
        btn.addEventListener('click', async function(){
          try{
            await auth.signOut();
          }catch(e){ alert("Sign out error: " + (e && e.message || e)); }
        });
        actions.appendChild(btn);
      }
    }catch(_){}
  }

  function leaveApp(){
    document.body.classList.add('require-auth');
    var gate = document.getElementById('authGate'); if(gate) gate.style.display='flex';
  }

  function connectForm(){
    var loginBtn = document.getElementById('authLoginBtn');
    var regBtn   = document.getElementById('authRegisterBtn');
    var resetBtn = document.getElementById('authResetBtn');
    var emailEl  = document.getElementById('authEmail');
    var passEl   = document.getElementById('authPassword');
    if(loginBtn){
      loginBtn.addEventListener('click', async function(){
        var email = (emailEl && emailEl.value || '').trim();
        var pass = (passEl && passEl.value || '').trim();
        if(!email || !pass){ showBanner("Podaj e‑mail i hasło."); return; }
        try{
          await auth.signInWithEmailAndPassword(email, pass);
        }catch(e){
          console.error(e); showBanner("Logowanie nieudane: " + (e && e.message || e));
        }
      });
    }
    if(regBtn){
      regBtn.addEventListener('click', async function(){
        var email = (emailEl && emailEl.value || '').trim();
        var pass = (passEl && passEl.value || '').trim();
        if(!email || !pass){ showBanner("Podaj e‑mail i hasło."); return; }
        try{
          await auth.createUserWithEmailAndPassword(email, pass);
          toast("Konto utworzone. Zalogowano.");
        }catch(e){
          console.error(e); showBanner("Rejestracja nieudana: " + (e && e.message || e));
        }
      });
    }
    if(resetBtn){
      resetBtn.addEventListener('click', async function(){
        var email = (emailEl && emailEl.value || '').trim();
        if(!email){ showBanner("Podaj e‑mail do resetu hasła."); return; }
        try{
          await auth.sendPasswordResetEmail(email);
          toast("Wysłano link resetu hasła.");
        }catch(e){
          console.error(e); showBanner("Reset nieudany: " + (e && e.message || e));
        }
      });
    }
  }
  connectForm();

  if(auth){
    auth.onAuthStateChanged(async function(user){
      if(user){
        // Logged in
        enterApp();
        try{
          await tryBootstrapFromLocal();
          // Auto-download latest from cloud and reload the app so it picks up the data
          var ref = userDocRef();
          if(ref){
            var snap = await ref.get();
            if(snap.exists && snap.data() && snap.data().db){
              writeLocalDB(snap.data().db);
              // Reload once to ensure the main app reads the freshly synced DB
              if(!sessionStorage.getItem('__authed_reloaded')){
                sessionStorage.setItem('__authed_reloaded', '1');
                location.reload();
              }
            }
          }
        }catch(e){ console.warn("Post-login sync warn:", e); }
      }else{
        // Logged out
        leaveApp();
        clearLocal(); // prevent mixing data between users on same device
        try{ sessionStorage.removeItem('__authed_reloaded'); }catch(_){}
      }
    });
  }else{
    console.warn("Firebase Auth not available; the auth gate will remain visible.");
  }
})();
</script>
</body>
</html>

<script>
// Sound ticker to honour repeat interval independently of quote polling
if(!window.__soundTicker){
  window.__soundTicker = setInterval(()=>{
    try{ if(window.checkAndPlayPortfolioAlerts) checkAndPlayPortfolioAlerts(); }catch(_){}
    try{ if(window.checkAndPlayWishlistAlert) checkAndPlayWishlistAlert(); }catch(_){}
  }, 1000);
}

/* === Company Notes (localStorage + Firestore sync) === */
(function(){
  const NOTES_KEY = 'companyNotes_v1';
  function loadCompanyNotes(){ try{ return JSON.parse(localStorage.getItem(NOTES_KEY)||'{}')||{}; }catch(_){ return {}; } }
  function saveCompanyNotes(map){ try{ localStorage.setItem(NOTES_KEY, JSON.stringify(map||{})); }catch(_){ } }
  window.getCompanyNote = (ticker)=> (loadCompanyNotes()[(ticker||'').toUpperCase()]||'');
  window.setCompanyNote = (ticker, text)=>{ const m=loadCompanyNotes(); m[(ticker||'').toUpperCase()]=String(text||''); saveCompanyNotes(m); };

  async function saveNoteRemote(ticker, text){
    try{
      const ctx = await (typeof fbInit === 'function' ? fbInit() : null);
      const auth = ctx && ctx.auth, db = ctx && ctx.db;
      if(!auth || !auth.currentUser || !db) return false;
      const uid = auth.currentUser.uid;
      const id = `${uid}_${String(ticker||'').toUpperCase()}`;
      const fv = (window.firebase && window.firebase.firestore && window.firebase.firestore.FieldValue) || null;
      const ts = fv && fv.serverTimestamp ? fv.serverTimestamp() : new Date();
      await db.collection('companyNotes').doc(id).set({ uid, ticker: String(ticker||'').toUpperCase(), note: String(text||''), updatedAt: ts }, { merge: true });
      return true;
    }catch(e){ console.warn('[notes] save remote failed', e); return false; }
  }
  async function loadNoteRemote(ticker){
    try{
      const ctx = await (typeof fbInit === 'function' ? fbInit() : null);
      const auth = ctx && ctx.auth, db = ctx && ctx.db;
      if(!auth || !auth.currentUser || !db) return null;
      const uid = auth.currentUser.uid;
      const id = `${uid}_${String(ticker||'').toUpperCase()}`;
      const snap = await db.collection('companyNotes').doc(id).get();
      return snap.exists ? (snap.data() && (snap.data().note||'')) : null;
    }catch(e){ return null; }
  }

  window.openCompanyInfoModal = async function(ticker){
    let cur = await loadNoteRemote(ticker);
    if (cur == null) cur = getCompanyNote(ticker);

    const data = await openModal({
      title: `Notatka o spółce: ${ticker}`,
      innerHTML: `<form>
        <label>Twoje notatki o spółce</label>
        <textarea name="note" rows="8" style="width:100%">${__esc(cur||'')}</textarea>
        <p class="small muted">Zapisywane lokalnie i synchronizowane z Firestore (jeśli zalogowany).</p>
      </form>`,
      okText: 'Zapisz'
    });
    if(!data) return;

    setCompanyNote(ticker, data.note||'');
    const ok = await saveNoteRemote(ticker, data.note||'');
    try{ showToast && showToast({ title: ok ? 'Zapisano notatkę (Firestore + lokalnie)' : 'Zapisano notatkę (lokalnie)', message: ticker }); }catch(_){}
  };

  const __origExport = window.exportJSON;
  if (typeof __origExport === 'function'){
    window.exportJSON = function(){
      try{ DB.companyNotes = JSON.parse(JSON.stringify(loadCompanyNotes())); }catch(_){}
      return __origExport.apply(this, arguments);
    };
  }
  try{
    document.getElementById('importFile')?.addEventListener('change', ()=>{
      setTimeout(()=>{ try{ if(DB && DB.companyNotes){ localStorage.setItem(NOTES_KEY, JSON.stringify(DB.companyNotes)); } }catch(_){ } }, 0);
    }, {capture:false});
  }catch(_){}
})();
</script>
<!-- ALLOW_RULES_ALERTS_SNIPPET
Suggested Firestore rules for alerts collection (replace with your setup):
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /alerts/{alertId} {
      allow read: if request.auth != null && resource.data.uid == request.auth.uid;
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow update, delete: if request.auth != null && resource.data.uid == request.auth.uid;
    }
  }
}
-->


<script>
(function(){
  if (typeof window.openModal !== 'function'){
    window.openModal = function({title='Informacja', innerHTML='', okText='OK', cancelText='Anuluj'}={}){
      return new Promise((resolve)=>{
        const overlay = document.createElement('div');
        Object.assign(overlay.style, {position:'fixed', inset:'0', background:'rgba(2,6,23,0.66)', backdropFilter:'blur(6px)', zIndex:'99999', display:'flex', alignItems:'center', justifyContent:'center', padding:'16px'});
        const box = document.createElement('div');
        Object.assign(box.style, {background:'linear-gradient(180deg, rgba(17,24,39,.98), rgba(15,23,42,.98))',color:'var(--text)',border:'1px solid #334155',maxWidth:'720px', width:'100%', borderRadius:'16px', padding:'16px',boxShadow:'0 10px 25px rgba(0,0,0,.35)'});
        box.innerHTML = `
          <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px;">
            <h3 style="margin:0;font-size:18px;">${title}</h3>
            <button type="button" class="modal-x" aria-label="Zamknij" style="border:none;background:transparent;font-size:18px;cursor:pointer;color:#94a3b8">×</button>
          </div>
          <div class="modal-body">${innerHTML}</div>
          <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
            <button type="button" class="btn ghost modal-cancel">${cancelText||'Anuluj'}</button>
            <button type="button" class="btn modal-ok">${okText||'OK'}</button>
          </div>`;
        overlay.appendChild(box);
        document.body.appendChild(overlay);
        function cleanup(){ try{ overlay.remove(); }catch(_){} }
        function collectForm(){
          const form = box.querySelector('form');
          if(!form) return undefined;
          const fd = new FormData(form);
          const obj = {}; for (const [k,v] of fd.entries()) obj[k]=v; return obj;
        }
        const cancel = ()=>{ cleanup(); resolve(null); };
        box.querySelector('.modal-ok').addEventListener('click', ()=>{ const data=collectForm(); cleanup(); resolve(data||{}); });
        box.querySelector('.modal-cancel').addEventListener('click', cancel);
        box.querySelector('.modal-x').addEventListener('click', cancel);
        overlay.addEventListener('click', (e)=>{ if(e.target===overlay) cancel(); });
        setTimeout(()=>{ const el = box.querySelector('textarea, input, select, button'); el && el.focus && el.focus(); },0);
      });
    };
  }
})();
document.addEventListener('click', (e)=>{
  const b = e.target.closest('.wl-info'); if(!b) return;
  const t = b.getAttribute('data-ticker'); if(!t) return;
  if (typeof window.openCompanyInfoModal === 'function'){ e.preventDefault(); window.openCompanyInfoModal(t); }
}, true);
</script>


<script>
// === TradingView helpers & global opener ===
(function(){
  function __tvParseSymbol(t){
    var s = String(t||'').toUpperCase().trim();
    if(!s) return '';
    if(s.includes(':')) return s;           // already EXCHANGE:SYMBOL
    if(s.includes('.')){
      var parts = s.split('.');
      var base = parts[0], suf = parts[1];
      if(suf === 'WA') return 'GPW:' + base; // Warsaw GPW
      if(suf === 'L')  return 'LSE:' + base; // London
      if(suf === 'DE') return 'XETR:' + base; // Xetra (best-effort)
      if(suf === 'F')  return 'FWB:' + base;  // Frankfurt best-effort
      return s; // keep suffix (e.g., BRK.B, BF.B) // fallback: strip suffix
    }
    return s; // no exchange
  }
  function makeTradingViewURL(t){
    var sym = __tvParseSymbol(t);
    var q = encodeURIComponent(sym || String(t||'').toUpperCase());
    return 'https://pl.tradingview.com/chart/?symbol=' + q;
  }
  // global delegation (works for holdings + wishlist)
  document.addEventListener('click', function(e){
    var btn = e.target.closest('.tv-link');
    if(!btn) return;
    var t = btn.getAttribute('data-ticker');
    if(!t) return;
    e.preventDefault();
    try{ window.open(makeTradingViewURL(t), '_blank', 'noopener'); }catch(_){ location.href = makeTradingViewURL(t); }
  }, true);
  // expose for potential reuse
  window.makeTradingViewURL = makeTradingViewURL;
})();
</script>
<script id="plus-icon-relabel">
(function(){
  function swap(btn){
    if(!btn) return;
    const txt = (btn.textContent || "").trim();
    if (txt === "+" || txt === "＋") {
      btn.textContent = "➕";
      if (!btn.getAttribute("aria-label")) {
        btn.setAttribute("aria-label","Dodaj partię");
      }
    }
  }
  function apply(){
    const sel = '#holdingsTable
